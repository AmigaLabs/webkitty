Binary files clean/WebKit.161078/Source/JavaScriptCore/API/tests/Programs_minidom-JSNode.o and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/API/tests/Programs_minidom-JSNode.o differ
Binary files clean/WebKit.161078/Source/JavaScriptCore/API/tests/Programs_minidom-JSNodeList.o and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/API/tests/Programs_minidom-JSNodeList.o differ
Binary files clean/WebKit.161078/Source/JavaScriptCore/API/tests/Programs_minidom-Node.o and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/API/tests/Programs_minidom-Node.o differ
Binary files clean/WebKit.161078/Source/JavaScriptCore/API/tests/Programs_minidom-NodeList.o and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/API/tests/Programs_minidom-NodeList.o differ
Binary files clean/WebKit.161078/Source/JavaScriptCore/API/tests/Programs_minidom-minidom.o and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/API/tests/Programs_minidom-minidom.o differ
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/GNUmakefile.list.am attempt-5-161078/WebKit.161078/Source/JavaScriptCore/GNUmakefile.list.am
--- clean/WebKit.161078/Source/JavaScriptCore/GNUmakefile.list.am	2018-05-20 14:50:46.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/GNUmakefile.list.am	2018-06-12 14:28:02.333668694 +0000
@@ -86,12 +86,16 @@
 	Source/JavaScriptCore/assembler/MacroAssemblerARMv7.h \
 	Source/JavaScriptCore/assembler/MacroAssemblerCodeRef.h \
 	Source/JavaScriptCore/assembler/MacroAssemblerMIPS.h \
+	Source/JavaScriptCore/assembler/MacroAssemblerPPC.cpp \
+	Source/JavaScriptCore/assembler/MacroAssemblerPPC.h \
 	Source/JavaScriptCore/assembler/MacroAssemblerSH4.h \
 	Source/JavaScriptCore/assembler/MacroAssemblerX86.h \
 	Source/JavaScriptCore/assembler/MacroAssemblerX86Common.cpp \
 	Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h \
 	Source/JavaScriptCore/assembler/MacroAssemblerX86_64.h \
 	Source/JavaScriptCore/assembler/MIPSAssembler.h \
+	Source/JavaScriptCore/assembler/PPCAssembler.cpp \
+	Source/JavaScriptCore/assembler/PPCAssembler.h \
 	Source/JavaScriptCore/assembler/RepatchBuffer.h \
 	Source/JavaScriptCore/assembler/SH4Assembler.h \
 	Source/JavaScriptCore/assembler/X86Assembler.h \
Binary files clean/WebKit.161078/Source/JavaScriptCore/Programs_jsc_3-jsc.o and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/Programs_jsc_3-jsc.o differ
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/assembler/LinkBuffer.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/LinkBuffer.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/assembler/LinkBuffer.cpp	2018-05-20 14:50:43.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/LinkBuffer.cpp	2018-06-12 14:28:02.313668529 +0000
@@ -36,6 +36,7 @@
 
 LinkBuffer::CodeRef LinkBuffer::finalizeCodeWithoutDisassembly()
 {
+COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     performFinalization();
     
     ASSERT(m_didAllocate);
@@ -134,9 +135,6 @@
 #if DUMP_LINK_STATISTICS
     dumpLinkStatistics(m_code, m_initialSize, m_size);
 #endif
-#if DUMP_CODE
-    dumpCode(m_code, m_size);
-#endif
 }
 #endif
 
@@ -164,6 +162,9 @@
 #elif CPU(ARM64)
     copyCompactAndLinkCode<uint32_t>(ownerUID, effort);
 #endif
+#if DUMP_CODE
+    dumpCode(m_code, m_size);
+#endif
 }
 
 void LinkBuffer::allocate(size_t initialSize, void* ownerUID, JITCompilationEffort effort)
@@ -194,6 +195,7 @@
 
 void LinkBuffer::performFinalization()
 {
+COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
 #ifndef NDEBUG
     ASSERT(!isCompilationThread());
     ASSERT(!m_completed);
@@ -269,6 +271,18 @@
 
     for (unsigned i = 0; i < tsize; i++)
         dataLogF("\t.long\t0x%x\n", tcode[i]);
+#elif CPU(PPC)
+	unsigned int *ppccode;
+	unsigned int i;
+
+	ppccode = (unsigned int *)code;
+
+#if 0
+	foddprintf("Code dump from address %08x start:\n", code);
+	for(i=0;i<size/4;i++)
+		foddprintf("%08x\n", ppccode[i]);
+	foddprintf("Code dump end\n");
+#endif
 #endif
 }
 #endif
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/assembler/LinkBuffer.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/LinkBuffer.h
--- clean/WebKit.161078/Source/JavaScriptCore/assembler/LinkBuffer.h	2018-05-20 14:50:43.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/LinkBuffer.h	2018-06-12 14:28:02.313668529 +0000
@@ -29,7 +29,7 @@
 #if ENABLE(ASSEMBLER)
 
 #define DUMP_LINK_STATISTICS 0
-#define DUMP_CODE 0
+#define DUMP_CODE 1
 
 #define GLOBAL_THUNK_ID reinterpret_cast<void*>(static_cast<intptr_t>(-1))
 #define REGEXP_CODE_ID reinterpret_cast<void*>(static_cast<intptr_t>(-2))
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssembler.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssembler.h
--- clean/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssembler.h	2018-05-20 14:50:43.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssembler.h	2018-06-12 14:28:02.317668562 +0000
@@ -62,6 +62,12 @@
 typedef MacroAssemblerSH4 MacroAssemblerBase;
 };
 
+#elif CPU(PPC)
+#include "MacroAssemblerPPC.h"
+namespace JSC {
+typedef MacroAssemblerPPC MacroAssemblerBase;
+};
+
 #else
 #error "The MacroAssembler is not supported on this platform."
 #endif
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerCodeRef.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerCodeRef.h
--- clean/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerCodeRef.h	2018-05-20 14:50:43.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerCodeRef.h	2018-06-12 14:28:02.313668529 +0000
@@ -34,6 +34,8 @@
 #include <wtf/PrintStream.h>
 #include <wtf/RefPtr.h>
 
+extern "C" { void foddprintf(const char *, ...); }
+
 // ASSERT_VALID_CODE_POINTER checks that ptr is a non-null pointer, and that it is a valid
 // instruction address on the platform (for example, check any alignment requirements).
 #if CPU(ARM_THUMB2) && !ENABLE(LLINT_C_LOOP)
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerPPC.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerPPC.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerPPC.cpp	1970-01-01 00:00:00.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerPPC.cpp	2018-07-17 13:59:22.109398749 +0000
@@ -0,0 +1,1746 @@
+/*
+ * Copyright (C) 2013 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ */
+
+#include "config.h"
+
+#warning remove this
+char *mydebugstring = "JIT: Now calling %08x\n";
+char *dbg_enteringfunc = "JIT: Entering function\n";
+char *dbg_leavingfunc = "JIT: Leaving function\n";
+
+int gencount;
+
+#if ENABLE(ASSEMBLER) && CPU(PPC)
+#include "MacroAssemblerPPC.h"
+#include <stdarg.h>
+
+#define JITOUTPUTDEBUG 0
+#define JITCALLBACKDEBUG 0
+#define JITCOMPILEDEBUG 0
+#define JITEXECUTEDEBUG 0
+#define JITPATCHDEBUG 0
+#define JITVALUEDEBUG 0
+#define JITLOADSTOREDEBUG 0
+#define JITINTARITHDEBUG 0
+
+extern "C"
+{
+	static void dodprintf(va_list va, const char *fmt)
+	{
+#ifdef __MORPHOS__
+		char buf[256];
+
+		vsnprintf(buf, sizeof(buf), fmt, va);
+		dprintf("%s", buf);
+#else
+		vfprintf(stderr, fmt, va);
+#endif
+	}
+
+	void callbackdprintf(const char *fmt, ...)
+	{
+#if JITCALLBACKDEBUG
+		va_list va;
+		va_start(va, fmt);
+		dodprintf(va, fmt);
+		va_end(va);
+#endif
+	}
+
+	void compiledprintf(const char *fmt, ...)
+	{
+#if JITCOMPILEDEBUG
+		va_list va;
+		va_start(va, fmt);
+		dodprintf(va, fmt);
+		va_end(va);
+#endif
+	}
+
+	void executedprintf(const char *fmt, ...)
+	{
+#if JITEXECUTEDEBUG
+		va_list va;
+		va_start(va, fmt);
+		dodprintf(va, fmt);
+		va_end(va);
+#endif
+	}
+
+	void patchdprintf(const char *fmt, ...)
+	{
+#if JITPATCHDEBUG
+		va_list va;
+		va_start(va, fmt);
+		dodprintf(va, fmt);
+		va_end(va);
+#endif
+	}
+
+	void valuedprintf(const char *fmt, ...)
+	{
+#if JITVALUEDEBUG
+		va_list va;
+		va_start(va, fmt);
+		dodprintf(va, fmt);
+		va_end(va);
+#endif
+	}
+}
+
+namespace JSC {
+
+int BreakOnInvalidValue = 0;
+
+void MacroAssemblerPPC::add32(RegisterID src, RegisterID dest)
+{
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Adding 0x%08x to 0x%08x\n", getgencount(), src, dest);
+#endif
+
+	m_assembler.add(dest, dest, src);
+}
+
+void MacroAssemblerPPC::add32(TrustedImm32 imm, RegisterID dest)
+{
+	add32(imm, dest, dest);
+}
+
+void MacroAssemblerPPC::add32(AbsoluteAddress src, RegisterID dest)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	load32(src.m_ptr, scratch);
+	add32(scratch, dest);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::add32(TrustedImm32 imm, RegisterID src, RegisterID dest)
+{
+	uint32_t value;
+
+	value = imm.m_value;
+
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Adding 0x%08x to 0x%08x\n", getgencount(), value, dest);
+#endif
+
+	if ((value&0xffff8000) == 0 || (value&0xffff8000) == 0xffff8000)
+	{
+		m_assembler.addi(dest, src, value&0xffff);
+	}
+	else
+	{
+		if ((value&0x8000))
+			m_assembler.addis(dest, src, (value+1)>>16);
+		else
+			m_assembler.addis(dest, src, value>>16);
+
+		if ((value&0xffff))
+			m_assembler.addi(dest, dest, value&0xffff);
+	}
+}
+
+void MacroAssemblerPPC::add32(TrustedImm32 imm, Address address)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	load32(address, scratch);
+	add32(imm, scratch);
+	store32(scratch, address);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::add32(Address src, RegisterID dest)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	load32(src, scratch);
+	add32(scratch, dest);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::add32(TrustedImm32 imm, AbsoluteAddress address)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	load32(address.m_ptr, scratch);
+	add32(imm, scratch, scratch);
+	store32(scratch, address.m_ptr);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::add64(TrustedImm32 imm, AbsoluteAddress address)
+{
+	RegisterID scratch1, scratch2, scratch3;
+	uint32_t lower;
+
+	scratch1 = getScratchRegister();
+	scratch2 = getScratchRegister();
+	scratch3 = getScratchRegister();
+
+	m_assembler.lis(scratch1, imm.m_value>>16);
+	m_assembler.ori(scratch1, scratch1, imm.m_value&0xffff);
+
+	lower = prepareSignedOffset((void *)(((char *)address.m_ptr) + 4), scratch3);
+	m_assembler.lwz(scratch2, lower, scratch3);
+
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Adding lower 64-bit 0x%08x to 0x%08x\n", getgencount(), scratch1, scratch2);
+#endif
+
+	m_assembler.addo(scratch1, scratch2, scratch1);
+	m_assembler.stw(scratch1, lower, scratch3);
+
+	lower = prepareSignedOffset(address.m_ptr, scratch3);
+	m_assembler.lwz(scratch2, lower, scratch3);
+	m_assembler.li(scratch1, 0);
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Adding upper 64-bit 0x%08x to 0x%08x\n", getgencount(), scratch1, scratch2);
+#endif
+	m_assembler.adde(scratch1, scratch2, scratch1);
+	m_assembler.stw(scratch1, lower, scratch3);
+
+	freeScratchRegister(scratch1);
+	freeScratchRegister(scratch2);
+	freeScratchRegister(scratch3);
+}
+
+// Convert 'src' to an integer, and places the resulting 'dest'.
+// If the result is not representable as a 32 bit value, branch.
+// May also branch for some values that are representable in 32 bits
+// (specifically, in this case, 0).
+void MacroAssemblerPPC::branchConvertDoubleToInt32(FPRegisterID src, RegisterID dest, JumpList& failureCases, FPRegisterID, bool negZeroCheck)
+{
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-16)&0xffff);
+	m_assembler.fctiwz(fpTempRegister, src);
+	m_assembler.stfd(fpTempRegister, (16-8)&0xffff, PPCRegisters::r1);
+	m_assembler.lwz(dest, (16-4)&0xffff, PPCRegisters::r1);
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (16)&0xffff);
+
+	/* fixme: This could be done faster... */
+
+	convertInt32ToDouble(dest, fpTempRegister);
+
+	failureCases.append(branchDouble(DoubleNotEqualOrUnordered, src, fpTempRegister));
+
+	// If the result is zero, it might have been -0.0, and the double comparison won't catch this!
+	if (negZeroCheck)
+		failureCases.append(branchTest32(Zero, dest));
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchDouble(DoubleCondition cond, FPRegisterID left, FPRegisterID right)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+	move(TrustedImm32((int)left), scratch);
+	dprint("JIT@% 3d: left = %d\n", getgencount(), scratch);
+	move(TrustedImm32((int)right), scratch);
+	dprint("JIT@% 3d: right = %d\n", getgencount(), scratch);
+
+	dprint("JIT@% 3d: Comparing %f to %f\n", getgencount(), left, right);
+
+	m_assembler.fcmpu(0, left, right);
+	moveFixedWidthEncoding(TrustedImm32(0), scratch);
+	Jump myjump(m_assembler.label());
+	m_assembler.mtctr(scratch);
+	if (cond == DoubleEqualOrUnordered
+	 || cond == DoubleNotEqualOrUnordered
+	 || cond == DoubleGreaterThanOrUnordered
+	 || cond == DoubleGreaterThanOrEqualOrUnordered
+	 || cond == DoubleLessThanOrUnordered
+	 || cond == DoubleLessThanOrEqualOrUnordered)
+	{
+		m_assembler.bsoctr();
+	}
+
+	if (cond == DoubleEqual || cond == DoubleEqualOrUnordered)
+	{
+		m_assembler.beqctr();
+	}
+	else if (cond == DoubleNotEqual || cond == DoubleNotEqualOrUnordered)
+	{
+		m_assembler.bnectr();
+	}
+	else if (cond == DoubleGreaterThan || cond == DoubleGreaterThanOrUnordered)
+	{
+		m_assembler.bgtctr();
+	}
+	else if (cond == DoubleGreaterThanOrEqual || cond == DoubleGreaterThanOrEqualOrUnordered)
+	{
+		m_assembler.bgectr();
+	}
+	else if (cond == DoubleLessThan || cond == DoubleLessThanOrUnordered)
+	{
+		m_assembler.bltctr();
+	}
+	else if (cond == DoubleLessThanOrEqual || cond == DoubleLessThanOrEqualOrUnordered)
+	{
+		m_assembler.blectr();
+	}
+	else
+	{
+		foddprintf("%s:%d/%s(): lolwut\n", __FILE__, __LINE__, __func__);
+	}
+
+	freeScratchRegister(scratch);
+
+	return myjump;
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchDoubleNonZero(FPRegisterID reg, FPRegisterID fpscratch)
+{
+	RegisterID scratch;
+	uint32_t value;
+
+	dprint("JIT@% 3d: branchDoubleNonZero\n", getgencount());
+
+	scratch = getScratchRegister();
+
+	value = (uint32_t)&doubleZero;
+
+	m_assembler.lis(scratch, value>>16);
+	m_assembler.ori(scratch, scratch, value&0xffff);
+	m_assembler.lfd(fpscratch, 0, scratch);
+
+	freeScratchRegister(scratch);
+
+	Jump unordered = branchDouble(DoubleEqualOrUnordered, reg, fpscratch);
+	Jump result = branchDouble(DoubleNotEqual, reg, fpscratch);
+	unordered.link(this);
+
+	return result;
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchDoubleZeroOrNaN(FPRegisterID reg, FPRegisterID fpscratch)
+{
+	RegisterID scratch;
+	uint32_t value;
+
+	scratch = getScratchRegister();
+
+	value = (uint32_t)&doubleZero;
+
+	m_assembler.lis(scratch, value>>16);
+	m_assembler.ori(scratch, scratch, value&0xffff);
+	m_assembler.lfd(fpscratch, 0, scratch);
+
+	freeScratchRegister(scratch);
+
+	return branchDouble(DoubleEqualOrUnordered, reg, fpscratch);
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchAdd32(ResultCondition cond, RegisterID op1, RegisterID op2, RegisterID dest)
+{
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Adding 0x%08x to 0x%08x\n", getgencount(), op2, op1);
+#endif
+
+	if (cond == Overflow)
+	{
+		m_assembler.addo_dot(dest, op1, op2);
+	}
+	else
+	{
+		m_assembler.add_dot(dest, op1, op2);
+	}
+	return handleResultCondition(cond);
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchAdd32(ResultCondition cond, RegisterID op1, TrustedImm32 imm, RegisterID dest)
+{
+	RegisterID scratch;
+	Jump jump;
+
+	scratch = getScratchRegister();
+
+	load32BitImmediate(scratch, imm.m_value);
+
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Adding 0x%08x to 0x%08x\n", getgencount(), imm, op1);
+#endif
+
+	if (cond == Overflow)
+	{
+		m_assembler.addo_dot(dest, op1, scratch);
+	}
+	else
+	{
+		m_assembler.add_dot(dest, op1, scratch);
+	}
+	jump = handleResultCondition(cond);
+
+	freeScratchRegister(scratch);
+
+	return jump;
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchAdd32(ResultCondition cond, RegisterID src, RegisterID dest)
+{
+	return branchAdd32(cond, dest, src, dest);
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchAdd32(ResultCondition cond, TrustedImm32 imm, RegisterID dest)
+{
+	return branchAdd32(cond, dest, imm, dest);
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchAdd32(ResultCondition cond, TrustedImm32 imm, AbsoluteAddress dest)
+{
+	RegisterID scratch1, scratch2;
+
+	scratch1 = getScratchRegister();
+	scratch2 = getScratchRegister();
+
+	load32(dest.m_ptr, scratch1);
+	move(imm, scratch2);
+
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Adding 0x%08x to 0x%08x\n", getgencount(), scratch2, scratch1);
+#endif
+
+	m_assembler.addo_dot(scratch1, scratch1, scratch2);
+	store32(scratch1, dest.m_ptr);
+
+	freeScratchRegister(scratch1);
+	freeScratchRegister(scratch2);
+
+	return handleResultCondition(cond);
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchSub32(ResultCondition cond, RegisterID op1, RegisterID op2, RegisterID dest)
+{
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Subtracting 0x%08x from 0x%08x\n", getgencount(), op2, op1);
+#endif
+
+	if (cond == Overflow)
+	{
+		m_assembler.subfo_dot(dest, op2, op1);
+	}
+	else
+	{
+		m_assembler.subf_dot(dest, op2, op1);
+	}
+	return handleResultCondition(cond);
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchSub32(ResultCondition cond, RegisterID op1, TrustedImm32 imm, RegisterID dest)
+{
+	RegisterID scratch;
+	Jump jump;
+
+	scratch = getScratchRegister();
+
+	move(imm, scratch);
+
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Subtracting 0x%08x from 0x%08x\n", getgencount(), scratch, op1);
+#endif
+
+	if (cond == Overflow)
+	{
+		m_assembler.subfo_dot(dest, scratch, op1);
+	}
+	else
+	{
+		m_assembler.subf_dot(dest, scratch, op1);
+	}
+
+	jump = handleResultCondition(cond);
+
+	freeScratchRegister(scratch);
+
+	return jump;
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchSub32(ResultCondition cond, RegisterID src, RegisterID dest)
+{
+	return branchSub32(cond, dest, src, dest);
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchSub32(ResultCondition cond, TrustedImm32 imm, RegisterID dest)
+{
+	return branchSub32(cond, dest, imm, dest);
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchTest8(ResultCondition cond, AbsoluteAddress address, TrustedImm32 mask)
+{
+    RegisterID scratch;
+    Jump jump;
+
+    scratch = getScratchRegister();
+
+    move(TrustedImmPtr(address.m_ptr), scratch);
+    load8(Address(scratch), scratch);
+    jump = branchTest32(cond, scratch, mask);
+
+    freeScratchRegister(scratch);
+
+    return jump;
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchTest8(ResultCondition cond, Address address, TrustedImm32 mask)
+{
+    RegisterID scratch;
+    Jump jump;
+
+    scratch = getScratchRegister();
+
+    load8(address, scratch);
+    jump = branchTest32(cond, scratch, mask);
+
+    freeScratchRegister(scratch);
+
+    return jump;
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchTest8(ResultCondition cond, BaseIndex address, TrustedImm32 mask)
+{
+    RegisterID scratch;
+    Jump jump;
+
+    scratch = getScratchRegister();
+
+    load8(address, scratch);
+    jump = branchTest32(cond, scratch, mask);
+
+    freeScratchRegister(scratch);
+
+    return jump;
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchTruncateDoubleToInt32(FPRegisterID src, RegisterID dest, BranchTruncateType branchType)
+{
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-16)&0xffff);
+	m_assembler.fctiwz(fpTempRegister, src);
+	m_assembler.stfd(fpTempRegister, (16-8)&0xffff, PPCRegisters::r1);
+	m_assembler.lwz(dest, (16-4)&0xffff, PPCRegisters::r1);
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (16)&0xffff);
+
+	/* Fixme: This could be done better */
+
+	if (branchType == BranchIfTruncateSuccessful)
+	{
+		Jump retjump;
+		Jump underflow = branch32(Equal, dest, TrustedImm32(-0x80000000));
+		Jump overflow = branch32(Equal, dest, TrustedImm32(0x7fffffff));
+
+		retjump = jump();
+
+		underflow.link(this);
+		overflow.link(this);
+
+		return retjump;
+	}
+	else
+	{
+		Jump retjump;
+		Jump underflow = branch32(Equal, dest, TrustedImm32(-0x80000000));
+		Jump overflow = branch32(NotEqual, dest, TrustedImm32(0x7fffffff));
+
+		underflow.link(this);
+
+		retjump = jump();
+
+		overflow.link(this);
+
+		return retjump;
+	}
+}
+
+MacroAssemblerPPC::Jump MacroAssemblerPPC::branchTruncateDoubleToUint32(FPRegisterID src, RegisterID dest, BranchTruncateType branchType)
+{
+	foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+
+	dprint("JIT@% 3d: " __FILE__ "%d/branchTruncateDoubleToUint32(): Unimplemented\n", getgencount(), __LINE__);
+#if 0
+
+	m_assembler.vcvt_floatingPointToSigned(fpTempRegisterAsSingle(), src);
+	m_assembler.vmov(dest, fpTempRegisterAsSingle());
+#endif
+	
+	Jump overflow = branch32(Equal, dest, TrustedImm32(0x7fffffff));
+	Jump success = branch32(GreaterThanOrEqual, dest, TrustedImm32(0));
+	overflow.link(this);
+
+	if (branchType == BranchIfTruncateSuccessful)
+		return success;
+	
+	Jump failure = jump();
+	success.link(this);
+	return failure;
+}
+
+void MacroAssemblerPPC::breakpoint(uint8_t imm)
+{
+	m_assembler.twi(31, PPCRegisters::r0, 0);
+}
+
+void MacroAssemblerPPC::convertInt32ToDouble(RegisterID src, FPRegisterID dest)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-32)&0xffff);
+
+	m_assembler.xoris(scratch, src, 0x8000);
+	m_assembler.stw(scratch, (32-4)&0xffff, PPCRegisters::r1);
+
+	m_assembler.lis(scratch, 0x4330);
+	m_assembler.stw(scratch, (32-8)&0xffff, PPCRegisters::r1);
+
+	m_assembler.lfd(dest, (32-8)&0xffff, PPCRegisters::r1);
+
+	m_assembler.lis(scratch, 0x8000);
+	m_assembler.stw(scratch, (32-4)&0xffff, PPCRegisters::r1);
+
+	m_assembler.lfd(fpTempRegister, (32-8)&0xffff, PPCRegisters::r1);
+
+	m_assembler.fsub(dest, dest, fpTempRegister);
+
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (32)&0xffff);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::convertInt32ToDouble(Address address, FPRegisterID dest)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	load32(address, scratch);
+	convertInt32ToDouble(scratch, dest);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::convertInt32ToDouble(AbsoluteAddress address, FPRegisterID dest)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	load32(address.m_ptr, scratch);
+	convertInt32ToDouble(scratch, dest);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::convertFloatToDouble(FPRegisterID src, FPRegisterID dst)
+{
+	if (src != dst)
+		m_assembler.fmr(dst, src);
+}
+
+void MacroAssemblerPPC::convertDoubleToFloat(FPRegisterID src, FPRegisterID dst)
+{
+	m_assembler.frsp(dst, src);
+}
+
+void MacroAssemblerPPC::load32(ImplicitAddress address, RegisterID dest)
+{
+	RegisterID scratch;
+	RegisterID base;
+	uint32_t offset;
+
+	scratch = getScratchRegister();
+
+#if JITLOADSTOREDEBUG
+	RegisterID scratch2;
+	scratch2 = getScratchRegister();
+	move(address.base, scratch2);
+	add32(TrustedImm32(address.offset), scratch2);
+#endif
+
+	getBaseOffset(address, &base, &offset, scratch);
+	m_assembler.lwz(dest, offset, base);
+
+#if JITLOADSTOREDEBUG
+	dprint("JIT@% 3d: Loaded %08x from 0x%08x\n", getgencount(), dest, scratch2);
+	freeScratchRegister(scratch2);
+#endif
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::load32(BaseIndex address, RegisterID dest)
+{
+	RegisterID scratch;
+	uint32_t offset;
+
+	scratch = getScratchRegister();
+
+#if JITLOADSTOREDEBUG
+	RegisterID scratch2;
+	scratch2 = getScratchRegister();
+	m_assembler.slwi(scratch2, address.index, (int)address.scale);
+	m_assembler.add(scratch2, scratch2, address.base);
+#endif
+
+	offset = prepareBaseIndex(address, scratch);
+	m_assembler.lwz(dest, offset & 0xffff, scratch);
+
+#if JITLOADSTOREDEBUG
+	dprint("JIT@% 3d: Loaded %08x from 0x%08x\n", getgencount(), dest, scratch2);
+	freeScratchRegister(scratch2);
+#endif
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::load32(const void* address, RegisterID dest)
+{
+	uint32_t lower;
+	lower = prepareSignedOffset(address, dest);
+	m_assembler.lwz(dest, lower, dest);
+
+#if JITLOADSTOREDEBUG
+	RegisterID scratch2;
+	scratch2 = getScratchRegister();
+	m_assembler.lis(scratch2, ((unsigned int)address)>>16);
+	m_assembler.ori(scratch2, scratch2, ((unsigned int)address)&0xffff);
+	dprint("JIT@% 3d: Loaded %08x from 0x%08x\n", getgencount(), dest, scratch2);
+	freeScratchRegister(scratch2);
+#endif
+}
+
+void MacroAssemblerPPC::load8(const void* address, RegisterID dest)
+{
+	load8(AbsoluteAddress(address), dest);
+}
+
+void MacroAssemblerPPC::load8(ImplicitAddress address, RegisterID dest)
+{
+    RegisterID scratch;
+    RegisterID base;
+    uint32_t offset;
+
+    scratch = getScratchRegister();
+
+    getBaseOffset(address, &base, &offset, scratch);
+    m_assembler.lbz(dest, offset, base);
+
+    freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::load8(AbsoluteAddress address, RegisterID dest)
+{
+    RegisterID scratch;
+
+    scratch = getScratchRegister();
+
+#warning Could be optimised by just using a lis/lbz pair
+    load32BitImmediate(scratch, (unsigned int)address.m_ptr);
+    m_assembler.lbz(dest, 0, scratch);
+
+    freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::load8Signed(ImplicitAddress, RegisterID)
+{
+    UNREACHABLE_FOR_PLATFORM();
+}
+
+void MacroAssemblerPPC::load8(BaseIndex address, RegisterID dest)
+{
+    RegisterID scratch;
+    uint32_t offset;
+
+    scratch = getScratchRegister();
+
+    offset = prepareBaseIndex(address, scratch);
+    m_assembler.lbz(dest, offset & 0xffff, scratch);
+
+    freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::load8Signed(BaseIndex address, RegisterID dest)
+{
+    load8(address, dest);
+    m_assembler.extsb(dest, dest);
+}
+
+void MacroAssemblerPPC::move(TrustedImm32 imm, RegisterID dest)
+{
+	load32BitImmediate(dest, imm.m_value);
+
+#if JITLOADSTOREDEBUG
+	dprint("JIT@% 3d: Loaded %08x into r%d\n", getgencount(), dest, (int)dest);
+#endif
+}
+
+void MacroAssemblerPPC::move(RegisterID src, RegisterID dest)
+{
+	if (src != dest)
+		m_assembler.mr(dest, src);
+
+	if (src == PPCRegisters::r1 && dest == PPCRegisters::r3)
+	{
+		dprint("JIT@% 3d: Moving r1 to r%d (r1 = %08x)\n", getgencount(), (int)dest, dest);
+	}
+
+#if JITLOADSTOREDEBUG
+	dprint("JIT@% 3d: Moved %08x from r%d into r%d\n", getgencount(), dest, (int)src, (int)dest);
+#endif
+}
+
+void MacroAssemblerPPC::move(TrustedImmPtr imm, RegisterID dest)
+{
+	move(TrustedImm32(imm), dest);
+}
+
+void MacroAssemblerPPC::moveDoubleToInts(FPRegisterID src, RegisterID dest1, RegisterID dest2)
+{
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-16)&0xffff);
+	m_assembler.stfd(src, (16-16)&0xffff, PPCRegisters::r1);
+	m_assembler.lwz(dest2, (16-16)&0xffff, PPCRegisters::r1);
+	m_assembler.lwz(dest1, (16-12)&0xffff, PPCRegisters::r1);
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (16)&0xffff);
+}
+
+void MacroAssemblerPPC::moveIntsToDouble(RegisterID src1, RegisterID src2, FPRegisterID dest, FPRegisterID scratch)
+{
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-16)&0xffff);
+	m_assembler.stw(src2, (16-16)&0xffff, PPCRegisters::r1);
+	m_assembler.stw(src1, (16-12)&0xffff, PPCRegisters::r1);
+	m_assembler.lfd(dest, (16-16)&0xffff, PPCRegisters::r1);
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (16)&0xffff);
+}
+
+#warning "Push/pop sucks as it will break the ABI's r1 link chain guarantee."
+
+void MacroAssemblerPPC::pop(RegisterID dest)
+{
+	foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+	m_assembler.lwz(dest, 0, PPCRegisters::r1);
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, 4);
+}
+
+void MacroAssemblerPPC::push(RegisterID src)
+{
+	foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+	m_assembler.stw(src, (-4)&0xffff, PPCRegisters::r1);
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-4)&0xffff);
+}
+
+void MacroAssemblerPPC::push(Address address)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	load32(address, scratch);
+	push(scratch);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::push(TrustedImm32 imm)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	move(imm, scratch);
+	push(scratch);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::revertJumpReplacementToBranchPtrWithPatch(CodeLocationLabel instructionStart, RegisterID rd, void* initialValue)
+{
+	foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+	PPCAssembler::revertJumpReplacementToBranchPtrWithPatch(instructionStart.dataLocation(), rd, reinterpret_cast<int>(initialValue));
+}
+
+void MacroAssemblerPPC::rshift32(RegisterID src, RegisterID shiftAmount, RegisterID dest)
+{
+	RegisterID scratch;
+
+	dprint("JIT@% 3d: rshift32 src = %d, shiftAmount = %d, dest = %d\n", getgencount(), src, shiftAmount, dest);
+
+	scratch = getScratchRegister();
+	m_assembler.andi_dot(scratch, shiftAmount, 0x1f);
+
+	dprint("JIT@% 3d: rshift32 adjusted shiftAmount = %d\n", getgencount(), scratch);
+
+	m_assembler.sraw(dest, src, scratch);
+
+	dprint("JIT@% 3d: rshift32 result = %d\n", getgencount(), dest);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::rshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
+{
+	m_assembler.srawi(dest, src, imm.m_value & 0x1f);
+}
+
+CodeLocationLabel MacroAssemblerPPC::startOfBranchPtrWithPatchOnRegister(CodeLocationDataLabelPtr label)
+{
+	foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+	const unsigned twoWordOpSize = 4;
+	return label.labelAtOffset(-twoWordOpSize * 2);
+}
+
+void MacroAssemblerPPC::store32(RegisterID src, ImplicitAddress address)
+{
+	RegisterID scratch;
+	RegisterID base;
+	uint32_t offset;
+
+	scratch = getScratchRegister();
+
+#if JITLOADSTOREDEBUG
+	move(address.base, scratch);
+	add32(TrustedImm32(address.offset), scratch);
+
+	dprint("JIT@% 3d: Storing %08x to 0x%08x\n", getgencount(), src, scratch);
+#endif
+
+	getBaseOffset(address, &base, &offset, scratch);
+
+#if 0
+	if (base == PPCRegisters::r1)
+	{
+		m_assembler.lis(PPCRegisters::r6, offset>>16);
+		m_assembler.ori(PPCRegisters::r6, PPCRegisters::r6, offset&0xffff);
+		m_assembler.add(PPCRegisters::r7, PPCRegisters::r1, PPCRegisters::r6);
+		dprint("JIT@% 3d: Storing %08x to %d(r1) (abs address %08x)\n", getgencount(), src, PPCRegisters::r6, PPCRegisters::r7);
+	}
+
+	if (base == PPCRegisters::r14)
+	{
+		m_assembler.lis(PPCRegisters::r6, offset>>16);
+		m_assembler.ori(PPCRegisters::r6, PPCRegisters::r6, offset&0xffff);
+		m_assembler.add(PPCRegisters::r7, PPCRegisters::r1, PPCRegisters::r6);
+		dprint("JIT@% 3d: Storing %08x to %d(r14) (abs address %08x)\n", getgencount(), src, PPCRegisters::r6, PPCRegisters::r7);
+	}
+#endif
+
+	m_assembler.stw(src, offset, base);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::store32(RegisterID src, BaseIndex address)
+{
+	RegisterID scratch;
+	uint32_t offset;
+
+	scratch = getScratchRegister();
+
+#if JITLOADSTOREDEBUG
+	m_assembler.slwi(scratch, address.index, (int)address.scale);
+	m_assembler.add(scratch, scratch, address.base);
+
+	dprint("JIT@% 3d: Storing %08x to 0x%08x\n", getgencount(), src, scratch);
+#endif
+
+	offset = prepareBaseIndex(address, scratch);
+	m_assembler.stw(src, offset & 0xffff, scratch);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::store32(TrustedImm32 imm, ImplicitAddress address)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+#if JITLOADSTOREDEBUG
+	move(address.base, scratch);
+	add32(TrustedImm32(address.offset), scratch);
+
+	dprint("JIT@% 3d: Storing %08x to 0x%08x\n", getgencount(), imm.m_value, scratch);
+#endif
+
+	move(imm, scratch);
+	store32(scratch, address);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::store32(TrustedImm32 imm, BaseIndex address)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+#if JITLOADSTOREDEBUG
+	m_assembler.slwi(scratch, address.index, (int)address.scale);
+	m_assembler.add(scratch, scratch, address.base);
+
+	dprint("JIT@% 3d: Storing %08x to 0x%08x\n", getgencount(), imm.m_value, scratch);
+#endif
+
+	move(imm, scratch);
+	store32(scratch, address);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::store32(RegisterID src, const void* address)
+{
+	RegisterID scratch;
+	uint32_t lower;
+
+	scratch = getScratchRegister();
+
+#if JITLOADSTOREDEBUG && 0
+	m_assembler.lis(scratch, ((unsigned int)address)>>16);
+	m_assembler.ori(scratch, scratch, ((unsigned int)address)&0xffff);
+	dprint("JIT@% 3d: Storing %08x to 0x%08x\n", getgencount(), src, scratch);
+#endif
+
+	lower = prepareSignedOffset(address, scratch);
+	m_assembler.stw(src, lower, scratch);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::store32(TrustedImm32 imm, const void* address)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+#if JITLOADSTOREDEBUG && 0
+	m_assembler.lis(scratch, ((unsigned int)address)>>16);
+	m_assembler.ori(scratch, scratch, ((unsigned int)address)&0xffff);
+	dprint("JIT@% 3d: Storing %08x to 0x%08x\n", getgencount(), imm.m_value, scratch);
+#endif
+	move(imm, scratch);
+	store32(scratch, address);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::sub32(RegisterID src, RegisterID dest)
+{
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Subtracting 0x%08x from 0x%08x\n", getgencount(), src, dest);
+#endif
+
+	m_assembler.subf(dest, src, dest);
+}
+
+void MacroAssemblerPPC::sub32(TrustedImm32 imm, RegisterID dest)
+{
+	/* Optimise this */
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	load32BitImmediate(scratch, imm.m_value);
+
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Subtracting 0x%08x from 0x%08x\n", getgencount(), scratch, dest);
+#endif
+
+	m_assembler.subf(dest, scratch, dest);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::sub32(TrustedImm32 imm, Address address)
+{
+	/* Optimise this */
+	RegisterID scratch1, scratch2;
+
+	scratch1 = getScratchRegister();
+	scratch2 = getScratchRegister();
+
+	load32BitImmediate(scratch1, imm.m_value);
+	load32(address, scratch2);
+
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Subtracting 0x%08x from 0x%08x\n", getgencount(), scratch1, scratch2);
+#endif
+
+	m_assembler.subf(scratch2, scratch1, scratch2);
+	store32(scratch2, address);
+
+	freeScratchRegister(scratch1);
+	freeScratchRegister(scratch2);
+}
+
+void MacroAssemblerPPC::sub32(Address src, RegisterID dest)
+{
+	RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	load32(src, scratch);
+	sub32(scratch, dest);
+
+	freeScratchRegister(scratch);
+}
+
+void MacroAssemblerPPC::sub32(TrustedImm32 imm, AbsoluteAddress address)
+{
+	RegisterID scratch1, scratch2;
+
+	scratch1 = getScratchRegister();
+	scratch2 = getScratchRegister();
+
+	load32BitImmediate(scratch1, imm.m_value);
+	load32(address.m_ptr, scratch2);
+
+#if INTARITHDEBUG
+	dprint("JIT@% 3d: Subtracting 0x%08x from 0x%08x\n", getgencount(), scratch1, scratch2);
+#endif
+
+	m_assembler.subf(scratch2, scratch1, scratch2);
+	store32(scratch2, address.m_ptr);
+
+	freeScratchRegister(scratch1);
+	freeScratchRegister(scratch2);
+}
+
+#warning Remove from here. Also remove the prototypes in MacroAssemblerPPC.h
+
+void MacroAssemblerPPC::dprintsaveregs()
+{
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-144)&0xffff);
+
+        m_assembler.stw(PPCRegisters::r0, (144-4)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r3, (144-8)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r4, (144-12)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r5, (144-16)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r6, (144-20)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r7, (144-24)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r8, (144-28)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r9, (144-32)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r10, (144-36)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r11, (144-40)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r12, (144-44)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r17, (144-48)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r18, (144-52)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r19, (144-56)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r20, (144-60)&0xffff, PPCRegisters::r1);
+        m_assembler.stw(PPCRegisters::r21, (144-64)&0xffff, PPCRegisters::r1);
+
+	m_assembler.mfctr(PPCRegisters::r0);
+        m_assembler.stw(PPCRegisters::r0, (144-68)&0xffff, PPCRegisters::r1);
+
+	m_assembler.mflr(PPCRegisters::r0);
+        m_assembler.stw(PPCRegisters::r0, (144-72)&0xffff, PPCRegisters::r1);
+
+	m_assembler.mfcr(PPCRegisters::r0);
+        m_assembler.stw(PPCRegisters::r0, (144-76)&0xffff, PPCRegisters::r1);
+
+        m_assembler.lwz(PPCRegisters::r0, (144-4)&0xffff, PPCRegisters::r1);
+
+	m_assembler.stfd(PPCRegisters::f0, (144-88)&0xffff, PPCRegisters::r1);
+	m_assembler.stfd(PPCRegisters::f1, (144-96)&0xffff, PPCRegisters::r1);
+	m_assembler.stfd(PPCRegisters::f2, (144-104)&0xffff, PPCRegisters::r1);
+	m_assembler.stfd(PPCRegisters::f3, (144-112)&0xffff, PPCRegisters::r1);
+	m_assembler.stfd(PPCRegisters::f4, (144-120)&0xffff, PPCRegisters::r1);
+	m_assembler.stfd(PPCRegisters::f5, (144-128)&0xffff, PPCRegisters::r1);
+}
+
+void MacroAssemblerPPC::dprintrestoreregs()
+{
+        m_assembler.lwz(PPCRegisters::r0, (144-68)&0xffff, PPCRegisters::r1);
+	m_assembler.mtctr(PPCRegisters::r0);
+
+        m_assembler.lwz(PPCRegisters::r0, (144-72)&0xffff, PPCRegisters::r1);
+	m_assembler.mtlr(PPCRegisters::r0);
+
+        m_assembler.lwz(PPCRegisters::r0, (144-76)&0xffff, PPCRegisters::r1);
+	m_assembler.mtcr(PPCRegisters::r0);
+
+        m_assembler.lwz(PPCRegisters::r0, (144-4)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r3, (144-8)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r4, (144-12)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r5, (144-16)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r6, (144-20)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r7, (144-24)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r8, (144-28)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r9, (144-32)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r10, (144-36)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r11, (144-40)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r12, (144-44)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r17, (144-48)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r18, (144-52)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r19, (144-56)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r20, (144-60)&0xffff, PPCRegisters::r1);
+        m_assembler.lwz(PPCRegisters::r21, (144-64)&0xffff, PPCRegisters::r1);
+
+	m_assembler.lfd(PPCRegisters::f0, (144-88)&0xffff, PPCRegisters::r1);
+	m_assembler.lfd(PPCRegisters::f1, (144-96)&0xffff, PPCRegisters::r1);
+	m_assembler.lfd(PPCRegisters::f2, (144-104)&0xffff, PPCRegisters::r1);
+	m_assembler.lfd(PPCRegisters::f3, (144-112)&0xffff, PPCRegisters::r1);
+	m_assembler.lfd(PPCRegisters::f4, (144-120)&0xffff, PPCRegisters::r1);
+	m_assembler.lfd(PPCRegisters::f5, (144-128)&0xffff, PPCRegisters::r1);
+
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (144)&0xffff);
+}
+
+void MacroAssemblerPPC::dprint(const char *str)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, RegisterID argreg)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	m_assembler.mr(PPCRegisters::r4, argreg);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, RegisterID argreg1, RegisterID argreg2)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	if (argreg2 == PPCRegisters::r4)
+	{
+		if (argreg1 == PPCRegisters::r5)
+		{
+			m_assembler.mr(PPCRegisters::r3, argreg2);
+			m_assembler.mr(PPCRegisters::r4, argreg1);
+			m_assembler.mr(PPCRegisters::r5, PPCRegisters::r3);
+		}
+		else
+		{
+			m_assembler.mr(PPCRegisters::r5, argreg2);
+			m_assembler.mr(PPCRegisters::r4, argreg1);
+		}
+	}
+	else
+	{
+		m_assembler.mr(PPCRegisters::r4, argreg1);
+		m_assembler.mr(PPCRegisters::r5, argreg2);
+}
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, RegisterID argreg1, RegisterID argreg2, RegisterID argreg3)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	if (argreg1 == PPCRegisters::r5 || argreg1 == PPCRegisters::r6
+	 || argreg2 == PPCRegisters::r4 || argreg2 == PPCRegisters::r6
+	 || argreg3 == PPCRegisters::r4 || argreg3 == PPCRegisters::r5)
+	{
+		m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-32)&0xffff);
+
+		m_assembler.stw(argreg1, (32-4)&0xffff, PPCRegisters::r1);
+		m_assembler.stw(argreg2, (32-8)&0xffff, PPCRegisters::r1);
+		m_assembler.stw(argreg3, (32-12)&0xffff, PPCRegisters::r1);
+
+		m_assembler.lwz(PPCRegisters::r4, (32-4)&0xffff, PPCRegisters::r1);
+		m_assembler.lwz(PPCRegisters::r5, (32-8)&0xffff, PPCRegisters::r1);
+		m_assembler.lwz(PPCRegisters::r6, (32-12)&0xffff, PPCRegisters::r1);
+
+		m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (32)&0xffff);
+	}
+	else
+	{
+		m_assembler.mr(PPCRegisters::r4, argreg1);
+		m_assembler.mr(PPCRegisters::r5, argreg2);
+		m_assembler.mr(PPCRegisters::r6, argreg3);
+}
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, RegisterID argreg2)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	m_assembler.mr(PPCRegisters::r5, argreg2);
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, FPRegisterID fpargreg2)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	m_assembler.fmr(PPCRegisters::f1, fpargreg2);
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.opcode(0x4cc63242);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, RegisterID argreg2, RegisterID argreg3)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	if (argreg2 == PPCRegisters::r6
+	 || argreg3 == PPCRegisters::r5)
+	{
+		m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-32)&0xffff);
+
+		m_assembler.stw(argreg2, (32-8)&0xffff, PPCRegisters::r1);
+		m_assembler.stw(argreg3, (32-12)&0xffff, PPCRegisters::r1);
+
+		m_assembler.lwz(PPCRegisters::r5, (32-8)&0xffff, PPCRegisters::r1);
+		m_assembler.lwz(PPCRegisters::r6, (32-12)&0xffff, PPCRegisters::r1);
+
+		m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (32)&0xffff);
+	}
+	else
+	{
+		m_assembler.mr(PPCRegisters::r5, argreg2);
+		m_assembler.mr(PPCRegisters::r6, argreg3);
+}
+
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, RegisterID argreg2, unsigned int argconst3)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	m_assembler.mr(PPCRegisters::r5, argreg2);
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+	m_assembler.lis(PPCRegisters::r6, argconst3>>16);
+	m_assembler.ori(PPCRegisters::r6, PPCRegisters::r6, argconst3&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, RegisterID argreg2, unsigned int argconst3, unsigned int argconst4)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	m_assembler.mr(PPCRegisters::r5, argreg2);
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+	m_assembler.lis(PPCRegisters::r6, argconst3>>16);
+	m_assembler.ori(PPCRegisters::r6, PPCRegisters::r6, argconst3&0xffff);
+	m_assembler.lis(PPCRegisters::r7, argconst4>>16);
+	m_assembler.ori(PPCRegisters::r7, PPCRegisters::r7, argconst4&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, FPRegisterID fpargreg2, FPRegisterID fpargreg3)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-32)&0xffff);
+
+	m_assembler.stfd(fpargreg2, (32-8)&0xffff, PPCRegisters::r1);
+	m_assembler.stfd(fpargreg3, (32-16)&0xffff, PPCRegisters::r1);
+
+	m_assembler.lfd(PPCRegisters::f1, (32-8)&0xffff, PPCRegisters::r1);
+	m_assembler.lfd(PPCRegisters::f2, (32-16)&0xffff, PPCRegisters::r1);
+
+	m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (32)&0xffff);
+
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.opcode(0x4cc63242);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, RegisterID argreg2, RegisterID argreg3, RegisterID argreg4)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	if (argreg2 == PPCRegisters::r6 || argreg2 == PPCRegisters::r7
+	 || argreg3 == PPCRegisters::r5 || argreg3 == PPCRegisters::r7
+	 || argreg4 == PPCRegisters::r5 || argreg3 == PPCRegisters::r6)
+	{
+		m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-32)&0xffff);
+
+		m_assembler.stw(argreg2, (32-8)&0xffff, PPCRegisters::r1);
+		m_assembler.stw(argreg3, (32-12)&0xffff, PPCRegisters::r1);
+		m_assembler.stw(argreg4, (32-16)&0xffff, PPCRegisters::r1);
+
+		m_assembler.lwz(PPCRegisters::r5, (32-8)&0xffff, PPCRegisters::r1);
+		m_assembler.lwz(PPCRegisters::r6, (32-12)&0xffff, PPCRegisters::r1);
+		m_assembler.lwz(PPCRegisters::r7, (32-16)&0xffff, PPCRegisters::r1);
+
+		m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (32)&0xffff);
+	}
+	else
+	{
+		m_assembler.mr(PPCRegisters::r5, argreg2);
+		m_assembler.mr(PPCRegisters::r6, argreg3);
+		m_assembler.mr(PPCRegisters::r7, argreg4);
+}
+
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, unsigned int argconst2, RegisterID argreg3)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	m_assembler.mr(PPCRegisters::r6, argreg3);
+
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+
+	m_assembler.lis(PPCRegisters::r5, argconst2>>16);
+	m_assembler.ori(PPCRegisters::r5, PPCRegisters::r5, argconst2&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, unsigned int argconst2, RegisterID argreg3, RegisterID argreg4)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	if (argreg3 == PPCRegisters::r7
+	 || argreg4 == PPCRegisters::r6)
+	{
+		m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-32)&0xffff);
+
+		m_assembler.stw(argreg3, (32-8)&0xffff, PPCRegisters::r1);
+		m_assembler.stw(argreg4, (32-12)&0xffff, PPCRegisters::r1);
+
+		m_assembler.lwz(PPCRegisters::r6, (32-8)&0xffff, PPCRegisters::r1);
+		m_assembler.lwz(PPCRegisters::r7, (32-12)&0xffff, PPCRegisters::r1);
+
+		m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (32)&0xffff);
+	}
+	else
+	{
+		m_assembler.mr(PPCRegisters::r6, argreg3);
+		m_assembler.mr(PPCRegisters::r7, argreg4);
+}
+
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+
+	m_assembler.lis(PPCRegisters::r5, argconst2>>16);
+	m_assembler.ori(PPCRegisters::r5, PPCRegisters::r5, argconst2&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, unsigned int argconst2, RegisterID argreg3, RegisterID argreg4, RegisterID argreg5)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	if (argreg3 == PPCRegisters::r7 || argreg3 == PPCRegisters::r8
+	 || argreg4 == PPCRegisters::r6 || argreg4 == PPCRegisters::r8
+	 || argreg5 == PPCRegisters::r6 || argreg5 == PPCRegisters::r7)
+	{
+		m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (-32)&0xffff);
+
+		m_assembler.stw(argreg3, (32-8)&0xffff, PPCRegisters::r1);
+		m_assembler.stw(argreg4, (32-12)&0xffff, PPCRegisters::r1);
+		m_assembler.stw(argreg5, (32-16)&0xffff, PPCRegisters::r1);
+
+		m_assembler.lwz(PPCRegisters::r6, (32-8)&0xffff, PPCRegisters::r1);
+		m_assembler.lwz(PPCRegisters::r7, (32-12)&0xffff, PPCRegisters::r1);
+		m_assembler.lwz(PPCRegisters::r8, (32-16)&0xffff, PPCRegisters::r1);
+
+		m_assembler.addi(PPCRegisters::r1, PPCRegisters::r1, (32)&0xffff);
+	}
+	else
+	{
+		m_assembler.mr(PPCRegisters::r6, argreg3);
+		m_assembler.mr(PPCRegisters::r7, argreg4);
+		m_assembler.mr(PPCRegisters::r8, argreg5);
+}
+
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+
+	m_assembler.lis(PPCRegisters::r5, argconst2>>16);
+	m_assembler.ori(PPCRegisters::r5, PPCRegisters::r5, argconst2&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+void MacroAssemblerPPC::dprint(const char *str, unsigned int argconst1, unsigned int argconst2)
+{
+#if JITOUTPUTDEBUG
+    	EMITPRINTF("<-- dprint start\n");
+
+	dprintsaveregs();
+
+	m_assembler.lis(PPCRegisters::r4, argconst1>>16);
+	m_assembler.ori(PPCRegisters::r4, PPCRegisters::r4, argconst1&0xffff);
+
+	m_assembler.lis(PPCRegisters::r5, argconst2>>16);
+	m_assembler.ori(PPCRegisters::r5, PPCRegisters::r5, argconst2&0xffff);
+
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)foddprintf)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)foddprintf)&0xffff);
+	m_assembler.mtctr(PPCRegisters::r3);
+	m_assembler.lis(PPCRegisters::r3, ((unsigned int)str)>>16);
+	m_assembler.ori(PPCRegisters::r3, PPCRegisters::r3, ((unsigned int)str)&0xffff);
+	m_assembler.bctrl();
+
+	dprintrestoreregs();
+
+    	EMITPRINTF("dprint end -->\n");
+#endif
+}
+
+#warning Remove to here
+
+} // namespace JSC
+
+#endif // ENABLE(ASSEMBLER)
+
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerPPC.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerPPC.h
--- clean/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerPPC.h	1970-01-01 00:00:00.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/MacroAssemblerPPC.h	2018-07-16 07:51:56.445084167 +0000
@@ -0,0 +1,1985 @@
+/*
+ * Copyright (C) 2009, 2010 Apple Inc. All rights reserved.
+ * Copyright (C) 2010 University of Szeged
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ */
+
+#ifndef MacroAssemblerPPC_h
+#define MacroAssemblerPPC_h
+
+#if ENABLE(ASSEMBLER)
+
+extern "C"
+{
+	void callbackdprintf(const char *, ...);
+	void compiledprintf(const char *, ...);
+	void executedprintf(const char *, ...);
+	void valuedprintf(const char *, ...);
+}
+
+#define CALLBACKDPRINTF(x...) callbackdprintf(x)
+#define COMPILEDPRINTF(x...) compiledprintf(x)
+#define EXECUTEDPRINTF(x...) executedprintf(x)
+#define VALUEDPRINTF(x...) valuedprintf(x)
+
+#include "PPCAssembler.h"
+#include "AbstractMacroAssembler.h"
+
+extern char *mydebugstring;
+extern char *dbg_leavingfunc;
+
+extern int gencount;
+
+namespace JSC {
+
+struct JITStackFrame;
+
+static const double doubleZero = 0.0;
+
+class MacroAssemblerPPC : public AbstractMacroAssembler<PPCAssembler> {
+    static const PPCRegisters::FPRegisterID fpTempRegister = PPCRegisters::f7;
+
+public:
+    MacroAssemblerPPC()
+        : m_regsFree(0xf0001800),
+          m_scratchRegs(m_regsFree)
+    {
+    	m_gencount = gencount++;
+
+	m_assembler.setgencount(m_gencount);
+
+	if (m_gencount == 101 && 0)
+	{
+		m_doemitdebug = 1;
+		m_assembler.enabledebug();
+	}
+	else
+		m_doemitdebug = 0;
+    }
+
+    ~MacroAssemblerPPC()
+    {
+	if (m_regsFree != m_scratchRegs)
+        {
+            foddprintf("%s:%d/%s(): m_regsFree %08x doesn't match m_scratchRegs %08x\n", __FILE__, __LINE__, __func__, m_regsFree, m_scratchRegs);
+        }
+    }
+
+    int getgencount()
+    {
+    	return m_gencount;
+    }
+
+    static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
+    {
+        return value >= -255 && value <= 255;
+    }
+
+public:
+    typedef PPCRegisters::FPRegisterID FPRegisterID;
+
+    static const Scale ScalePtr = TimesFour;
+
+    enum RelationalCondition {
+        Equal,
+        NotEqual,
+        Above,
+        AboveOrEqual,
+        Below,
+        BelowOrEqual,
+        GreaterThan,
+        GreaterThanOrEqual,
+        LessThan,
+        LessThanOrEqual,
+    };
+
+    enum ResultCondition {
+        Overflow,
+        Signed,
+        PositiveOrZero,
+        Zero,
+        NonZero,
+    };
+
+    enum DoubleCondition {
+        // These conditions will only evaluate to true if the comparison is ordered - i.e. neither operand is NaN.
+        DoubleEqual,
+        DoubleNotEqual,
+        DoubleGreaterThan,
+        DoubleGreaterThanOrEqual,
+        DoubleLessThan,
+        DoubleLessThanOrEqual,
+        // If either operand is NaN, these conditions always evaluate to true.
+        DoubleEqualOrUnordered,
+        DoubleNotEqualOrUnordered,
+        DoubleGreaterThanOrUnordered,
+        DoubleGreaterThanOrEqualOrUnordered,
+        DoubleLessThanOrUnordered,
+        DoubleLessThanOrEqualOrUnordered,
+    };
+
+    static const RegisterID stackPointerRegister = PPCRegisters::r1;
+    static const RegisterID framePointerRegister = PPCRegisters::fp;
+
+    // Integer arithmetic operations:
+    //
+    // Operations are typically two operand - operation(source, srcDst)
+    // For many operations the source may be an TrustedImm32, the srcDst operand
+    // may often be a memory location (explictly described using an Address
+    // object).
+
+private:
+    RegisterID getScratchRegister(void)
+    {
+        uint32_t mask;
+        uint32_t regnum;
+
+        if (!m_regsFree)
+        {
+            foddprintf("%s:%d/%s(): Out of free scratch registers!\n", __FILE__, __LINE__, __func__);
+
+            return PPCRegisters::r0;
+        }
+
+        mask = m_regsFree^(m_regsFree&(m_regsFree-1));
+
+        for(regnum=0;(mask&1)==0;mask>>=1,regnum++);
+
+	m_regsFree &= ~(1<<regnum);
+
+        return (RegisterID)regnum;
+    }
+
+    void freeScratchRegister(RegisterID reg)
+    {
+        uint32_t regnum;
+
+        regnum = reg;
+
+        m_regsFree |= (1<<regnum);
+    }
+
+    void load32BitImmediate(RegisterID dest, uint32_t value)
+    {
+        if ((value&0xffff8000) == 0 || (value&0xffff8000) == 0xffff8000)
+        {
+            m_assembler.li(dest, value&0xffff);
+        }
+        else
+        {
+            m_assembler.lis(dest, value>>16);
+            if ((value&0xffff))
+                m_assembler.ori(dest, dest, value&0xffff);
+        }
+    }
+
+public:
+
+    void add32(RegisterID src, RegisterID dest);
+    void add32(TrustedImm32 imm, RegisterID dest);
+    void add32(AbsoluteAddress src, RegisterID dest);
+    void add32(TrustedImm32 imm, RegisterID src, RegisterID dest);
+    void add32(TrustedImm32 imm, Address address);
+    void add32(Address src, RegisterID dest);
+    void add32(TrustedImm32 imm, AbsoluteAddress address);
+    void add64(TrustedImm32 imm, AbsoluteAddress address);
+
+    void and32(RegisterID op1, RegisterID op2, RegisterID dest)
+    {
+        m_assembler.and_(dest, op1, op2);
+    }
+
+    void and32(TrustedImm32 imm, RegisterID src, RegisterID dest)
+    {
+        if (src == dest)
+        {
+            RegisterID scratch;
+    
+            scratch = getScratchRegister();
+    
+            load32BitImmediate(scratch, imm.m_value);
+            m_assembler.and_(dest, src, scratch);
+    
+            freeScratchRegister(scratch);
+        }
+        else
+        {
+            load32BitImmediate(dest, imm.m_value);
+            m_assembler.and_(dest, src, dest);
+        }
+    }
+
+    void and32(RegisterID src, RegisterID dest)
+    {
+        and32(dest, src, dest);
+    }
+
+    void and32(TrustedImm32 imm, RegisterID dest)
+    {
+        and32(imm, dest, dest);
+    }
+
+    void and32(Address src, RegisterID dest)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        load32(src, scratch);
+        and32(scratch, dest);
+
+        freeScratchRegister(scratch);
+    }
+
+    void countLeadingZeros32(RegisterID src, RegisterID dest)
+    {
+        m_assembler.cntlzw(dest, src);
+    }
+
+    void lshift32(RegisterID src, RegisterID shiftAmount, RegisterID dest)
+    {
+        m_assembler.slw(dest, src, shiftAmount);
+    }
+
+    void lshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
+    {
+        m_assembler.slwi(dest, src, imm.m_value & 0x1f);
+    }
+
+    void lshift32(RegisterID shiftAmount, RegisterID dest)
+    {
+        lshift32(dest, shiftAmount, dest);
+    }
+
+    void lshift32(TrustedImm32 imm, RegisterID dest)
+    {
+        lshift32(dest, imm, dest);
+    }
+
+    void mul32(RegisterID src, RegisterID dest)
+    {
+        m_assembler.mullw(dest, dest, src);
+    }
+
+    void mul32(TrustedImm32 imm, RegisterID src, RegisterID dest)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        move(imm, scratch);
+        m_assembler.mullw(dest, src, scratch);
+
+        freeScratchRegister(scratch);
+    }
+
+    void neg32(RegisterID srcDest)
+    {
+        m_assembler.neg(srcDest, srcDest);
+    }
+
+    void or32(RegisterID src, RegisterID dest)
+    {
+        m_assembler.or_(dest, dest, src);
+    }
+    
+    void or32(RegisterID src, AbsoluteAddress dest)
+    {
+        /* Optimise this */
+
+        RegisterID scratch1, scratch2;
+
+        scratch1 = getScratchRegister();
+        scratch2 = getScratchRegister();
+
+        move(TrustedImmPtr(dest.m_ptr), scratch1);
+        load32(scratch1, scratch2);
+        or32(src, scratch2);
+        store32(scratch2, scratch1);
+
+        freeScratchRegister(scratch1);
+        freeScratchRegister(scratch2);
+    }
+
+    void or32(TrustedImm32 imm, RegisterID dest)
+    {
+        or32(imm, dest, dest);
+    }
+
+    void or32(RegisterID op1, RegisterID op2, RegisterID dest)
+    {
+        m_assembler.or_(dest, op1, op2);
+    }
+
+    void or32(TrustedImm32 imm, RegisterID src, RegisterID dest)
+    {
+        uint32_t value;
+
+        value = imm.m_value;
+
+        if (value&0xffff0000)
+            m_assembler.oris(dest, src, value>>16);
+
+        if (value&0xffff)
+            m_assembler.ori(dest, src, value&0xffff);
+    }
+
+    void rshift32(RegisterID src, RegisterID shiftAmount, RegisterID dest);
+    void rshift32(RegisterID src, TrustedImm32 imm, RegisterID dest);
+
+    void rshift32(RegisterID shiftAmount, RegisterID dest)
+    {
+        rshift32(dest, shiftAmount, dest);
+    }
+    
+    void rshift32(TrustedImm32 imm, RegisterID dest)
+    {
+        rshift32(dest, imm, dest);
+    }
+
+    void urshift32(RegisterID src, RegisterID shiftAmount, RegisterID dest)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+	m_assembler.andi_dot(scratch, shiftAmount, 0x1f);
+
+        m_assembler.srw(dest, src, scratch);
+
+        freeScratchRegister(scratch);
+    }
+    
+    void urshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
+    {
+        m_assembler.srwi(dest, src, imm.m_value & 0x1f);
+    }
+
+    void urshift32(RegisterID shiftAmount, RegisterID dest)
+    {
+        urshift32(dest, shiftAmount, dest);
+    }
+    
+    void urshift32(TrustedImm32 imm, RegisterID dest)
+    {
+        urshift32(dest, imm, dest);
+    }
+
+    void sub32(RegisterID src, RegisterID dest);
+    void sub32(TrustedImm32 imm, RegisterID dest);
+    void sub32(TrustedImm32 imm, Address address);
+    void sub32(Address src, RegisterID dest);
+    void sub32(TrustedImm32 imm, AbsoluteAddress address);
+
+    void xor32(RegisterID op1, RegisterID op2, RegisterID dest)
+    {
+        m_assembler.xor_(dest, op1, op2);
+    }
+
+    void xor32(TrustedImm32 imm, RegisterID src, RegisterID dest)
+    {
+        uint32_t value;
+
+        value = imm.m_value;
+
+        if (value == 0)
+        {
+            if (src != dest)
+            {
+                m_assembler.mr(dest, src);
+            }
+        }
+        else
+        {
+#if 0
+            if ((value&0xffff0000) || src != dest)
+                m_assembler.xoris(dest, src, value>>16);
+
+            if ((value&0x0000ffff) || src != dest)
+                m_assembler.xori(dest, src, value&0xffff);
+#else
+            if ((value&0xffff0000) == 0)
+            {
+                m_assembler.xori(dest, src, value);
+            }
+            else if ((value&0x0000ffff) == 0)
+            {
+                m_assembler.xoris(dest, src, (value>>16));
+            }
+            else
+            {
+                RegisterID scratch;
+
+                scratch = getScratchRegister();
+        
+                load32BitImmediate(scratch, value);
+                m_assembler.xor_(dest, src, scratch);
+        
+                freeScratchRegister(scratch);
+            }
+#endif
+        }
+    }
+
+    void xor32(RegisterID src, RegisterID dest)
+    {
+        xor32(dest, src, dest);
+    }
+
+    void xor32(TrustedImm32 imm, RegisterID dest)
+    {
+        xor32(imm, dest, dest);
+    }
+
+    // Memory access operations:
+    //
+    // Loads are of the form load(address, destination) and stores of the form
+    // store(source, address).  The source for a store may be an TrustedImm32.  Address
+    // operand objects to loads and store will be implicitly constructed if a
+    // register is passed.
+
+private:
+    void getBaseOffset(ImplicitAddress address, RegisterID *baseptr, uint32_t *offsetptr, RegisterID scratch)
+    {
+        RegisterID base = address.base;
+        int32_t offset = address.offset;
+
+        if (offset >= -32768 && offset <= 32767)
+        {
+            *baseptr = base;
+            *offsetptr = offset&0xffff;
+        }
+        else
+        {
+            load32BitImmediate(scratch, offset);
+            m_assembler.add(scratch, scratch, base);
+
+            *baseptr = scratch;
+            *offsetptr = 0;
+        }
+    }
+
+    uint32_t prepareSignedOffset(const void *address, RegisterID reg)
+    {
+        unsigned int value;
+        unsigned int upper;
+        unsigned int lower;
+
+        value = (unsigned int)address;
+
+        upper = value>>16;
+        lower = value&0xffff;
+
+        if ((lower&0x8000))
+            upper++;
+
+        m_assembler.lis(reg, upper);
+
+        return lower;
+    }
+
+    uint32_t prepareBaseIndex(BaseIndex baseindex, RegisterID reg)
+    {
+        uint32_t newoffset;
+
+        if (baseindex.base != reg && baseindex.index != reg && baseindex.base != baseindex.index)
+        {
+            if (baseindex.scale)
+            {
+                m_assembler.slwi(reg, baseindex.index, (int)baseindex.scale);
+                m_assembler.add(reg, reg, baseindex.base);
+            }
+            else
+            {
+            	m_assembler.add(reg, baseindex.base, baseindex.index);
+            }
+
+            if (baseindex.offset >= -32768 && baseindex.offset <= 32767)
+            {
+            	newoffset = baseindex.offset;
+            }
+            else
+            {
+            	m_assembler.addis(reg, reg, (baseindex.offset + 0x8000)>>16);
+            	m_assembler.addi(reg, reg, baseindex.offset&0xffff);
+            	newoffset = 0;
+            }
+        }
+        else
+        {
+            foddprintf("%s:%d/%s(): Can't handle base %d index %d reg %d\n", __FILE__, __LINE__, __func__, baseindex.base, baseindex.index, reg);
+            newoffset = 0;
+        }
+
+        return newoffset;
+    }
+
+public:
+    void load32(ImplicitAddress address, RegisterID dest);
+    void load32(BaseIndex address, RegisterID dest);
+    void load32(const void* address, RegisterID dest);
+
+    void load32WithUnalignedHalfWords(BaseIndex address, RegisterID dest)
+    {
+        load32(address, dest);
+    }
+
+    void load16Unaligned(BaseIndex address, RegisterID dest)
+    {
+        load16(address, dest);
+    }
+
+    ConvertibleLoadLabel convertibleLoadPtr(Address address, RegisterID dest)
+    {
+        ConvertibleLoadLabel result(this);
+	ASSERT(address.offset >= 0 && address.offset <= 255);
+	m_assembler.lwz(dest, address.offset, address.base);
+        return result;
+    }
+
+    void load8(const void* address, RegisterID dest);
+    void load8(ImplicitAddress address, RegisterID dest);
+    void load8(AbsoluteAddress address, RegisterID dest);
+    void load8Signed(ImplicitAddress, RegisterID);
+    void load8(BaseIndex address, RegisterID dest);
+    void load8Signed(BaseIndex address, RegisterID dest);
+
+    DataLabel32 load32WithAddressOffsetPatch(Address address, RegisterID dest)
+    {
+        foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+        DataLabel32 label(this);
+        return label;
+    #if 0
+        DataLabel32 label = moveWithPatch(TrustedImm32(address.offset), dataTempRegister);
+        load32(ArmAddress(address.base, dataTempRegister), dest);
+        return label;
+#endif
+    }
+    
+    DataLabelCompact load32WithCompactAddressOffsetPatch(Address address, RegisterID dest)
+    {
+        DataLabelCompact label(this);
+	m_assembler.lwz(dest, address.offset, address.base);
+        return label;
+    }
+
+    void load16(BaseIndex address, RegisterID dest)
+    {
+        RegisterID scratch;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        offset = prepareBaseIndex(address, scratch);
+        m_assembler.lhz(dest, offset & 0xffff, scratch);
+
+        freeScratchRegister(scratch);
+    }
+    
+    void load16Signed(BaseIndex address, RegisterID dest)
+    {
+        load16(address, dest);
+        m_assembler.extsh(dest, dest);
+    }
+    
+    void load16(ImplicitAddress address, RegisterID dest)
+    {
+        RegisterID scratch;
+        RegisterID base;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        getBaseOffset(address, &base, &offset, scratch);
+        m_assembler.lhz(dest, offset, base);
+
+        freeScratchRegister(scratch);
+    }
+    
+    void load16Signed(ImplicitAddress, RegisterID)
+    {
+        UNREACHABLE_FOR_PLATFORM();
+    }
+
+    DataLabel32 store32WithAddressOffsetPatch(RegisterID src, Address address)
+    {
+        RegisterID scratch;
+
+	scratch = getScratchRegister();
+
+	DataLabel32 label = moveWithPatch(TrustedImm32(address.offset), scratch);
+	m_assembler.add(scratch, scratch, address.base);
+	m_assembler.stw(src, 0, scratch);
+
+	freeScratchRegister(scratch);
+
+        return label;
+    }
+
+    void store32(RegisterID src, ImplicitAddress address);
+    void store32(RegisterID src, BaseIndex address);
+    void store32(TrustedImm32 imm, ImplicitAddress address);
+    void store32(TrustedImm32 imm, BaseIndex address);
+    void store32(RegisterID src, const void* address);
+    void store32(TrustedImm32 imm, const void* address);
+
+    void store8(RegisterID src, BaseIndex address)
+    {
+        RegisterID scratch;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        offset = prepareBaseIndex(address, scratch);
+        m_assembler.stb(src, offset & 0xffff, scratch);
+
+        freeScratchRegister(scratch);
+    }
+    
+    void store8(RegisterID src, void* address)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        move(TrustedImmPtr(address), scratch);
+        m_assembler.stb(src, 0, scratch);
+
+        freeScratchRegister(scratch);
+    }
+    
+    void store8(TrustedImm32 imm, void* address)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        move(imm, scratch);
+        store8(scratch, address);
+
+        freeScratchRegister(scratch);
+    }
+    
+    void store16(RegisterID src, BaseIndex address)
+    {
+        RegisterID scratch;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        offset = prepareBaseIndex(address, scratch);
+        m_assembler.sth(src, offset & 0xffff, scratch);
+
+        freeScratchRegister(scratch);
+    }
+
+    void moveDoubleToInts(FPRegisterID src, RegisterID dest1, RegisterID dest2);
+    
+    void moveIntsToDouble(RegisterID src1, RegisterID src2, FPRegisterID dest, FPRegisterID scratch);
+
+#if ENABLE(JIT_CONSTANT_BLINDING)
+    static bool shouldBlindForSpecificArch(uint32_t value)
+    {
+#warning Fixme?
+        return false;
+    }
+#endif
+
+    // Floating-point operations:
+
+    static bool supportsFloatingPoint() { return true; }
+    static bool supportsFloatingPointTruncate() { return true; }
+    static bool supportsFloatingPointSqrt() { return false; }
+    static bool supportsFloatingPointAbs() { return true; }
+
+    void loadDouble(ImplicitAddress address, FPRegisterID dest)
+    {
+        RegisterID scratch;
+        RegisterID base;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        getBaseOffset(address, &base, &offset, scratch);
+        m_assembler.lfd(dest, offset, base);
+
+        freeScratchRegister(scratch);
+    }
+
+    void loadFloat(ImplicitAddress address, FPRegisterID dest)
+    {
+        RegisterID scratch;
+        RegisterID base;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        getBaseOffset(address, &base, &offset, scratch);
+        m_assembler.lfs(dest, offset, base);
+
+        freeScratchRegister(scratch);
+    }
+
+    void loadDouble(BaseIndex address, FPRegisterID dest)
+    {
+        RegisterID scratch;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        offset = prepareBaseIndex(address, scratch);
+        m_assembler.lfd(dest, offset & 0xffff, scratch);
+
+        freeScratchRegister(scratch);
+    }
+    
+    void loadFloat(BaseIndex address, FPRegisterID dest)
+    {
+        RegisterID scratch;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        offset = prepareBaseIndex(address, scratch);
+        m_assembler.lfs(dest, offset & 0xffff, scratch);
+
+        freeScratchRegister(scratch);
+    }
+
+    void moveDouble(FPRegisterID src, FPRegisterID dest)
+    {
+        if (src != dest)
+            m_assembler.fmr(dest, src);
+    }
+
+    void loadDouble(const void* address, FPRegisterID dest)
+    {
+        RegisterID scratch;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        offset = prepareSignedOffset(address, scratch);
+        m_assembler.lfd(dest, offset, scratch);
+
+        freeScratchRegister(scratch);
+    }
+
+    void storeDouble(FPRegisterID src, ImplicitAddress address)
+    {
+        RegisterID scratch;
+        RegisterID base;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        getBaseOffset(address, &base, &offset, scratch);
+        m_assembler.stfd(src, offset, base);
+
+        freeScratchRegister(scratch);
+    }
+
+    void storeFloat(FPRegisterID src, ImplicitAddress address)
+    {
+        RegisterID scratch;
+        RegisterID base;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        getBaseOffset(address, &base, &offset, scratch);
+        m_assembler.stfs(src, offset, base);
+
+        freeScratchRegister(scratch);
+    }
+
+    void storeDouble(FPRegisterID src, const void* address)
+    {
+        RegisterID scratch;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        offset = prepareSignedOffset(address, scratch);
+        m_assembler.stfd(src, offset, scratch);
+
+        freeScratchRegister(scratch);
+    }
+
+    void storeDouble(FPRegisterID src, BaseIndex address)
+    {
+        RegisterID scratch;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        offset = prepareBaseIndex(address, scratch);
+        m_assembler.stfd(src, offset & 0xffff, scratch);
+
+        freeScratchRegister(scratch);
+    }
+    
+    void storeFloat(FPRegisterID src, BaseIndex address)
+    {
+        RegisterID scratch;
+        uint32_t offset;
+
+        scratch = getScratchRegister();
+
+        offset = prepareBaseIndex(address, scratch);
+        m_assembler.stfs(src, offset & 0xffff, scratch);
+
+        freeScratchRegister(scratch);
+    }
+    
+    void addDouble(FPRegisterID src, FPRegisterID dest)
+    {
+    	dprint("JIT@% 3d: addDouble: %f + %f\n", getgencount(), src, dest);
+        m_assembler.fadd(dest, dest, src);
+    	dprint("JIT@% 3d: addDouble: = %f\n", getgencount(), dest);
+    }
+
+    void addDouble(Address src, FPRegisterID dest)
+    {
+        loadDouble(src, fpTempRegister);
+        addDouble(fpTempRegister, dest);
+    }
+
+    void addDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
+    {
+        m_assembler.fadd(dest, op1, op2);
+    }
+
+    void addDouble(AbsoluteAddress address, FPRegisterID dest)
+    {
+        loadDouble(address.m_ptr, fpTempRegister);
+        m_assembler.fadd(dest, dest, fpTempRegister);
+    }
+
+    void divDouble(FPRegisterID src, FPRegisterID dest)
+    {
+        m_assembler.fdiv(dest, dest, src);
+    }
+
+    void divDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
+    {
+        m_assembler.fdiv(dest, op1, op2);
+    }
+
+    void subDouble(FPRegisterID src, FPRegisterID dest)
+    {
+        m_assembler.fsub(dest, dest, src);
+    }
+
+    void subDouble(Address src, FPRegisterID dest)
+    {
+        loadDouble(src, fpTempRegister);
+        subDouble(fpTempRegister, dest);
+    }
+
+    void subDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
+    {
+        m_assembler.fsub(dest, op1, op2);
+    }
+
+    void mulDouble(FPRegisterID src, FPRegisterID dest)
+    {
+        m_assembler.fmul(dest, dest, src);
+    }
+
+    void mulDouble(Address src, FPRegisterID dest)
+    {
+        loadDouble(src, fpTempRegister);
+        mulDouble(fpTempRegister, dest);
+    }
+
+    void mulDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
+    {
+        m_assembler.fmul(dest, op1, op2);
+    }
+
+    void sqrtDouble(FPRegisterID src, FPRegisterID dest)
+    {
+        m_assembler.fsqrt(dest, src);
+    }
+    
+    void absDouble(FPRegisterID src, FPRegisterID dest)
+    {
+        m_assembler.fabs(dest, src);
+    }
+
+    void negateDouble(FPRegisterID src, FPRegisterID dest)
+    {
+        m_assembler.fneg(dest, src);
+    }
+
+    void convertInt32ToDouble(RegisterID src, FPRegisterID dest);
+    void convertInt32ToDouble(Address address, FPRegisterID dest);
+    void convertInt32ToDouble(AbsoluteAddress address, FPRegisterID dest);
+    void convertFloatToDouble(FPRegisterID src, FPRegisterID dst);
+    void convertDoubleToFloat(FPRegisterID src, FPRegisterID dst);
+
+    Jump branchDouble(DoubleCondition cond, FPRegisterID left, FPRegisterID right);
+
+    enum BranchTruncateType { BranchIfTruncateFailed, BranchIfTruncateSuccessful };
+    Jump branchTruncateDoubleToInt32(FPRegisterID src, RegisterID dest, BranchTruncateType branchType = BranchIfTruncateFailed);
+    Jump branchTruncateDoubleToUint32(FPRegisterID src, RegisterID dest, BranchTruncateType branchType = BranchIfTruncateFailed);
+
+    // Result is undefined if the value is outside of the integer range.
+    void truncateDoubleToInt32(FPRegisterID src, RegisterID dest)
+    {
+        foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+    #if 0
+        m_assembler.vcvt_floatingPointToSigned(fpTempRegisterAsSingle(), src);
+        m_assembler.vmov(dest, fpTempRegisterAsSingle());
+#endif
+    }
+
+    void truncateDoubleToUint32(FPRegisterID src, RegisterID dest)
+    {
+        foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+    #if 0
+        m_assembler.vcvt_floatingPointToUnsigned(fpTempRegisterAsSingle(), src);
+        m_assembler.vmov(dest, fpTempRegisterAsSingle());
+#endif
+    }
+    
+    void branchConvertDoubleToInt32(FPRegisterID src, RegisterID dest, JumpList& failureCases, FPRegisterID, bool negZeroCheck = true);
+
+    Jump branchDoubleNonZero(FPRegisterID reg, FPRegisterID fpscratch);
+    Jump branchDoubleZeroOrNaN(FPRegisterID reg, FPRegisterID fpscratch);
+
+    // Stack manipulation operations:
+    //
+    // The ABI is assumed to provide a stack abstraction to memory,
+    // containing machine word sized units of data.  Push and pop
+    // operations add and remove a single register sized unit of data
+    // to or from the stack.  Peek and poke operations read or write
+    // values on the stack, without moving the current stack position.
+
+    void pop(RegisterID dest);
+    void push(RegisterID src);
+    void push(Address address);
+    void push(TrustedImm32 imm);
+
+    // Register move operations:
+    //
+    // Move values in registers.
+
+    void move(TrustedImm32 imm, RegisterID dest);
+    void move(RegisterID src, RegisterID dest);
+    void move(TrustedImmPtr imm, RegisterID dest);
+
+    void swap(RegisterID reg1, RegisterID reg2)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        move(reg1, scratch);
+        move(reg2, reg1);
+        move(scratch, reg2);
+
+        freeScratchRegister(scratch);
+    }
+
+    void signExtend32ToPtr(RegisterID src, RegisterID dest)
+    {
+        move(src, dest);
+    }
+
+    void zeroExtend32ToPtr(RegisterID src, RegisterID dest)
+    {
+        move(src, dest);
+    }
+
+    // Invert a relational condition, e.g. == becomes !=, < becomes >=, etc.
+    static RelationalCondition invert(RelationalCondition cond)
+    {
+        if (cond == Equal)
+            return NotEqual;
+        else if (cond == NotEqual)
+            return Equal;
+        else if (cond == Above)
+            return BelowOrEqual;
+        else if (cond == AboveOrEqual)
+            return Below;
+        else if (cond == Below)
+            return AboveOrEqual;
+        else if (cond == BelowOrEqual)
+            return Above;
+        else if (cond == GreaterThan)
+            return LessThanOrEqual;
+        else if (cond == GreaterThanOrEqual)
+            return LessThan;
+        else if (cond == LessThan)
+            return GreaterThanOrEqual;
+        else if (cond == LessThanOrEqual)
+            return GreaterThan;
+    }
+
+    void nop()
+    {
+        m_assembler.nop();
+    }
+    
+    static void replaceWithJump(CodeLocationLabel instructionStart, CodeLocationLabel destination)
+    {
+        PPCAssembler::replaceWithJump(instructionStart.dataLocation(), destination.dataLocation());
+    }
+    
+    static ptrdiff_t maxJumpReplacementSize()
+    {
+        return PPCAssembler::maxJumpReplacementSize();
+    }
+
+    // Forwards / external control flow operations:
+    //
+    // This set of jump and conditional branch operations return a Jump
+    // object which may linked at a later point, allow forwards jump,
+    // or jumps that will require external linkage (after the code has been
+    // relocated).
+    //
+    // For branches, signed <, >, <= and >= are denoted as l, g, le, and ge
+    // respecitvely, for unsigned comparisons the names b, a, be, and ae are
+    // used (representing the names 'below' and 'above').
+    //
+    // Operands to the comparision are provided in the expected order, e.g.
+    // jle32(reg1, TrustedImm32(5)) will branch if the value held in reg1, when
+    // treated as a signed 32bit value, is less than or equal to 5.
+    //
+    // jz and jnz test whether the first operand is equal to zero, and take
+    // an optional second operand of a mask under which to perform the test.
+private:
+    Jump handleResultCondition(ResultCondition cond)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+	if (cond == Overflow)
+	{
+		m_assembler.mfxer(scratch);
+		m_assembler.rlwinm_dot(scratch, scratch, 2, 31, 31);
+	}
+
+        moveFixedWidthEncoding(TrustedImm32(0), scratch);
+        Jump myjump(m_assembler.label());
+        m_assembler.mtctr(scratch);
+        if (cond == Overflow)
+        {
+            m_assembler.bnectr();
+        }
+        else if (cond == Signed)
+        {
+            m_assembler.bltctr();
+        }
+        else if (cond == PositiveOrZero)
+        {
+            m_assembler.bgectr();
+        }
+        else if (cond == Zero)
+        {
+            m_assembler.beqctr();
+        }
+        else if (cond == NonZero)
+        {
+            m_assembler.bnectr();
+        }
+        else
+        {
+            foddprintf("%s:%d/%s(): lolwut\n", __FILE__, __LINE__, __func__);
+        }
+
+        freeScratchRegister(scratch);
+
+        return myjump;
+    }
+
+public:
+    Jump branch32(RelationalCondition cond, RegisterID left, RegisterID right)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        if (cond == Above
+         || cond == AboveOrEqual
+         || cond == Below
+         || cond == BelowOrEqual)
+        {
+            m_assembler.cmplw(0, left, right);
+        }
+        else
+        {
+            m_assembler.cmpw(0, left, right);
+        }
+        moveFixedWidthEncoding(TrustedImm32(0), scratch);
+        Jump myjump(m_assembler.label());
+        m_assembler.mtctr(scratch);
+        if (cond == Equal)
+        {
+            m_assembler.beqctr();
+        }
+        else if (cond == NotEqual)
+        {
+            m_assembler.bnectr();
+        }
+        else if (cond == Above || cond == GreaterThan)
+        {
+            m_assembler.bgtctr();
+        }
+        else if (cond == AboveOrEqual || cond == GreaterThanOrEqual)
+        {
+            m_assembler.bgectr();
+        }
+        else if (cond == Below || cond == LessThan)
+        {
+            m_assembler.bltctr();
+        }
+        else if (cond == BelowOrEqual || cond == LessThanOrEqual)
+        {
+            m_assembler.blectr();
+        }
+        else
+        {
+            foddprintf("%s:%d/%s(): lolwut\n", __FILE__, __LINE__, __func__);
+        }
+
+        freeScratchRegister(scratch);
+
+        return myjump;
+    }
+
+    Jump branch32(RelationalCondition cond, RegisterID left, TrustedImm32 right)
+    {
+        RegisterID scratch;
+	uint32_t value;
+        Jump myjump;
+	int signed_;
+
+	value = right.m_value;
+
+        if (cond == Above
+         || cond == AboveOrEqual
+         || cond == Below
+         || cond == BelowOrEqual)
+        {
+	    signed_ = 0;
+        }
+        else
+        {
+	    signed_ = 1;
+        }
+
+	if ((signed_ && (value >= 0xffff8000 || value <= 0x00007fff))
+	 || (!signed_ && value <= 0x0000ffff))
+	{
+            scratch = getScratchRegister();
+    
+            if (cond == Above
+             || cond == AboveOrEqual
+             || cond == Below
+             || cond == BelowOrEqual)
+            {
+                m_assembler.cmplwi(0, left, value&0xffff);
+            }
+            else
+            {
+                m_assembler.cmpwi(0, left, value&0xffff);
+            }
+            moveFixedWidthEncoding(TrustedImm32(0), scratch);
+            myjump = Jump(m_assembler.label());
+            m_assembler.mtctr(scratch);
+            if (cond == Equal)
+            {
+                m_assembler.beqctr();
+            }
+            else if (cond == NotEqual)
+            {
+                m_assembler.bnectr();
+            }
+            else if (cond == Above || cond == GreaterThan)
+            {
+                m_assembler.bgtctr();
+            }
+            else if (cond == AboveOrEqual || cond == GreaterThanOrEqual)
+            {
+                m_assembler.bgectr();
+            }
+            else if (cond == Below || cond == LessThan)
+            {
+                m_assembler.bltctr();
+            }
+            else if (cond == BelowOrEqual || cond == LessThanOrEqual)
+            {
+                m_assembler.blectr();
+            }
+            else
+            {
+                foddprintf("%s:%d/%s(): lolwut\n", __FILE__, __LINE__, __func__);
+            }
+    
+            freeScratchRegister(scratch);
+	}
+	else
+	{
+            scratch = getScratchRegister();
+
+            move(right, scratch);
+            myjump = branch32(cond, left, scratch);
+
+            freeScratchRegister(scratch);
+        }
+
+        return myjump;
+    }
+
+    Jump branch32(RelationalCondition cond, RegisterID left, Address right)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        load32(right, scratch);
+        jump = branch32(cond, left, scratch);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branch32(RelationalCondition cond, Address left, RegisterID right)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        load32(left, scratch);
+        jump = branch32(cond, scratch, right);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branch32(RelationalCondition cond, Address left, TrustedImm32 right)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        load32(left, scratch);
+        jump = branch32(cond, scratch, right);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branch32(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        load32(left, scratch);
+        jump = branch32(cond, scratch, right);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branch32WithUnalignedHalfWords(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        load32WithUnalignedHalfWords(left, scratch);
+        jump = branch32(cond, scratch, right);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branch32(RelationalCondition cond, AbsoluteAddress left, RegisterID right)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        load32(left.m_ptr, scratch);
+        jump = branch32(cond, scratch, right);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branch32(RelationalCondition cond, AbsoluteAddress left, TrustedImm32 right)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        load32(left.m_ptr, scratch);
+        jump = branch32(cond, scratch, right);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branch8(RelationalCondition cond, RegisterID left, TrustedImm32 right)
+    {
+        return branch32(cond, left, right);
+    }
+
+    Jump branch8(RelationalCondition cond, Address left, TrustedImm32 right)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        ASSERT(!(0xffffff00 & right.m_value));
+
+        load8(left, scratch);
+        jump = branch8(cond, scratch, right);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branch8(RelationalCondition cond, AbsoluteAddress left, TrustedImm32 right)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        ASSERT(!(0xffffff00 & right.m_value));
+
+        load8(left, scratch);
+        jump = branch8(cond, scratch, right);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branch8(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        ASSERT(!(0xffffff00 & right.m_value));
+
+        load8(left, scratch);
+        jump = branch32(cond, scratch, right);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+    
+    Jump branchTest32(ResultCondition cond, RegisterID reg, RegisterID mask)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        m_assembler.and_dot(scratch, reg, mask);
+        jump = handleResultCondition(cond);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branchTest32(ResultCondition cond, RegisterID reg, TrustedImm32 mask = TrustedImm32(-1))
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        move(mask, scratch);
+        jump = branchTest32(cond, reg, scratch);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branchTest32(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1))
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        load32(address, scratch);
+        jump = branchTest32(cond, scratch, mask);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branchTest32(ResultCondition cond, BaseIndex address, TrustedImm32 mask = TrustedImm32(-1))
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        load32(address, scratch);
+        jump = branchTest32(cond, scratch, mask);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branchTest8(ResultCondition cond, AbsoluteAddress address, TrustedImm32 mask = TrustedImm32(-1));
+    Jump branchTest8(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1));
+    Jump branchTest8(ResultCondition cond, BaseIndex address, TrustedImm32 mask = TrustedImm32(-1));
+
+    void jump(RegisterID target)
+    {
+        m_assembler.mtctr(target);
+        m_assembler.bctr();
+    }
+
+    // Address is a memory location containing the address to jump to
+    void jump(Address address)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        load32(address, scratch);
+        jump(scratch);
+
+        freeScratchRegister(scratch);
+    }
+    
+    void jump(AbsoluteAddress address)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        move(TrustedImmPtr(address.m_ptr), scratch);
+        load32(Address(scratch), scratch);
+        jump(scratch);
+
+        freeScratchRegister(scratch);
+    }
+
+
+    // Arithmetic control flow operations:
+    //
+    // This set of conditional branch operations branch based
+    // on the result of an arithmetic operation.  The operation
+    // is performed as normal, storing the result.
+    //
+    // * jz operations branch if the result is zero.
+    // * jo operations branch if the (signed) arithmetic
+    //   operation caused an overflow to occur.
+    
+    Jump branchAdd32(ResultCondition cond, RegisterID op1, RegisterID op2, RegisterID dest);
+    Jump branchAdd32(ResultCondition cond, RegisterID op1, TrustedImm32 imm, RegisterID dest);
+    Jump branchAdd32(ResultCondition cond, RegisterID src, RegisterID dest);
+    Jump branchAdd32(ResultCondition cond, TrustedImm32 imm, RegisterID dest);
+    Jump branchAdd32(ResultCondition cond, TrustedImm32 imm, AbsoluteAddress dest);
+
+    Jump branchMul32(ResultCondition cond, RegisterID src1, RegisterID src2, RegisterID dest)
+    {
+        m_assembler.mullwo_dot(dest, src1, src2);
+        return handleResultCondition(cond);
+    }
+
+    Jump branchMul32(ResultCondition cond, RegisterID src, RegisterID dest)
+    {
+        return branchMul32(cond, src, dest, dest);
+    }
+
+    Jump branchMul32(ResultCondition cond, TrustedImm32 imm, RegisterID src, RegisterID dest)
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        move(imm, scratch);
+        jump = branchMul32(cond, scratch, src, dest);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    Jump branchNeg32(ResultCondition cond, RegisterID srcDest)
+    {
+        m_assembler.neg_dot(srcDest, srcDest);
+        return handleResultCondition(cond);
+    }
+
+    Jump branchOr32(ResultCondition cond, RegisterID src, RegisterID dest)
+    {
+        m_assembler.or_dot(dest, dest, src);
+        return handleResultCondition(cond);
+    }
+
+    Jump branchSub32(ResultCondition cond, RegisterID op1, RegisterID op2, RegisterID dest);
+    Jump branchSub32(ResultCondition cond, RegisterID op1, TrustedImm32 imm, RegisterID dest);
+    Jump branchSub32(ResultCondition cond, RegisterID src, RegisterID dest);
+    Jump branchSub32(ResultCondition cond, TrustedImm32 imm, RegisterID dest);
+
+    // Miscellaneous operations:
+
+    void breakpoint(uint8_t imm = 0);
+
+    ALWAYS_INLINE Call nearCall()
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+	m_assembler.nop();
+
+        moveFixedWidthEncoding(TrustedImm32(0), scratch);
+        m_assembler.mtctr(scratch);
+        m_assembler.bctrl();
+        Call call(m_assembler.label(), Call::LinkableNear);
+
+        freeScratchRegister(scratch);
+
+        return call;
+    }
+
+    ALWAYS_INLINE Call call()
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+	m_assembler.nop();
+
+        moveFixedWidthEncoding(TrustedImm32(0), scratch);
+        m_assembler.mtctr(scratch);
+        m_assembler.bctrl();
+        Call call(m_assembler.label(), Call::Linkable);
+
+        freeScratchRegister(scratch);
+
+        return call;
+    }
+
+    ALWAYS_INLINE Call call(RegisterID target)
+    {
+    	if (getgencount() == 50)
+		dprint("JIT@% 3d: Calling %08x\n", getgencount(), target);
+        Call call(m_assembler.label(), Call::Linkable);
+        m_assembler.mtctr(target);
+        m_assembler.bctrl();
+        return call;
+    }
+
+    ALWAYS_INLINE Call call(Address address)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        load32(address, scratch);
+
+	dprint("JIT@% 3d: Calling address %08x\n", getgencount(), scratch);
+
+        m_assembler.mtctr(scratch);
+        m_assembler.bctrl();
+        Call call(m_assembler.label(), Call::Linkable);
+
+        freeScratchRegister(scratch);
+
+        return call;
+    }
+
+    ALWAYS_INLINE void ret()
+    {
+	m_assembler.mflr(PPCRegisters::r0);
+    	dprint("JIT@% 3d: Returning to %08x, r3 = %08x, r4 = %08x\n", getgencount(), PPCRegisters::r0, PPCRegisters::r3, PPCRegisters::r4);
+	m_assembler.mflr(PPCRegisters::r0);
+
+        m_assembler.blr();
+    }
+
+    void compare32(RelationalCondition cond, RegisterID left, RegisterID right, RegisterID dest)
+    {
+#if 0
+        foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+#else
+        RegisterID scratch1;
+        RegisterID scratch2;
+
+        scratch1 = getScratchRegister();
+        scratch2 = getScratchRegister();
+
+	dprint("JIT@% 3d: compare32 left %08x right %08x\n", getgencount(), left, right);
+
+	if (cond == Equal)
+	{
+		m_assembler.xor_(dest, left, right);
+		m_assembler.cntlzw(dest, dest);
+		m_assembler.rlwinm(dest, dest, 27, 5, 31);
+	}
+	else if (cond == NotEqual)
+	{
+		m_assembler.xor_(scratch1, left, right);
+		m_assembler.addic(scratch2, scratch1, (-1)&0xffff);
+		m_assembler.subfe(dest, scratch2, scratch1);
+	}
+	else if (cond == Above)
+	{
+		m_assembler.subfc(dest, left, right);
+		m_assembler.subfe(dest, dest, dest);
+		m_assembler.neg(dest, dest);
+	}
+	else if (cond == AboveOrEqual)
+	{
+		m_assembler.subfc(dest, right, left);
+		m_assembler.li(dest, 0);
+		m_assembler.adde(dest, dest, dest);
+	}
+	else if (cond == Below)
+	{
+		m_assembler.subfc(dest, right, left);
+		m_assembler.subfe(dest, dest, dest);
+		m_assembler.neg(dest, dest);
+	}
+	else if (cond == BelowOrEqual)
+	{
+		m_assembler.subfc(dest, left, right);
+		m_assembler.li(dest, 0);
+		m_assembler.adde(dest, dest, dest);
+	}
+	else if (cond == GreaterThan)
+	{
+		m_assembler.cmpw(7, left, right);
+		m_assembler.mfcr(scratch1);
+		m_assembler.rlwinm(dest, scratch1, 30, 31, 31);
+	}
+	else if (cond == GreaterThanOrEqual)
+	{
+		m_assembler.cmpw(7, right, left);
+		m_assembler.mfcr(scratch1);
+		m_assembler.rlwinm(dest, scratch1, 29, 31, 31);
+	}
+	else if (cond == LessThan)
+	{
+		m_assembler.cmpw(7, left, right);
+		m_assembler.mfcr(scratch1);
+		m_assembler.rlwinm(dest, scratch1, 29, 31, 31);
+	}
+	else if (cond == LessThanOrEqual)
+	{
+		m_assembler.cmpw(7, right, left);
+		m_assembler.mfcr(scratch1);
+		m_assembler.rlwinm(dest, scratch1, 30, 31, 31);
+	}
+
+        freeScratchRegister(scratch1);
+        freeScratchRegister(scratch2);
+
+	dprint("JIT@% 3d: compare32 result: %d\n", getgencount(), dest);
+#endif
+    }
+
+    void compare32(RelationalCondition cond, Address left, RegisterID right, RegisterID dest)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        load32(left, scratch);
+        compare32(cond, scratch, right, dest);
+
+        freeScratchRegister(scratch);
+    }
+
+    void compare8(RelationalCondition cond, Address left, TrustedImm32 right, RegisterID dest)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        load8(left, scratch);
+        compare32(cond, scratch, right, dest);
+
+        freeScratchRegister(scratch);
+    }
+
+    void compare32(RelationalCondition cond, RegisterID left, TrustedImm32 right, RegisterID dest)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        load32BitImmediate(scratch, right.m_value);
+
+        compare32(cond, left, scratch, dest);
+
+        freeScratchRegister(scratch);
+    }
+
+    // FIXME:
+    // The mask should be optional... paerhaps the argument order should be
+    // dest-src, operations always have a dest? ... possibly not true, considering
+    // asm ops like test, or pseudo ops like pop().
+    void test32(ResultCondition cond, Address address, TrustedImm32 mask, RegisterID dest)
+    {
+        foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+        #if 0
+        load32(address, dataTempRegister);
+        test32(dataTempRegister, mask);
+        m_assembler.it(armV7Condition(cond), false);
+        m_assembler.mov(dest, PPCThumbImmediate::makeUInt16(1));
+        m_assembler.mov(dest, PPCThumbImmediate::makeUInt16(0));
+        #endif
+    }
+
+    void test8(ResultCondition cond, Address address, TrustedImm32 mask, RegisterID dest)
+    {
+        foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+        #if 0
+        load8(address, dataTempRegister);
+        test32(dataTempRegister, mask);
+        m_assembler.it(armV7Condition(cond), false);
+        m_assembler.mov(dest, PPCThumbImmediate::makeUInt16(1));
+        m_assembler.mov(dest, PPCThumbImmediate::makeUInt16(0));
+        #endif
+    }
+
+    ALWAYS_INLINE DataLabel32 moveWithPatch(TrustedImm32 imm, RegisterID dst)
+    {
+        padBeforePatch();
+        moveFixedWidthEncoding(imm, dst);
+        return DataLabel32(this);
+    }
+
+    ALWAYS_INLINE DataLabelPtr moveWithPatch(TrustedImmPtr imm, RegisterID dst)
+    {
+        padBeforePatch();
+        moveFixedWidthEncoding(TrustedImm32(imm), dst);
+        return DataLabelPtr(this);
+    }
+
+    ALWAYS_INLINE Jump branchPtrWithPatch(RelationalCondition cond, RegisterID left, DataLabelPtr& dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(0))
+    {
+        RegisterID scratch;
+        Jump jump;
+
+        scratch = getScratchRegister();
+
+        dataLabel = moveWithPatch(initialRightValue, scratch);
+        jump = branch32(cond, left, scratch);
+
+        freeScratchRegister(scratch);
+
+        return jump;
+    }
+
+    ALWAYS_INLINE Jump branchPtrWithPatch(RelationalCondition cond, Address left, DataLabelPtr& dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(0))
+    {
+        RegisterID scratch1;
+        RegisterID scratch2;
+        Jump jump;
+
+        scratch1 = getScratchRegister();
+        scratch2 = getScratchRegister();
+
+        load32(left, scratch1);
+        dataLabel = moveWithPatch(initialRightValue, scratch2);
+        jump = branch32(cond, scratch1, scratch2);
+
+        freeScratchRegister(scratch1);
+        freeScratchRegister(scratch2);
+
+        return jump;
+    }
+    
+    ALWAYS_INLINE DataLabelPtr storePtrWithPatch(TrustedImmPtr initialValue, ImplicitAddress address)
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        DataLabelPtr label = moveWithPatch(initialValue, scratch);
+        store32(scratch, address);
+
+        freeScratchRegister(scratch);
+
+        return label;
+    }
+    ALWAYS_INLINE DataLabelPtr storePtrWithPatch(ImplicitAddress address) { return storePtrWithPatch(TrustedImmPtr(0), address); }
+
+
+    ALWAYS_INLINE Call tailRecursiveCall()
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        // Like a normal call, but don't link.
+        moveFixedWidthEncoding(TrustedImm32(0), scratch);
+        m_assembler.mtctr(scratch);
+        m_assembler.bctr();
+        Call call(m_assembler.label(), Call::Linkable);
+
+        freeScratchRegister(scratch);
+
+        return call;
+    }
+
+    ALWAYS_INLINE Call makeTailRecursiveCall(Jump oldJump)
+    {
+        oldJump.link(this);
+        return tailRecursiveCall();
+    }
+
+    static FunctionPtr readCallTarget(CodeLocationCall call)
+    {
+        return FunctionPtr(reinterpret_cast<void(*)()>(PPCAssembler::readCallTarget(call.dataLocation())));
+    }
+    
+    static bool canJumpReplacePatchableBranchPtrWithPatch() { return false; }
+    
+    static CodeLocationLabel startOfBranchPtrWithPatchOnRegister(CodeLocationDataLabelPtr label);
+    
+    static void revertJumpReplacementToBranchPtrWithPatch(CodeLocationLabel instructionStart, RegisterID rd, void* initialValue);
+    
+    static CodeLocationLabel startOfPatchableBranchPtrWithPatchOnAddress(CodeLocationDataLabelPtr)
+    {
+        UNREACHABLE_FOR_PLATFORM();
+        return CodeLocationLabel();
+    }
+    
+    static void revertJumpReplacementToPatchableBranchPtrWithPatch(CodeLocationLabel, Address, void*)
+    {
+        UNREACHABLE_FOR_PLATFORM();
+    }
+
+public:
+	void dprintsaveregs();
+	void dprintrestoreregs();
+
+	void dprint(const char *str);
+	void dprint(const char *str, RegisterID argreg);
+	void dprint(const char *str, RegisterID argreg1, RegisterID argreg2);
+	void dprint(const char *str, RegisterID argreg1, RegisterID argreg2, RegisterID argreg3);
+	void dprint(const char *str, unsigned int argconst1, RegisterID argreg2);
+	void dprint(const char *str, unsigned int argconst1, FPRegisterID fpargreg2);
+	void dprint(const char *str, unsigned int argconst1, RegisterID argreg2, RegisterID argreg3);
+	void dprint(const char *str, unsigned int argconst1, RegisterID argreg2, unsigned int argconst3);
+	void dprint(const char *str, unsigned int argconst1, RegisterID argreg2, unsigned int argconst3, unsigned int argconst4);
+	void dprint(const char *str, unsigned int argconst1, FPRegisterID fpargreg2, FPRegisterID fpargreg3);
+	void dprint(const char *str, unsigned int argconst1, RegisterID argreg2, RegisterID argreg3, RegisterID argreg4);
+	void dprint(const char *str, unsigned int argconst1, unsigned int argconst2, RegisterID argreg3);
+	void dprint(const char *str, unsigned int argconst1, unsigned int argconst2, RegisterID argreg3, RegisterID argreg4);
+	void dprint(const char *str, unsigned int argconst1, unsigned int argconst2, RegisterID argreg3, RegisterID argreg4, RegisterID argreg5);
+	void dprint(const char *str, unsigned int argconst1);
+	void dprint(const char *str, unsigned int argconst1, unsigned int argconst2);
+
+protected:
+    ALWAYS_INLINE Jump jump()
+    {
+        RegisterID scratch;
+
+        scratch = getScratchRegister();
+
+        m_assembler.label(); // Force nop-padding if we're in the middle of a watchpoint.
+        moveFixedWidthEncoding(TrustedImm32(0), scratch);
+        Jump myjump(m_assembler.label());
+        m_assembler.mtctr(scratch);
+        m_assembler.bctr();
+
+        freeScratchRegister(scratch);
+
+        return myjump;
+    }
+
+    void moveFixedWidthEncoding(TrustedImm32 imm, RegisterID dst)
+    {
+        uint32_t value = imm.m_value;
+        m_assembler.lis(dst, value>>16);
+        m_assembler.ori(dst, dst, value&0xffff);
+    }
+
+private:
+    uint32_t m_regsFree;
+    uint32_t m_scratchRegs;
+
+    uint32_t m_gencount;
+
+    friend class LinkBuffer;
+    friend class RepatchBuffer;
+
+    static void linkCall(void* code, Call call, FunctionPtr function)
+    {
+        PPCAssembler::linkCall(code, call.m_label, function.value());
+    }
+
+    static void repatchCall(CodeLocationCall call, CodeLocationLabel destination)
+    {
+        PPCAssembler::relinkCall(call.dataLocation(), destination.executableAddress());
+    }
+
+    static void repatchCall(CodeLocationCall call, FunctionPtr destination)
+    {
+        PPCAssembler::relinkCall(call.dataLocation(), destination.executableAddress());
+    }
+
+    #warning remove this
+    int m_doemitdebug;
+};
+
+} // namespace JSC
+
+#endif // ENABLE(ASSEMBLER)
+
+#endif // MacroAssemblerPPC_h
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/assembler/PPCAssembler.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/PPCAssembler.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/assembler/PPCAssembler.cpp	1970-01-01 00:00:00.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/PPCAssembler.cpp	2018-07-16 15:20:47.029680683 +0000
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2010 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+
+#if ENABLE(ASSEMBLER) && CPU(PPC)
+
+#include "PPCAssembler.h"
+
+extern "C"
+{
+	void foddprintf(const char *fmt, ...)
+	{
+#ifndef __MORPHOS__
+		char buf[4096];
+		unsigned int len;
+		va_list va;
+		va_start(va, fmt);
+		strcpy(buf, "foddprintf: ");
+		len = strlen(buf);
+		vsnprintf(buf + len, sizeof(buf) - len, fmt, va);
+		va_end(va);
+		fprintf(stderr, "%s", buf);
+#endif
+	}
+}
+
+struct DumpSpace
+{
+	void *address;
+	unsigned int size;
+	unsigned int gen;
+};
+
+struct DumpSpace DumpSpaces[256];
+unsigned int DumpSpaceCount;
+
+void AddDumpSpace(void *address, unsigned int size, unsigned int gen)
+{
+	unsigned int i;
+
+	if (DumpSpaceCount >= 256)
+		return;
+
+	for(i=0;i<DumpSpaceCount;i++)
+	{
+		if (((((size_t)address) + size) >= ((size_t)DumpSpaces[i].address))
+		 && (((size_t)address) < (((size_t)DumpSpaces[i].address) + DumpSpaces[i].size)))
+		{
+			foddprintf("New range overlaps old range %d, removing old range\n", i);
+			if (i+1 != DumpSpaceCount)
+			{
+				memmove(&DumpSpaces[i], &DumpSpaces[i + 1], sizeof(*DumpSpaces) * (DumpSpaceCount - i - 1));
+			}
+
+			DumpSpaceCount--;
+		}
+	}
+
+	DumpSpaces[DumpSpaceCount].address = address;
+	DumpSpaces[DumpSpaceCount].size = size;
+	DumpSpaces[DumpSpaceCount].gen = gen;
+	DumpSpaceCount++;
+}
+
+int DumpSpaceComparison(const void *a, const void *b)
+{
+	const struct DumpSpace *aa;
+	const struct DumpSpace *bb;
+
+	aa = (const struct DumpSpace *)a;
+	bb = (const struct DumpSpace *)b;
+
+	if (aa->address < bb->address)
+		return -1;
+	else if (aa->address > bb->address)
+		return 1;
+	else
+		return 0;
+}
+
+int dumpskip = 0;
+
+void DumpDumpSpaces()
+{
+	unsigned int i;
+	unsigned int j;
+	unsigned int *code;
+
+#if 1
+	return;
+#endif
+
+	if (dumpskip)
+	{
+		dumpskip--;
+		foddprintf("Skipping dumping of code, %d skips remaining\n", dumpskip);
+		return;
+	}
+
+	if (!DumpSpaceCount)
+		return;
+
+	qsort(DumpSpaces, DumpSpaceCount, sizeof(*DumpSpaces), DumpSpaceComparison);
+
+	foddprintf("Starting at address %08x\n", DumpSpaces[0].address);
+
+	for(i=0;i<DumpSpaceCount;i++)
+	{
+		code = (unsigned int *)DumpSpaces[i].address;
+
+		foddprintf("jsfunc_%d:\n", DumpSpaces[i].gen);
+
+		for(j=0;j<DumpSpaces[i].size/4;j++)
+		{
+			foddprintf("\t.long 0x%08x\n", code[j]);
+		}
+
+		if (i+1 < DumpSpaceCount && ((size_t)DumpSpaces[i+1].address) > ((size_t)DumpSpaces[i].address) + DumpSpaces[i].size)
+		{
+			foddprintf("\n");
+			foddprintf("\t.space %d\n", ((size_t)DumpSpaces[i+1].address) - (((size_t)DumpSpaces[i].address) + DumpSpaces[i].size));
+		}
+
+		foddprintf("\n");
+	}
+}
+
+namespace JSC {
+
+#if 0
+PassRefPtr<ExecutableMemoryHandle> PPCAssembler::executableCopy(VM& vm, void* ownerUID, JITCompilationEffort effort)
+{
+	RefPtr<ExecutableMemoryHandle> ret;
+
+#warning No idea WTF this is supposed to do
+
+	ret = m_formatter.executableCopy(vm, ownerUID, effort);
+
+#if 0
+	foddprintf("%s:%d/%s: gen %d, Original buffer at %08x, new buffer at %08x, size %d\n", __FILE__, __LINE__, __func__, m_gencount, m_formatter.data(), ret->start(), m_formatter.codeSize());
+#endif
+
+#if 0
+	if (m_gencount == 8)
+#endif
+	AddDumpSpace(ret->start(), m_formatter.codeSize(), m_gencount);
+
+	return ret.release();
+}
+#endif
+
+#if OS(LINUX)
+void PPCAssembler::flushstuff(void *ptr, unsigned int length)
+{
+	unsigned int i;
+	unsigned int alignedptr;
+	unsigned int intptr;
+
+#if 0
+        foddprintf("%s:%d/%s(): Supposed to flush from 0x%08x to 0x%08x, length %d\n", __FILE__, __LINE__, __func__, ptr, ptr + length, length);
+#endif
+
+#warning Not necessary.
+	intptr = (unsigned int)ptr;
+#if 1
+	alignedptr = intptr & ~(31);
+	length += intptr - alignedptr;
+	length = (length + 31) & ~(31);
+#else
+	alignedptr = intptr;
+#endif
+
+#if 0
+        foddprintf("%s:%d/%s(): Flushing from 0x%08x to 0x%08x, length %d\n", __FILE__, __LINE__, __func__, alignedptr, alignedptr + length, length);
+#endif
+
+	for(i=0;i<length;i+=32)
+	{
+		asm volatile(
+			"\tdcbf 0,%0\n"
+			"\ticbi 0,%0\n"
+			:
+			: "b" (alignedptr + i));
+	}
+
+	asm volatile("sync\n");
+	asm volatile("isync\n");
+}
+#endif
+
+void PPCAssembler::PatchBranch(void *from, void *to, int absolute)
+{
+	unsigned int *insts;
+	int bo;
+	int bi;
+	int bo2;
+	int bi2;
+	int doublebranch;
+	int link;
+	unsigned int max;
+	unsigned int reg;
+	uint32_t fromint;
+	uint32_t toint;
+
+	doublebranch = 0;
+
+	fromint = (uint32_t)from;
+	toint = (uint32_t)to;
+
+#if 1
+	PATCHDPRINTF("%s:%d/%s(): Linking from %08x to %08x\n", __FILE__, __LINE__, __func__, from, to);
+#endif
+
+	insts = (unsigned int *)from;
+
+#if 0
+	{
+		unsigned int *insts;
+		insts = (unsigned int *)(from - 8);
+       		PATCHDPRINTF("%s:%d/%s(): Before patch: address 0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts, insts[0], insts[1], insts[2], insts[3], insts[4]);
+	}
+#endif
+
+#if 0
+	PATCHDPRINTF("%s:%d/%s(): Instructions 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts[-2], insts[-1], insts[0], insts[1], insts[2], insts[3], insts[4]);
+ 
+	if (insts[-2] == 0x3d000000
+	 && insts[-1] == 0x61080000
+	 && insts[0] == 0x7d0903a6
+	 && insts[1] == 0x4d830420
+	 && insts[2] == 0x4c810420
+	 && insts[3] == 0x3821ffa0
+	 && insts[4] == 0x9061005c)
+	{
+		PATCHDPRINTF("%s:%d/%s(): This is the one\n", __FILE__, __LINE__, __func__);
+	}
+#endif
+
+	if (!islis(insts[-2]) || !isori(insts[-1]))
+	{
+		PATCHDPRINTF("%s:%d/%s(): Can't patch %08x %08x | %08x %08x\n", __FILE__, __LINE__, __func__, insts[-2], insts[-1], insts[0], insts[1]);
+		return;
+	}
+
+	reg = (insts[-2]>>(31-10))&0x1f;
+
+	if (((insts[-1]>>(31-10))&0x1f) != reg
+	 || ((insts[-1]>>(31-15))&0x1f) != reg)
+	{
+		PATCHDPRINTF("%s:%d/%s(): Can't patch %08x %08x | %08x %08x\n", __FILE__, __LINE__, __func__, insts[-2], insts[-1], insts[0], insts[1]);
+		return;
+	}
+
+	max = 2;
+
+	if (ismtctr(insts[0]) && isbcctr(insts[1]))
+	{
+		if (((insts[0]>>(31-10))&0x1f) != reg)
+		{
+			PATCHDPRINTF("%s:%d/%s(): Can't patch %08x %08x | %08x %08x\n", __FILE__, __LINE__, __func__, insts[-2], insts[-1], insts[0], insts[1]);
+			return;
+		}
+
+		link = insts[1]&1;
+		bo = (insts[1]>>(31-10))&0x1f;
+		bi = (insts[1]>>(31-15))&0x1f;
+	}
+	else if (isbc(insts[0]) && isnop(insts[1]))
+	{
+		link = insts[0]&1;
+		bo = (insts[0]>>(31-10))&0x1f;
+		bi = (insts[0]>>(31-15))&0x1f;
+	}
+	else if (isbc(insts[0]) && isb(insts[1]))
+	{
+		link = insts[1]&1;
+		bo = (insts[0]>>(31-10))&0x1f;
+		bi = (insts[0]>>(31-15))&0x1f;
+
+		bo ^= 8;
+	}
+	else
+	{
+		PATCHDPRINTF("%s:%d/%s(): Can't patch %08x %08x | %08x %08x\n", __FILE__, __LINE__, __func__, insts[-2], insts[-1], insts[0], insts[1]);
+		return;
+	}
+
+	/* Now write the new instructions */
+ 
+	if ((bo == 12 || bo == 4) && bi == 3)
+	{
+		PATCHDPRINTF("%s:%d/%s(): Patching SO\n", __FILE__, __LINE__, __func__);
+
+		bo2 = (insts[2]>>(31-10))&0x1f;
+		bi2 = (insts[2]>>(31-15))&0x1f;
+		doublebranch = 1;
+
+		max = 3;
+	}
+
+	if (absolute)
+	{
+		PATCHDPRINTF("%s:%d/%s(): Absolute\n", __FILE__, __LINE__, __func__);
+
+		insts[-2] = (15<<(31-5))|(reg<<(31-10))|(toint>>16);					 /* lis */
+		insts[-1] = (24<<(31-5))|(reg<<(31-10))|(reg<<(31-15))|(toint&0xffff);   /* ori */
+		insts[0] = (31<<(31-5))|(reg<<(31-10))|((9<<5)<<(31-20))|(467<<(31-30));	  /* mtspr */
+		insts[1] = (19<<(31-5))|(bo<<(31-10))|(bi<<(31-15))|(528<<(31-30))|link; /* bcctr */
+
+		if (doublebranch)
+			insts[2] = (19<<(31-5))|(bo2<<(31-10))|(bi2<<(31-15))|(528<<(31-30))|link; /* bcctr */
+	}
+	else
+	{
+		PATCHDPRINTF("%s:%d/%s(): Relative\n", __FILE__, __LINE__, __func__);
+
+		if (bo != 20)
+		{
+			/* Conditional branch */
+
+			PATCHDPRINTF("%s:%d/%s(): Conditional branch\n", __FILE__, __LINE__, __func__);
+
+			if ((int)(toint - fromint) < -32768 || (int)(toint - fromint) > 32767)
+			{
+				PATCHDPRINTF("%s:%d/%s(): Not within 16 bit range\n", __FILE__, __LINE__, __func__);
+
+				ASSERT((bo&0x14) == 0x4);
+
+				insts[0] = (16<<(31-5))|((bo^8)<<(31-10))|(bi<<(31-15))|(doublebranch?12:8);  /* bc */
+				if (doublebranch)
+				{
+					insts[1] = (16<<(31-5))|((bo2^8)<<(31-10))|(bi2<<(31-15))|8;  /* bc */
+					insts[2] = (18<<(31-5))|((toint - (fromint + 8))&0x3fffffc)|link; /* b */
+				}
+				else
+					insts[1] = (18<<(31-5))|((toint - (fromint + 4))&0x3fffffc)|link; /* b */
+			}
+			else
+			{
+				PATCHDPRINTF("%s:%d/%s(): Within 16 bit range\n", __FILE__, __LINE__, __func__);
+
+#if 0
+				/* Old code */
+				insts[0] = (16<<(31-5))|(bo<<(31-10))|(bi<<(31-15))|((toint - fromint)&0xfffc)|link; /* bc */
+				insts[1] = (24<<(31-5));															 /* nop */
+
+				if (doublebranch)
+					insts[2] = (16<<(31-5))|(bo<<(31-10))|(bi<<(31-15))|((toint - (fromint + 8))&0xfffc)|link; /* bc */
+#else
+				/* New code */
+				insts[0] = (16<<(31-5))|(bo<<(31-10))|(bi<<(31-15))|((toint - fromint)&0xfffc)|link; /* bc */
+				insts[1] = (24<<(31-5));															 /* nop */
+
+				if (doublebranch)
+					insts[2] = (16<<(31-5))|(bo2<<(31-10))|(bi2<<(31-15))|((toint - (fromint + 8))&0xfffc)|link; /* bc */
+#endif
+			}
+		}
+		else
+		{
+			/* Unconditional branch */
+
+			PATCHDPRINTF("%s:%d/%s(): Unconditional branch\n", __FILE__, __LINE__, __func__);
+
+			insts[0] = (18<<(31-5))|((toint - fromint)&0x3fffffc)|link; /* b */
+			insts[1] = (24<<(31-5));									/* nop */
+		}
+	}
+
+#if 0
+	{
+		unsigned int *insts;
+		insts = (unsigned int *)(from - 8);
+       		PATCHDPRINTF("%s:%d/%s():  After patch: address 0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts, insts[0], insts[1], insts[2], insts[3], insts[4]);
+	}
+#endif
+
+#if 0
+	PATCHDPRINTF("%s:%d/%s(): New instructions 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts[-2], insts[-1], insts[0], insts[1], insts[2], insts[3], insts[4]);
+#endif
+	
+	cacheFlush(reinterpret_cast<uint8_t*>(insts - 2), (max + 2)*4);
+}
+
+void* PPCAssembler::readCallTarget(void* from)
+{
+	PATCHDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+	return readPointer(reinterpret_cast<uint16_t*>(from) - 4);
+}
+
+int32_t PPCAssembler::readInt32(void* code)
+{
+	uint32_t *ppccode;
+
+	ppccode = (uint32_t *)code;
+
+	if ((((unsigned int)ppccode)&3))
+	{
+		asm volatile ("twi 31,0,0");
+	}
+
+	ASSERT((ppccode[-2] & 0xfc1f0000) == 0x3c000000 && (ppccode[-1] & 0xfc000000) == 0x60000000 && ((ppccode[-1]>>(31-10))&0x1f) == ((ppccode[-1]>>(31-15))&0x1f));
+
+	if (!((ppccode[-2] & 0xfc1f0000) == 0x3c000000 && (ppccode[-1] & 0xfc000000) == 0x60000000 && ((ppccode[-1]>>(31-10))&0x1f) == ((ppccode[-1]>>(31-15))&0x1f)))
+		foddprintf("Failed to read code at address 0x%08x: %08x %08x %08x %08x %08x %08x | %08x %08x %08x %08x\n", ppccode, ppccode[-6], ppccode[-5], ppccode[-4], ppccode[-3], ppccode[-2], ppccode[-1], ppccode[0], ppccode[1], ppccode[2], ppccode[3]);
+
+	return ((ppccode[-2]&0x0000ffff)<<16)|(ppccode[-1]&0x0000ffff);
+}
+
+void PPCAssembler::relinkCall(void* from, void* to)
+{
+	PATCHDPRINTF("%s:%d/%s(): from 0x%08x, to 0x%08x\n", __FILE__, __LINE__, __func__, from, to);
+
+#warning Figure this one out at some point
+
+	{
+		unsigned int *insts;
+		insts = (unsigned int *)(from - 16);
+        	PATCHDPRINTF("%s:%d/%s(): Before patch: address 0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts, insts[0], insts[1], insts[2], insts[3], insts[4], insts[5], insts[6], insts[7], insts[8], insts[9]);
+	}
+
+   	setPointer((void *)(((intptr_t)from) - 8), to, true);
+
+	{
+		unsigned int *insts;
+		insts = (unsigned int *)(from - 16);
+        	PATCHDPRINTF("%s:%d/%s():  After patch: address 0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts, insts[0], insts[1], insts[2], insts[3], insts[4], insts[5], insts[6], insts[7], insts[8], insts[9]);
+	}
+}
+
+void PPCAssembler::repatchPointer(void* where, void* value)
+{
+	PATCHDPRINTF("%s:%d/%s(): where 0x%08x, value 0x%08x\n", __FILE__, __LINE__, __func__, where, value);
+    
+	{
+		unsigned int *insts;
+		insts = (unsigned int *)(where - 8);
+        	PATCHDPRINTF("%s:%d/%s(): Before patch: address 0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts, insts[0], insts[1], insts[2], insts[3], insts[4], insts[5], insts[6], insts[7], insts[8], insts[9]);
+	}
+
+	setPointer(where, value, true);
+
+	{
+		unsigned int *insts;
+		insts = (unsigned int *)(where - 8);
+        	PATCHDPRINTF("%s:%d/%s():  After patch: address 0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts, insts[0], insts[1], insts[2], insts[3], insts[4], insts[5], insts[6], insts[7], insts[8], insts[9]);
+	}
+}
+
+void PPCAssembler::revertJumpReplacementToBranchPtrWithPatch(void* instructionStart, RegisterID rd, int imm)
+{
+        unsigned int *insts;
+	unsigned int imm2;
+
+	imm2 = imm;
+	insts = (unsigned int *)instructionStart;
+
+        foddprintf("%s:%d/%s(): Unimplemented, register %d, imm 0x%08x\n", __FILE__, __LINE__, __func__, (int)rd, imm);
+
+        foddprintf("%s:%d/%s(): Before patch: address 0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts, insts[0], insts[1], insts[2], insts[3], insts[4], insts[5], insts[6], insts[7], insts[8], insts[9]);
+
+        if (!islis(insts[0])
+	 || !isori(insts[1])
+	 || (!iscmp(insts[2]) && !iscmpl(insts[2])))
+	{
+        	foddprintf("%s:%d/%s(): Can't handle this instruction stream: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts[0], insts[1], insts[2], insts[3], insts[4], insts[5], insts[6], insts[7], insts[8], insts[9]);
+		return;
+	}
+
+	insts[0] = (insts[0] & 0xffff0000) | (imm2>>16);
+	insts[1] = (insts[1] & 0xffff0000) | (imm2&0xffff);
+	insts[2] = (insts[2] & 0xffe0ffff) | (rd<<16);
+
+        foddprintf("%s:%d/%s():  After patch: address 0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", __FILE__, __LINE__, __func__, insts, insts[0], insts[1], insts[2], insts[3], insts[4], insts[5], insts[6], insts[7], insts[8], insts[9]);
+
+	cacheFlush(insts, 3*4);
+/*
+	PatchBranch(insts + 5, (void *)imm, true);
+*/
+}
+
+}
+
+#endif
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/assembler/PPCAssembler.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/PPCAssembler.h
--- clean/WebKit.161078/Source/JavaScriptCore/assembler/PPCAssembler.h	1970-01-01 00:00:00.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/assembler/PPCAssembler.h	2018-07-16 11:52:32.927336526 +0000
@@ -0,0 +1,1324 @@
+/*
+ * Copyright (C) 2009, 2010, 2012, 2013 Apple Inc. All rights reserved.
+ * Copyright (C) 2010 University of Szeged
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ */
+
+#ifndef PPCAssembler_h
+#define PPCAssembler_h
+
+#if ENABLE(ASSEMBLER) && CPU(PPC)
+
+#include <limits.h>
+
+#ifdef __MORPHOS__
+#define foddprintf dprintf
+#endif
+
+extern "C" { void foddprintf(const char *, ...); }
+
+extern "C"
+{
+	void patchdprintf(const char *fmt, ...);
+}
+
+#define PATCHDPRINTF(x...) patchdprintf(x)
+
+#if 0
+#define EMITPRINTF(x...) do { if (m_doemitdebug) foddprintf(x); } while (0)
+#else
+#define EMITPRINTF(x...) do { } while (0)
+#endif
+
+#include "AssemblerBuffer.h"
+#include <wtf/Assertions.h>
+#include <wtf/Vector.h>
+#include <stdint.h>
+
+namespace JSC {
+
+namespace PPCRegisters {
+    typedef enum {
+        r0,
+        r1,
+        r2,
+        r3,
+        r4,
+        r5,
+        r6,
+        r7,
+        r8,
+        r9, sb = r9,   // static base
+        r10, sl = r10, // stack limit
+        r11, fp = r11, // frame pointer
+        r12, ip = r12,
+        r13, sp = r13,
+        r14,
+        r15,
+	r16,
+	r17,
+	r18,
+	r19,
+	r20,
+	r21,
+	r22,
+	r23,
+	r24,
+	r25,
+	r26,
+	r27,
+	r28,
+	r29,
+	r30,
+	r31,
+    } RegisterID;
+
+    typedef enum {
+        f0,
+        f1,
+        f2,
+        f3,
+        f4,
+        f5,
+        f6,
+        f7,
+        f8,
+        f9,
+        f10,
+        f11,
+        f12,
+        f13,
+        f14,
+        f15,
+        f16,
+        f17,
+        f18,
+        f19,
+        f20,
+        f21,
+        f22,
+        f23,
+        f24,
+        f25,
+        f26,
+        f27,
+        f28,
+        f29,
+        f30,
+        f31,
+    } FPRegisterID;
+}
+
+class PPCAssembler;
+
+class PPCAssembler {
+public:
+    typedef PPCRegisters::RegisterID RegisterID;
+    typedef PPCRegisters::FPRegisterID FPRegisterID;
+
+    static RegisterID firstRegister() { return PPCRegisters::r0; }
+    static RegisterID lastRegister() { return PPCRegisters::r31; }
+
+    static FPRegisterID firstFPRegister() { return PPCRegisters::f0; }
+    static FPRegisterID lastFPRegister() { return PPCRegisters::f31; }
+
+
+    PPCAssembler()
+        : m_indexOfLastWatchpoint(INT_MIN)
+        , m_indexOfTailOfLastWatchpoint(INT_MIN)
+    {
+    #warning remove this
+    m_doemitdebug = 1;
+    m_gencount = 0;
+    }
+
+private:
+
+    class PPCInstructionFormatter;
+
+public:
+
+    AssemblerBuffer& buffer() { return m_formatter.buffer(); }
+
+    ALWAYS_INLINE void add(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: add     r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 0, 266, 0);
+    }
+
+    ALWAYS_INLINE void add_dot(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: add.    r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 0, 266, 1);
+    }
+
+    ALWAYS_INLINE void adde(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: adde    r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 0, 138, 0);
+    }
+
+    ALWAYS_INLINE void addi(RegisterID rd, RegisterID ra, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: addi    r%d, r%d, 0x%04x\n", rd, ra, imm);
+
+        m_formatter.emit2RegsImmediate(14, rd, ra, imm);
+    }
+
+    ALWAYS_INLINE void addic(RegisterID rd, RegisterID ra, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: addic   r%d, r%d, 0x%04x\n", rd, ra, imm);
+
+        m_formatter.emit2RegsImmediate(12, rd, ra, imm);
+    }
+
+    ALWAYS_INLINE void addis(RegisterID rd, RegisterID ra, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: addis   r%d, r%d, 0x%04x\n", rd, ra, imm);
+
+        m_formatter.emit2RegsImmediate(15, rd, ra, imm);
+    }
+
+    ALWAYS_INLINE void addo(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: addo    r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 1, 266, 0);
+    }
+
+    ALWAYS_INLINE void addo_dot(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: addo.   r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 1, 266, 1);
+    }
+
+    ALWAYS_INLINE void and_(RegisterID ra, RegisterID rs, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: and     r%d, r%d, r%d\n", ra, rs, rb);
+
+    	m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, rb, 28, 0);
+    }
+
+    ALWAYS_INLINE void and_dot(RegisterID ra, RegisterID rs, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: and.    r%d, r%d, r%d\n", ra, rs, rb);
+
+    	m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, rb, 28, 1);
+    }
+
+    ALWAYS_INLINE void andi_dot(RegisterID ra, RegisterID rs, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: andi.   r%d, r%d, 0x%04x\n", ra, rs, imm);
+
+        m_formatter.emit2RegsImmediate(28, rs, ra, imm);
+    }
+
+    ALWAYS_INLINE void bctr(void)
+    {
+        EMITPRINTF("Emitting: bctr\n");
+
+        m_formatter.emit3RegsSecondaryOp1Bit(19, 20, 0, 0, 528, 0);
+    }
+
+    ALWAYS_INLINE void bctrl(void)
+    {
+        EMITPRINTF("Emitting: bctrl\n");
+
+        m_formatter.emit3RegsSecondaryOp1Bit(19, 20, 0, 0, 528, 1);
+    }
+
+    ALWAYS_INLINE void beqctr(void)
+    {
+        EMITPRINTF("Emitting: beqctr\n");
+
+        m_formatter.emit3RegsSecondaryOp1Bit(19, 12, 2, 0, 528, 0);
+    }
+
+    ALWAYS_INLINE void bgectr(void)
+    {
+        EMITPRINTF("Emitting: bgectr\n");
+
+        m_formatter.emit3RegsSecondaryOp1Bit(19, 4, 0, 0, 528, 0);
+    }
+
+    ALWAYS_INLINE void bgtctr(void)
+    {
+        EMITPRINTF("Emitting: bgtctr\n");
+
+        m_formatter.emit3RegsSecondaryOp1Bit(19, 12, 1, 0, 528, 0);
+    }
+
+    ALWAYS_INLINE void blectr(void)
+    {
+        EMITPRINTF("Emitting: blectr\n");
+
+        m_formatter.emit3RegsSecondaryOp1Bit(19, 4, 1, 0, 528, 0);
+    }
+
+    ALWAYS_INLINE void bltctr(void)
+    {
+        EMITPRINTF("Emitting: bltctr\n");
+
+        m_formatter.emit3RegsSecondaryOp1Bit(19, 12, 0, 0, 528, 0);
+    }
+
+    ALWAYS_INLINE void bnectr(void)
+    {
+        EMITPRINTF("Emitting: bnectr\n");
+
+        m_formatter.emit3RegsSecondaryOp1Bit(19, 4, 2, 0, 528, 0);
+    }
+
+    ALWAYS_INLINE void bsoctr(void)
+    {
+        EMITPRINTF("Emitting: bsoctr\n");
+
+        m_formatter.emit3RegsSecondaryOp1Bit(19, 12, 3, 0, 528, 0);
+    }
+
+    ALWAYS_INLINE void blr()
+    {
+        EMITPRINTF("Emitting: blr\n");
+
+        m_formatter.emit3RegsSecondaryOp1Bit(19, 20, 0, 0, 16, 0);
+    }
+
+    ALWAYS_INLINE void cmplw(uint32_t cr, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: cmplw   cr%d, r%d, r%d\n", cr, ra, rb);
+
+    	m_formatter.emit3Bits1Bit1Bit2RegsSecondaryOp1Bit(31, cr, 0, 0, ra, rb, 32, 0);
+    }
+
+    ALWAYS_INLINE void cmplwi(uint32_t cr, RegisterID ra, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: cmplwi  cr%d, r%d, 0x%04x\n", cr, ra, imm);
+
+    	m_formatter.emit3Bits1Bit1Bit1RegImmediate(10, cr, 0, 0, ra, imm);
+    }
+
+    ALWAYS_INLINE void cmpw(uint32_t cr, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: cmpw    cr%d, r%d, r%d\n", cr, ra, rb);
+
+    	m_formatter.emit3Bits1Bit1Bit2RegsSecondaryOp1Bit(31, cr, 0, 0, ra, rb, 0, 0);
+    }
+
+    ALWAYS_INLINE void cmpwi(uint32_t cr, RegisterID ra, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: cmpwi   cr%d, r%d, 0x%04x\n", cr, ra, imm);
+
+    	m_formatter.emit3Bits1Bit1Bit1RegImmediate(11, cr, 0, 0, ra, imm);
+    }
+
+    ALWAYS_INLINE void cntlzw(RegisterID ra, RegisterID rs)
+    {
+        EMITPRINTF("Emitting: cntlzw  r%d, r%d\n", ra, rs);
+
+    	m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, 0, 26, 0);
+    }
+
+    ALWAYS_INLINE void extsb(RegisterID ra, RegisterID rs)
+    {
+        EMITPRINTF("Emitting: extsb   r%d, r%d\n", ra, rs);
+
+    	m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, 0, 954, 0);
+    }
+
+    ALWAYS_INLINE void extsh(RegisterID ra, RegisterID rs)
+    {
+        EMITPRINTF("Emitting: extsh   r%d, r%d\n", ra, rs);
+
+    	m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, 0, 922, 0);
+    }
+
+    ALWAYS_INLINE void fabs(FPRegisterID rd, FPRegisterID rb)
+    {
+        EMITPRINTF("Emitting: fabs    f%d, f%d\n", rd, rb);
+
+        m_formatter.emit3RegsSecondaryOp1Bit(63, rd, 0, rb, 264, 0);
+    }
+
+    ALWAYS_INLINE void fadd(FPRegisterID rd, FPRegisterID ra, FPRegisterID rb)
+    {
+        EMITPRINTF("Emitting: fadd    f%d, f%d, f%d\n", rd, ra, rb);
+
+        m_formatter.emit4RegsSecondaryOp1Bit(63, rd, ra, rb, 0, 21, 0);
+    }
+
+    ALWAYS_INLINE void fcmpu(uint32_t cr, FPRegisterID ra, FPRegisterID rb)
+    {
+        EMITPRINTF("Emitting: fcmpu   cr%d, f%d, f%d\n", cr, ra, rb);
+
+    	m_formatter.emit3Bits1Bit1Bit2RegsSecondaryOp1Bit(63, cr, 0, 0, ra, rb, 0, 0);
+    }
+
+    ALWAYS_INLINE void fctiwz(FPRegisterID rd, FPRegisterID rb)
+    {
+        EMITPRINTF("Emitting: fctiwz  f%d, f%d\n", rd, rb);
+
+        m_formatter.emit3RegsSecondaryOp1Bit(63, rd, 0, rb, 15, 0);
+    }
+
+    ALWAYS_INLINE void fdiv(FPRegisterID rd, FPRegisterID ra, FPRegisterID rb)
+    {
+        EMITPRINTF("Emitting: fdiv    f%d, f%d, f%d\n", rd, ra, rb);
+
+        m_formatter.emit4RegsSecondaryOp1Bit(63, rd, ra, rb, 0, 18, 0);
+    }
+
+    ALWAYS_INLINE void fmr(FPRegisterID rd, FPRegisterID rb)
+    {
+        EMITPRINTF("Emitting: fmr     f%d, f%d\n", rd, rb);
+
+        m_formatter.emit3RegsSecondaryOp1Bit(63, rd, 0, rb, 72, 0);
+    }
+
+    ALWAYS_INLINE void fmul(FPRegisterID rd, FPRegisterID ra, FPRegisterID rc)
+    {
+        EMITPRINTF("Emitting: fmul    f%d, f%d, f%d\n", rd, ra, rc);
+
+        m_formatter.emit4RegsSecondaryOp1Bit(63, rd, ra, 0, rc, 25, 0);
+    }
+
+    ALWAYS_INLINE void fneg(FPRegisterID rd, FPRegisterID rb)
+    {
+        EMITPRINTF("Emitting: fneg    f%d, f%d\n", rd, rb);
+
+        m_formatter.emit3RegsSecondaryOp1Bit(63, rd, 0, rb, 40, 0);
+    }
+
+    ALWAYS_INLINE void frsp(FPRegisterID rd, FPRegisterID rb)
+    {
+        EMITPRINTF("Emitting: frsp    f%d, f%d\n", rd, rb);
+
+        m_formatter.emit3RegsSecondaryOp1Bit(63, rd, 0, rb, 12, 0);
+    }
+
+    ALWAYS_INLINE void fsqrt(FPRegisterID rd, FPRegisterID rb)
+    {
+        EMITPRINTF("Emitting: fsqrt   f%d, f%d\n", rd, rb);
+
+        m_formatter.emit4RegsSecondaryOp1Bit(63, rd, 0, rb, 0, 22, 0);
+    }
+
+    ALWAYS_INLINE void fsub(FPRegisterID rd, FPRegisterID ra, FPRegisterID rb)
+    {
+        EMITPRINTF("Emitting: fsub    f%d, f%d, f%d\n", rd, ra, rb);
+
+        m_formatter.emit4RegsSecondaryOp1Bit(63, rd, ra, rb, 0, 20, 0);
+    }
+
+    ALWAYS_INLINE void lbz(RegisterID rd, uint32_t imm, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: lbz     r%d, 0x%04x(r%d)\n", rd, imm, ra);
+
+        m_formatter.emit2RegsImmediate(34, rd, ra, imm);
+    }
+
+    ALWAYS_INLINE void lfd(FPRegisterID rd, uint32_t imm, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: lfd     f%d, 0x%04x(r%d)\n", rd, imm, ra);
+
+        m_formatter.emit2RegsImmediate(50, rd, ra, imm);
+    }
+
+    ALWAYS_INLINE void lfs(FPRegisterID rd, uint32_t imm, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: lfs     f%d, 0x%04x(r%d)\n", rd, imm, ra);
+
+        m_formatter.emit2RegsImmediate(48, rd, ra, imm);
+    }
+
+    ALWAYS_INLINE void lhz(RegisterID rd, uint32_t imm, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: lhz     r%d, 0x%04x(r%d)\n", rd, imm, ra);
+
+        m_formatter.emit2RegsImmediate(40, rd, ra, imm);
+    }
+
+    ALWAYS_INLINE void lwz(RegisterID rd, uint32_t imm, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: lwz     r%d, 0x%04x(r%d)\n", rd, imm, ra);
+
+        m_formatter.emit2RegsImmediate(32, rd, ra, imm);
+    }
+
+    ALWAYS_INLINE void li(RegisterID rd, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: li      r%d, 0x%04x\n", rd, imm);
+
+        m_formatter.emit2RegsImmediate(14, rd, 0, imm);
+    }
+
+    ALWAYS_INLINE void lis(RegisterID rd, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: lis     r%d, 0x%04x\n", rd, imm);
+
+        m_formatter.emit2RegsImmediate(15, rd, 0, imm);
+    }
+
+    ALWAYS_INLINE void mfcr(RegisterID rd)
+    {
+    	EMITPRINTF("Emitting: mfcr    r%d\n", rd);
+
+        m_formatter.emit3RegsSecondaryOp1Bit(31, rd, 0, 0, 19, 0);
+    }
+
+#warning This function is only used for debugging.
+    ALWAYS_INLINE void mfctr(RegisterID rd)
+    {
+    	EMITPRINTF("Emitting: mfctr   r%d\n", rd);
+
+	m_formatter.emit1RegImmediateSecondaryOp1Bit(31, rd, (9<<5), 339, 0);
+    }
+
+    ALWAYS_INLINE void mflr(RegisterID rd)
+    {
+    	EMITPRINTF("Emitting: mflr    r%d\n", rd);
+
+	m_formatter.emit1RegImmediateSecondaryOp1Bit(31, rd, (8<<5), 339, 0);
+    }
+
+    ALWAYS_INLINE void mfxer(RegisterID rd)
+    {
+    	EMITPRINTF("Emitting: mfxer   r%d\n", rd);
+
+	m_formatter.emit1RegImmediateSecondaryOp1Bit(31, rd, (1<<5), 339, 0);
+    }
+
+    ALWAYS_INLINE void mr(RegisterID ra, RegisterID rs)
+    {
+        EMITPRINTF("Emitting: mr      r%d, r%d\n", ra, rs);
+
+        m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, rs, 444, 0);
+    }
+
+    ALWAYS_INLINE void mtcr(RegisterID rs)
+    {
+    	EMITPRINTF("Emitting: mtcr    r%d\n", rs);
+
+        m_formatter.emit1Reg1BitImmediate1BitSecondaryOp1Bit(31, rs, 0, 0xff, 0, 144, 0);
+    }
+
+    ALWAYS_INLINE void mtctr(RegisterID rs)
+    {
+    	EMITPRINTF("Emitting: mtctr   r%d\n", rs);
+
+	m_formatter.emit1RegImmediateSecondaryOp1Bit(31, rs, (9<<5), 467, 0);
+    }
+
+    ALWAYS_INLINE void mtlr(RegisterID rs)
+    {
+    	EMITPRINTF("Emitting: mtlr    r%d\n", rs);
+
+	m_formatter.emit1RegImmediateSecondaryOp1Bit(31, rs, (8<<5), 467, 0);
+    }
+
+    ALWAYS_INLINE void mullw(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: mullw   r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 0, 235, 0);
+    }
+
+    ALWAYS_INLINE void mullw_dot(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: mullw.  r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 0, 235, 1);
+    }
+
+    ALWAYS_INLINE void mullwo_dot(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: mullwo.  r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 1, 235, 1);
+    }
+
+    ALWAYS_INLINE void neg(RegisterID rd, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: neg     r%d, r%d\n", rd, ra);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, 0, 0, 104, 0);
+    }
+
+    ALWAYS_INLINE void neg_dot(RegisterID rd, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: neg.    r%d, r%d\n", rd, ra);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, 0, 0, 104, 1);
+    }
+
+    ALWAYS_INLINE void nop()
+    {
+        EMITPRINTF("Emitting: nop\n");
+
+        m_formatter.emit2RegsImmediate(24, 0, 0, 0);
+    }
+
+    ALWAYS_INLINE void or_(RegisterID ra, RegisterID rs, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: or      r%d, r%d, r%d\n", ra, rs, rb);
+
+        m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, rb, 444, 0);
+    }
+
+    ALWAYS_INLINE void or_dot(RegisterID ra, RegisterID rs, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: or.     r%d, r%d, r%d\n", ra, rs, rb);
+
+        m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, rb, 444, 1);
+    }
+
+    ALWAYS_INLINE void ori(RegisterID ra, RegisterID rs, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: ori     r%d, r%d, 0x%04x\n", ra, rs, imm);
+
+        m_formatter.emit2RegsImmediate(24, rs, ra, imm);
+    }
+
+    ALWAYS_INLINE void oris(RegisterID ra, RegisterID rs, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: oris    r%d, r%d, 0x%04x\n", ra, rs, imm);
+
+        m_formatter.emit2RegsImmediate(25, rs, ra, imm);
+    }
+
+    ALWAYS_INLINE void slw(RegisterID ra, RegisterID rs, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: slw     r%d, r%d, r%d\n", ra, rs, rb);
+
+    	m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, rb, 24, 0);
+    }
+
+    ALWAYS_INLINE void rlwinm(RegisterID ra, RegisterID rs, uint32_t shift, uint32_t mb, uint32_t me)
+    {
+        EMITPRINTF("Emitting: rlwinm  r%d, r%d, %d, %d, %d\n", ra, rs, shift, mb, me);
+
+    	m_formatter.emit5Regs1Bit(21, rs, ra, shift, mb, me, 0);
+    }
+
+    ALWAYS_INLINE void rlwinm_dot(RegisterID ra, RegisterID rs, uint32_t shift, uint32_t mb, uint32_t me)
+    {
+        EMITPRINTF("Emitting: rlwinm. r%d, r%d, %d, %d, %d\n", ra, rs, shift, mb, me);
+
+    	m_formatter.emit5Regs1Bit(21, rs, ra, shift, mb, me, 1);
+    }
+
+    ALWAYS_INLINE void slwi(RegisterID ra, RegisterID rs, uint32_t shift)
+    {
+        EMITPRINTF("Emitting: slwi    r%d, r%d, %d\n", ra, rs, shift);
+
+    	m_formatter.emit5Regs1Bit(21, rs, ra, shift, 0, 31-shift, 0);
+    }
+
+    ALWAYS_INLINE void sraw(RegisterID ra, RegisterID rs, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: sraw    r%d, r%d, r%d\n", ra, rs, rb);
+
+    	m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, rb, 792, 0);
+    }
+
+    ALWAYS_INLINE void srawi(RegisterID ra, RegisterID rs, uint32_t shift)
+    {
+        EMITPRINTF("Emitting: srawi   r%d, r%d, %d\n", ra, rs, shift);
+
+    	m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, shift, 824, 0);
+    }
+
+    ALWAYS_INLINE void srw(RegisterID ra, RegisterID rs, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: srw     r%d, r%d, r%d\n", ra, rs, rb);
+
+    	m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, rb, 536, 0);
+    }
+
+    ALWAYS_INLINE void srwi(RegisterID ra, RegisterID rs, uint32_t shift)
+    {
+        EMITPRINTF("Emitting: srwi    r%d, r%d, %d\n", ra, rs, shift);
+
+    	m_formatter.emit5Regs1Bit(21, rs, ra, 32-shift, shift, 31, 0);
+    }
+
+    ALWAYS_INLINE void stb(RegisterID rs, uint32_t imm, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: stb     r%d, 0x%04x(r%d)\n", rs, imm, ra);
+
+        m_formatter.emit2RegsImmediate(38, rs, ra, imm);
+    }
+
+    ALWAYS_INLINE void stfd(FPRegisterID rs, uint32_t imm, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: stfd    f%d, 0x%04x(r%d)\n", rs, imm, ra);
+
+        m_formatter.emit2RegsImmediate(54, rs, ra, imm);
+    }
+
+    ALWAYS_INLINE void stfs(FPRegisterID rs, uint32_t imm, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: stfs    f%d, 0x%04x(r%d)\n", rs, imm, ra);
+
+        m_formatter.emit2RegsImmediate(52, rs, ra, imm);
+    }
+
+    ALWAYS_INLINE void sth(RegisterID rs, uint32_t imm, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: sth     r%d, 0x%04x(r%d)\n", rs, imm, ra);
+
+        m_formatter.emit2RegsImmediate(44, rs, ra, imm);
+    }
+
+    ALWAYS_INLINE void stw(RegisterID rs, uint32_t imm, RegisterID ra)
+    {
+        EMITPRINTF("Emitting: stw     r%d, 0x%04x(r%d)\n", rs, imm, ra);
+
+        m_formatter.emit2RegsImmediate(36, rs, ra, imm);
+    }
+
+    ALWAYS_INLINE void subf(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: subf    r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 0, 40, 0);
+    }
+
+    ALWAYS_INLINE void subf_dot(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: subf.   r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 0, 40, 1);
+    }
+
+    ALWAYS_INLINE void subfc(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: subfc   r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 0, 8, 0);
+    }
+
+    ALWAYS_INLINE void subfe(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: subfe   r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 0, 136, 0);
+    }
+
+    ALWAYS_INLINE void subfo_dot(RegisterID rd, RegisterID ra, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: subfo.   r%d, r%d, r%d\n", rd, ra, rb);
+
+        m_formatter.emit3Regs1BitSecondaryOp1Bit(31, rd, ra, rb, 1, 40, 1);
+    }
+
+    ALWAYS_INLINE void xor_(RegisterID ra, RegisterID rs, RegisterID rb)
+    {
+        EMITPRINTF("Emitting: xor     r%d, r%d, r%d\n", ra, rs, rb);
+
+    	m_formatter.emit3RegsSecondaryOp1Bit(31, rs, ra, rb, 316, 0);
+    }
+
+    ALWAYS_INLINE void twi(uint32_t to, RegisterID ra, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: twi    %d, r%d, 0x%04x\n", to, ra, imm);
+
+        m_formatter.emit2RegsImmediate(03, to, ra, imm);
+    }
+
+    ALWAYS_INLINE void xori(RegisterID ra, RegisterID rs, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: xori    r%d, r%d, 0x%04x\n", rs, ra, imm);
+
+        m_formatter.emit2RegsImmediate(26, rs, ra, imm);
+    }
+
+    ALWAYS_INLINE void xoris(RegisterID ra, RegisterID rs, uint32_t imm)
+    {
+        EMITPRINTF("Emitting: xoris   r%d, r%d, 0x%04x\n", ra, rs, imm);
+
+        m_formatter.emit2RegsImmediate(27, rs, ra, imm);
+    }
+
+#warning remove this
+    void opcode(unsigned int opcode)
+    {
+    #if 1
+    	m_formatter.emitOpcode(opcode);
+    #endif
+    }
+
+    AssemblerLabel labelIgnoringWatchpoints()
+    {
+        return m_formatter.label();
+    }
+
+    AssemblerLabel labelForWatchpoint()
+    {
+        AssemblerLabel result = m_formatter.label();
+        if (static_cast<int>(result.m_offset) != m_indexOfLastWatchpoint)
+            result = label();
+        m_indexOfLastWatchpoint = result.m_offset;
+        m_indexOfTailOfLastWatchpoint = result.m_offset + maxJumpReplacementSize();
+        return result;
+    }
+
+    AssemblerLabel label()
+    {
+        AssemblerLabel result = m_formatter.label();
+        while (UNLIKELY(static_cast<int>(result.m_offset) < m_indexOfTailOfLastWatchpoint)) {
+            nop();
+            result = m_formatter.label();
+        }
+        return result;
+    }
+    
+    AssemblerLabel align(int alignment)
+    {
+        while (!m_formatter.isAligned(alignment))
+	    nop();
+
+        return label();
+    }
+    
+    static void* getRelocatedAddress(void* code, AssemblerLabel label)
+    {
+        ASSERT(label.isSet());
+        return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(code) + label.m_offset);
+    }
+    
+    static int getDifferenceBetweenLabels(AssemblerLabel a, AssemblerLabel b)
+    {
+        return b.m_offset - a.m_offset;
+    }
+
+    // Assembler admin methods:
+
+    size_t codeSize() const { return m_formatter.codeSize(); }
+
+    static unsigned getCallReturnOffset(AssemblerLabel call)
+    {
+        ASSERT(call.isSet());
+        return call.m_offset;
+    }
+
+    // Linking & patching:
+    //
+    // 'link' and 'patch' methods are for use on unprotected code - such as the code
+    // within the AssemblerBuffer, and code being patched by the patch buffer.  Once
+    // code has been finalized it is (platform support permitting) within a non-
+    // writable region of memory; to modify the code in an execute-only execuable
+    // pool the 'repatch' and 'relink' methods should be used.
+
+private:
+    static int isb(unsigned int value)
+    {
+    	if ((value&(63<<(31-5))) == (18<<(31-5)))
+	    return 1;
+	else
+	    return 0;
+    }
+
+    static int isbc(unsigned int value)
+    {
+    	if ((value&(63<<(31-5))) == (16<<(31-5)))
+	    return 1;
+	else
+	    return 0;
+    }
+
+    static int isbcctr(unsigned int value)
+    {
+    	if ((value&((63<<(31-5))|(1023<<(31-30)))) == ((19<<(31-5))|(528<<(31-30))))
+	    return 1;
+	else
+	    return 0;
+    }
+
+    static int iscmp(unsigned int value)
+    {
+    	if ((value&((63<<(31-5))|(1<<(31-9))|(1023<<(31-30))|(1<<(31-31)))) == (31<<(31-5)))
+	    return 1;
+	else
+	    return 0;
+    }
+
+    static int iscmpl(unsigned int value)
+    {
+    	if ((value&((63<<(31-5))|(1<<(31-9))|(1023<<(31-30))|(1<<(31-31)))) == ((31<<(31-5))|(32<<(31-30))))
+	    return 1;
+	else
+	    return 0;
+    }
+
+    static int islis(unsigned int value)
+    {
+    	if ((value&((63<<(31-5))|(31<<(31-15)))) == (15<<(31-5)))
+	    return 1;
+	else
+	    return 0;
+    }
+
+    static int ismtctr(unsigned int value)
+    {
+	if ((value&((63<<(31-5))|(1023<<(31-20))|(1023<<(31-30))|(1<<(31-31)))) == ((31<<(31-5))|((9<<5)<<(31-20))|(467<<(31-30))))
+	    return 1;
+	else
+	    return 0;
+    }
+
+    static int isnop(unsigned int value)
+    {
+        return value == 0x60000000;
+    }
+
+    static int isori(unsigned int value)
+    {
+    	if ((value&((63<<(31-5)))) == (24<<(31-5)))
+	    return 1;
+	else
+	    return 0;
+    }
+
+    static void PatchBranch(void *from, void *to, int absolute);
+
+public:
+
+#warning remove this
+	void enabledebug()
+	{
+		m_doemitdebug = 1;
+	}
+
+	void setgencount(int a)
+	{
+		m_gencount = a;
+	}
+
+    void linkJump(AssemblerLabel from, AssemblerLabel to)
+    {
+    	char *code;
+
+        ASSERT(to.isSet());
+        ASSERT(from.isSet());
+
+	code = (char *)m_formatter.data();
+	PatchBranch(code + from.m_offset, code + to.m_offset, 0);
+    }
+
+    static void linkJump(void* code, AssemblerLabel from, void* to)
+    {
+        ASSERT(from.isSet());
+
+	PatchBranch(((char *)code) + from.m_offset, to, 1);
+    }
+
+    static void linkCall(void* code, AssemblerLabel from, void* to)
+    {
+        ASSERT(from.isSet());
+
+        setPointer(reinterpret_cast<uint16_t*>(reinterpret_cast<intptr_t>(code) + from.m_offset - 8), to, false);
+    }
+
+    static void linkPointer(void* code, AssemblerLabel where, void* value)
+    {
+        PATCHDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+        setPointer(reinterpret_cast<char*>(code) + where.m_offset, value, false);
+    }
+
+    static void relinkCall(void* from, void* to);
+
+    static void relinkJump(void* from, void* to)
+    {
+	PatchBranch(from, to, 1);
+
+        /* Already handled by PatchBranch itself */
+#if 0
+        cacheFlush(reinterpret_cast<uint8_t*>(from) - (4*4), 8*4);
+#endif
+    }
+    
+    static void* readCallTarget(void* from);
+
+    static void repatchInt32(void* where, int32_t value)
+    {
+        PATCHDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+        
+        setInt32(where, value, true);
+    }
+    
+    static void repatchCompact(void* where, int32_t offset)
+    {
+    	unsigned int *insts;
+#if 0
+        foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+#else
+        PATCHDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+
+	insts = (unsigned int *)where;
+
+	if ((insts[0]>>(31-5)) == 32)
+	{
+            PATCHDPRINTF("%s:%d/%s(): Patching load offset from %04x to %08x\n", __FILE__, __LINE__, __func__, insts[0]&0xffff, offset);
+
+	    insts[0] &= 0xffff0000;
+	    insts[0] |= (offset&0xffff);
+	}
+	else
+	{
+	    foddprintf("%s:%d/%s(): Instruction at %08x (%08x) is unknown\n", __FILE__, __LINE__, __func__, insts, insts[0]);
+
+	    RELEASE_ASSERT_NOT_REACHED();
+	}
+
+	cacheFlush(insts, 4);
+#endif
+    }
+
+    static void repatchPointer(void* where, void* value);
+
+    static void* readPointer(void* where)
+    {
+        PATCHDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+        return reinterpret_cast<void*>(readInt32(where));
+    }
+
+    static void revertJumpReplacementToBranchPtrWithPatch(void* instructionStart, RegisterID rd, int imm);
+
+    static void replaceWithJump(void* instructionStart, void* to)
+    {
+        foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+    }
+    
+    static ptrdiff_t maxJumpReplacementSize()
+    {
+        foddprintf("%s:%d/%s(): Unimplemented\n", __FILE__, __LINE__, __func__);
+#if OS(LINUX) || OS(QNX)
+        return 10;
+#else
+        return 4;
+#endif
+    }
+    
+    static void replaceWithLoad(void* instructionStart)
+    {
+        unsigned int *insts;
+
+	insts = (unsigned int *)instructionStart;
+
+	if ((insts[0]>>(31-5)) == 32)
+	{
+	    foddprintf("%s:%d/%s(): Instruction at %08x is already lwz\n", __FILE__, __LINE__, __func__, insts);
+	}
+	else if ((insts[0]>>31-5) == 14)
+	{
+	    foddprintf("%s:%d/%s(): Instruction at %08x changed to addi\n", __FILE__, __LINE__, __func__, insts);
+	    insts[0] = (insts[0] & ~(63<<(31-5))) | (32<<(31-5));
+	}
+	else
+	{
+	    foddprintf("%s:%d/%s(): Instruction at %08x (%08x) is unknown\n", __FILE__, __LINE__, __func__, insts, insts[0]);
+            RELEASE_ASSERT_NOT_REACHED();
+	}
+
+	cacheFlush(insts, 4);
+    }
+
+    static void replaceWithAddressComputation(void* instructionStart)
+    {
+        unsigned int *insts;
+
+	insts = (unsigned int *)instructionStart;
+
+	if ((insts[0]>>(31-5)) == 32)
+	{
+	    PATCHDPRINTF("%s:%d/%s(): Instruction at %08x changed to lwz\n", __FILE__, __LINE__, __func__, insts);
+	    insts[0] = (insts[0] & ~(63<<(31-5))) | (14<<(31-5));
+	}
+	else if ((insts[0]>>31-5) == 14)
+	{
+	    PATCHDPRINTF("%s:%d/%s(): Instruction at %08x is already addi\n", __FILE__, __LINE__, __func__, insts);
+	}
+	else
+	{
+	    foddprintf("%s:%d/%s(): Instruction at %08x (%08x) is unknown\n", __FILE__, __LINE__, __func__, insts, insts[0]);
+            RELEASE_ASSERT_NOT_REACHED();
+	}
+
+	cacheFlush(insts, 4);
+    }
+
+#if 0
+    PassRefPtr<ExecutableMemoryHandle> executableCopy(VM&, void* ownerUID, JITCompilationEffort);
+#endif
+
+    unsigned debugOffset() { return m_formatter.debugOffset(); }
+
+#if OS(LINUX)
+#if 0
+    static inline void linuxPageFlush(uintptr_t begin, uintptr_t end)
+    {
+        asm volatile(
+            "push    {r7}\n"
+            "mov     r0, %0\n"
+            "mov     r1, %1\n"
+            "movw    r7, #0x2\n"
+            "movt    r7, #0xf\n"
+            "movs    r2, #0x0\n"
+            "svc     0x0\n"
+            "pop     {r7}\n"
+            :
+            : "r" (begin), "r" (end)
+            : "r0", "r1", "r2");
+    }
+#endif
+
+    static void flushstuff(void *ptr, unsigned int length);
+#endif
+
+    static void cacheFlush(void* code, size_t size)
+    {
+#if OS(IOS)
+        sys_cache_control(kCacheFunctionPrepareForExecution, code, size);
+#elif OS(LINUX)
+#if 0
+        size_t page = pageSize();
+        uintptr_t current = reinterpret_cast<uintptr_t>(code);
+        uintptr_t end = current + size;
+        uintptr_t firstPageEnd = (current & ~(page - 1)) + page;
+
+        if (end <= firstPageEnd) {
+            linuxPageFlush(current, end);
+            return;
+        }
+
+        linuxPageFlush(current, firstPageEnd);
+
+        for (current = firstPageEnd; current + page < end; current += page)
+            linuxPageFlush(current, current + page);
+
+        linuxPageFlush(current, end);
+#else
+	flushstuff(code, size);
+#endif
+#elif OS(WINCE)
+        CacheRangeFlush(code, size, CACHE_SYNC_ALL);
+#elif OS(QNX)
+#if !ENABLE(ASSEMBLER_WX_EXCLUSIVE)
+        msync(code, size, MS_INVALIDATE_ICACHE);
+#else
+        UNUSED_PARAM(code);
+        UNUSED_PARAM(size);
+#endif
+#elif OS(MORPHOS)
+	CacheFlushDataInstArea(code, size);
+#else
+#error "The cacheFlush support is missing on this platform."
+#endif
+    }
+
+private:
+
+    static void setInt32(void* code, uint32_t value, bool flush)
+    {
+        uint32_t *ppccode;
+
+	ppccode = (uint32_t *)code;
+
+	ASSERT((ppccode[-2] & 0xfc1f0000) == 0x3c000000 && (ppccode[-1] & 0xfc000000) == 0x60000000 && ((ppccode[-1]>>(31-10))&0x1f) == ((ppccode[-1]>>(31-15))&0x1f));
+
+	if (!((ppccode[-2] & 0xfc1f0000) == 0x3c000000 && (ppccode[-1] & 0xfc000000) == 0x60000000 && ((ppccode[-1]>>(31-10))&0x1f) == ((ppccode[-1]>>(31-15))&0x1f)))
+		foddprintf("Failed to patch code %08x %08x %08x %08x %08x %08x | %08x %08x\n", ppccode[-6], ppccode[-5], ppccode[-4], ppccode[-3], ppccode[-2], ppccode[-1], ppccode[0], ppccode[1]);
+
+	ppccode[-2] = (ppccode[-2]&0xffff0000)|(value>>16);
+	ppccode[-1] = (ppccode[-1]&0xffff0000)|(value&0xffff);
+
+        if (flush)
+            cacheFlush(ppccode - 2, 2 * sizeof(uint32_t));
+    }
+    
+    static int32_t readInt32(void* code);
+
+    static void setPointer(void* code, void* value, bool flush)
+    {
+        setInt32(code, reinterpret_cast<uint32_t>(value), flush);
+    }
+
+    class PPCInstructionFormatter {
+    public:
+
+    #warning remove this
+        ALWAYS_INLINE void emitOpcode(uint32_t opcode)
+	{
+		m_buffer.putInt(opcode);
+	}
+
+        ALWAYS_INLINE void emit1RegImmediateSecondaryOp1Bit(uint32_t primary, uint32_t reg, uint32_t immediate, uint32_t secondary, uint32_t bit)
+	{
+		ASSERT((primary&0xFFFFFFC0) == 0);
+		ASSERT((reg&0xFFFFFFE0) == 0);
+		ASSERT((immediate&0xFFFFFC00) == 0);
+		ASSERT((secondary&0xFFFFFFC00) == 0);
+		ASSERT((bit&0xFFFFFFFE) == 0);
+
+		m_buffer.putInt((primary<<(31-5))|(reg<<(31-10))|(immediate<<(31-20))|(secondary<<(31-30))|(bit<<(31-31)));
+	}
+
+        ALWAYS_INLINE void emit1Reg1BitImmediate1BitSecondaryOp1Bit(uint32_t primary, uint32_t reg, uint32_t bit0, uint32_t immediate, uint32_t bit1, uint32_t secondary, uint32_t bit2)
+	{
+		ASSERT((primary&0xFFFFFFC0) == 0);
+		ASSERT((reg&0xFFFFFFE0) == 0);
+		ASSERT((bit0&0xFFFFFFFE) == 0);
+		ASSERT((immediate&0xFFFFFF00) == 0);
+		ASSERT((bit1&0xFFFFFFFE) == 0);
+		ASSERT((secondary&0xFFFFFFC00) == 0);
+		ASSERT((bit2&0xFFFFFFFE) == 0);
+
+		m_buffer.putInt((primary<<(31-5))|(reg<<(31-10))|(bit0<<(31-11))|(immediate<<(31-19))|(bit1<<(31-20))|(secondary<<(31-30))|(bit2<<(31-31)));
+	}
+
+        ALWAYS_INLINE void emit2RegsImmediate(uint32_t primary, uint32_t reg0, uint32_t reg1, uint32_t immediate)
+	{
+		ASSERT((primary&0xFFFFFFC0) == 0);
+		ASSERT((reg0&0xFFFFFFE0) == 0);
+		ASSERT((reg1&0xFFFFFFE0) == 0);
+		ASSERT((immediate&0xFFFF0000) == 0);
+
+		m_buffer.putInt((primary<<(31-5))|(reg0<<(31-10))|(reg1<<(31-15))|(immediate<<(31-31)));
+	}
+
+	ALWAYS_INLINE void emit3Bits1Bit1Bit2RegsSecondaryOp1Bit(uint32_t primary, uint32_t bits0, uint32_t bit1, uint32_t bit2, uint32_t reg0, uint32_t reg1, uint32_t secondary, uint32_t bit3)
+	{
+		ASSERT((primary&0xFFFFFFC0) == 0);
+		ASSERT((bits0&0xFFFFFFF8) == 0);
+		ASSERT((bit1&0xFFFFFFFE) == 0);
+		ASSERT((bit2&0xFFFFFFFE) == 0);
+		ASSERT((reg0&0xFFFFFFE0) == 0);
+		ASSERT((reg1&0xFFFFFFE0) == 0);
+		ASSERT((secondary&0xFFFFFFE00) == 0);
+		ASSERT((bit3&0xFFFFFFFE) == 0);
+
+		m_buffer.putInt((primary<<(31-5))|(bits0<<(31-8))|(bit1<<(31-9))|(bit2<<(31-10))|(reg0<<(31-15))|(reg1<<(31-20))|(secondary<<(31-30))|(bit3<<(31-31)));
+	}
+
+	ALWAYS_INLINE void emit3Bits1Bit1Bit1RegImmediate(uint32_t primary, uint32_t bits0, uint32_t bit1, uint32_t bit2, uint32_t reg, uint32_t immediate)
+	{
+		ASSERT((primary&0xFFFFFFC0) == 0);
+		ASSERT((bits0&0xFFFFFFF8) == 0);
+		ASSERT((bit1&0xFFFFFFFE) == 0);
+		ASSERT((bit2&0xFFFFFFFE) == 0);
+		ASSERT((reg&0xFFFFFFE0) == 0);
+		ASSERT((immediate&0xffff0000) == 0);
+
+		m_buffer.putInt((primary<<(31-5))|(bits0<<(31-8))|(bit1<<(31-9))|(bit2<<(31-10))|(reg<<(31-15))|(immediate<<(31-31)));
+	}
+
+        ALWAYS_INLINE void emit3Regs1BitSecondaryOp1Bit(uint32_t primary, uint32_t reg0, uint32_t reg1, uint32_t reg2, uint32_t bit0, uint32_t secondary, uint32_t bit1)
+	{
+		ASSERT((primary&0xFFFFFFC0) == 0);
+		ASSERT((reg0&0xFFFFFFE0) == 0);
+		ASSERT((reg1&0xFFFFFFE0) == 0);
+		ASSERT((reg2&0xFFFFFFE0) == 0);
+		ASSERT((bit0&0xFFFFFFFE) == 0);
+		ASSERT((secondary&0xFFFFFFE00) == 0);
+		ASSERT((bit1&0xFFFFFFFE) == 0);
+
+		m_buffer.putInt((primary<<(31-5))|(reg0<<(31-10))|(reg1<<(31-15))|(reg2<<(31-20))|(bit0<<(31-21))|(secondary<<(31-30))|(bit1<<(31-31)));
+	}
+
+        ALWAYS_INLINE void emit3RegsSecondaryOp1Bit(uint32_t primary, uint32_t reg0, uint32_t reg1, uint32_t reg2, uint32_t secondary, uint32_t bit0)
+	{
+		ASSERT((primary&0xFFFFFFC0) == 0);
+		ASSERT((reg0&0xFFFFFFE0) == 0);
+		ASSERT((reg1&0xFFFFFFE0) == 0);
+		ASSERT((reg2&0xFFFFFFE0) == 0);
+		ASSERT((secondary&0xFFFFFFC00) == 0);
+		ASSERT((bit0&0xFFFFFFFE) == 0);
+
+		m_buffer.putInt((primary<<(31-5))|(reg0<<(31-10))|(reg1<<(31-15))|(reg2<<(31-20))|(secondary<<(31-30))|(bit0<<(31-31)));
+	}
+
+        ALWAYS_INLINE void emit4RegsSecondaryOp1Bit(uint32_t primary, uint32_t reg0, uint32_t reg1, uint32_t reg2, uint32_t reg3, uint32_t secondary, uint32_t bit0)
+	{
+		ASSERT((primary&0xFFFFFFC0) == 0);
+		ASSERT((reg0&0xFFFFFFE0) == 0);
+		ASSERT((reg1&0xFFFFFFE0) == 0);
+		ASSERT((reg2&0xFFFFFFE0) == 0);
+		ASSERT((reg3&0xFFFFFFE0) == 0);
+		ASSERT((secondary&0xFFFFFFFE0) == 0);
+		ASSERT((bit0&0xFFFFFFFE) == 0);
+
+		m_buffer.putInt((primary<<(31-5))|(reg0<<(31-10))|(reg1<<(31-15))|(reg2<<(31-20))|(reg3<<(31-25))|(secondary<<(31-30))|(bit0<<(31-31)));
+	}
+
+        ALWAYS_INLINE void emit5Regs1Bit(uint32_t primary, uint32_t reg0, uint32_t reg1, uint32_t reg2, uint32_t reg3, uint32_t reg4, uint32_t bit0)
+	{
+		ASSERT((primary&0xFFFFFFC0) == 0);
+		ASSERT((reg0&0xFFFFFFE0) == 0);
+		ASSERT((reg1&0xFFFFFFE0) == 0);
+		ASSERT((reg2&0xFFFFFFE0) == 0);
+		ASSERT((reg3&0xFFFFFFE0) == 0);
+		ASSERT((reg4&0xFFFFFFE0) == 0);
+		ASSERT((bit0&0xFFFFFFFE) == 0);
+
+		m_buffer.putInt((primary<<(31-5))|(reg0<<(31-10))|(reg1<<(31-15))|(reg2<<(31-20))|(reg3<<(31-25))|(reg4<<(31-30))|(bit0<<(31-31)));
+	}
+
+        // Administrative methods:
+
+        size_t codeSize() const { return m_buffer.codeSize(); }
+        AssemblerLabel label() const { return m_buffer.label(); }
+        bool isAligned(int alignment) const { return m_buffer.isAligned(alignment); }
+        void* data() const { return m_buffer.data(); }
+
+#if 0
+        PassRefPtr<ExecutableMemoryHandle> executableCopy(VM& vm, void* ownerUID, JITCompilationEffort effort)
+        {
+            return m_buffer.executableCopy(vm, ownerUID, effort);
+        }
+#endif
+
+        unsigned debugOffset() { return m_buffer.debugOffset(); }
+
+        AssemblerBuffer& buffer() { return m_buffer; }
+
+    private:
+        AssemblerBuffer m_buffer;
+    } m_formatter;
+
+    int m_indexOfLastWatchpoint;
+    int m_indexOfTailOfLastWatchpoint;
+
+    #warning remove this
+    int m_doemitdebug;
+    int m_gencount;
+};
+
+} // namespace JSC
+
+#endif // ENABLE(ASSEMBLER) && CPU(PPC)
+
+#endif // PPCAssembler_h
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/bytecode/CallLinkInfo.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/bytecode/CallLinkInfo.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/bytecode/CallLinkInfo.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/bytecode/CallLinkInfo.cpp	2018-06-27 11:34:47.226841885 +0000
@@ -36,9 +36,12 @@
 void CallLinkInfo::unlink(VM& vm, RepatchBuffer& repatchBuffer)
 {
     ASSERT(isLinked());
-    
+
+    foddprintf("%s:%d/%s(): Gonna repatch CallLinkInfo 0x%08x\n", __FILE__, __LINE__, __func__, (void *)this);
+
     repatchBuffer.revertJumpReplacementToBranchPtrWithPatch(RepatchBuffer::startOfBranchPtrWithPatchOnRegister(hotPathBegin), static_cast<MacroAssembler::RegisterID>(calleeGPR), 0);
     if (isDFG) {
+        foddprintf("%s:%d/%s(): is DFG\n", __FILE__, __LINE__, __func__);
 #if ENABLE(DFG_JIT)
         repatchBuffer.relink(callReturnLocation, (callType == Construct ? vm.getCTIStub(linkConstructThunkGenerator) : vm.getCTIStub(linkCallThunkGenerator)).code());
 #else
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp	2018-07-14 18:31:36.061869764 +0000
@@ -476,6 +476,7 @@
         if (InlineCallFrame* inlineCallFrame = inlineStackEntry->m_inlineCallFrame) {
             numArguments = inlineCallFrame->arguments.size();
             if (inlineCallFrame->isClosureCall) {
+                foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
                 flushDirect(inlineStackEntry->remapOperand(VirtualRegister(JSStack::Callee)));
                 flushDirect(inlineStackEntry->remapOperand(VirtualRegister(JSStack::ScopeChain)));
             }
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGFlushedAt.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGFlushedAt.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGFlushedAt.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGFlushedAt.cpp	2018-06-12 14:28:02.333668694 +0000
@@ -30,6 +30,8 @@
 
 namespace JSC { namespace DFG {
 
+#if ENABLE(DFG_JIT)
+
 void FlushedAt::dump(PrintStream& out) const
 {
     if (m_format == DeadFlush || m_format == ConflictingFlush)
@@ -43,6 +45,8 @@
     dump(out);
 }
 
+#endif
+
 } } // namespace JSC::DFG
 
 #endif // ENABLE(DFG_JIT)
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGJITCompiler.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGJITCompiler.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGJITCompiler.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGJITCompiler.cpp	2018-06-25 09:35:04.995268189 +0000
@@ -236,6 +236,7 @@
         info.codeOrigin = m_jsCalls[i].m_codeOrigin;
         linkBuffer.link(m_jsCalls[i].m_slowCall, FunctionPtr((m_vm->getCTIStub(info.callType == CallLinkInfo::Construct ? linkConstructThunkGenerator : linkCallThunkGenerator)).code().executableAddress()));
         info.callReturnLocation = linkBuffer.locationOfNearCall(m_jsCalls[i].m_slowCall);
+        foddprintf("%s:%d/%s(): Setting info 0x%08x hotPathBegin\n", __FILE__, __LINE__, __func__, &info);
         info.hotPathBegin = linkBuffer.locationOf(m_jsCalls[i].m_targetToCheck);
         info.hotPathOther = linkBuffer.locationOfNearCall(m_jsCalls[i].m_fastCall);
         info.calleeGPR = static_cast<unsigned>(m_jsCalls[i].m_callee);
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExit.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExit.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExit.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExit.cpp	2018-07-14 21:04:31.074066766 +0000
@@ -43,6 +43,7 @@
     , m_recoveryIndex(recoveryIndex)
     , m_streamIndex(streamIndex)
 {
+    jit->m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExit::OSRExit()\n", jit->m_jit.getgencount(), __LINE__);
     ASSERT(m_codeOrigin.isSet());
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExitCompiler32_64.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExitCompiler32_64.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExitCompiler32_64.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExitCompiler32_64.cpp	2018-07-14 22:06:28.684362031 +0000
@@ -38,6 +38,8 @@
 
 void OSRExitCompiler::compileExit(const OSRExit& exit, const Operands<ValueRecovery>& operands, SpeculationRecovery* recovery)
 {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit()\n", m_jit.getgencount(), __LINE__);
+
     // 1) Pro-forma stuff.
     if (Options::printEachOSRExit()) {
         SpeculationFailureDebugInfo* debugInfo = new SpeculationFailureDebugInfo;
@@ -46,6 +48,8 @@
         m_jit.debugCall(debugOperationPrintSpeculationFailure, debugInfo);
     }
     
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit()\n", m_jit.getgencount(), __LINE__);
+
     // 2) Perform speculation recovery. This only comes into play when an operation
     //    starts mutating state before verifying the speculation it has already made.
     
@@ -63,6 +67,8 @@
         }
     }
 
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit()\n", m_jit.getgencount(), __LINE__);
+
     // 3) Refine some value profile, if appropriate.
     
     if (!!exit.m_jsValueSource) {
@@ -168,6 +174,8 @@
     // Do a simplified OSR exit. See DFGOSRExitCompiler64.cpp's comment regarding how and wny we
     // do this simple approach.
 
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit()\n", m_jit.getgencount(), __LINE__);
+
     // 4) Save all state from GPRs into the scratch buffer.
     
     ScratchBuffer* scratchBuffer = m_jit.vm()->scratchBufferForSize(sizeof(EncodedJSValue) * operands.size());
@@ -201,6 +209,8 @@
     
     // Now all GPRs are free to reuse.
     
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit()\n", m_jit.getgencount(), __LINE__);
+
     // 5) Save all state from FPRs into the scratch buffer.
     
     for (size_t index = 0; index < operands.size(); ++index) {
@@ -219,6 +229,8 @@
     
     // Now all FPRs are free to reuse.
     
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit()\n", m_jit.getgencount(), __LINE__);
+
     // 6) Save all state from the stack into the scratch buffer. For simplicity we
     //    do this even for state that's already in the right place on the stack.
     //    It makes things simpler later.
@@ -251,6 +263,8 @@
         }
     }
     
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit()\n", m_jit.getgencount(), __LINE__);
+
     // 7) Do all data format conversions and store the results into the stack.
     
     bool haveArguments = false;
@@ -258,18 +272,42 @@
     for (size_t index = 0; index < operands.size(); ++index) {
         const ValueRecovery& recovery = operands[index];
         int operand = operands.operandForIndex(index);
+
+        if (recovery.technique() == InPair)
+        {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit(): InPair\n", m_jit.getgencount(), __LINE__);
+        }
+        else if (recovery.technique() == InFPR)
+        {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit(): InFPR\n", m_jit.getgencount(), __LINE__);
+        }
+        else if (recovery.technique() == DisplacedInJSStack)
+        {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit(): DisplacedInJSStack\n", m_jit.getgencount(), __LINE__);
+        }
+        else if (recovery.technique() == DoubleDisplacedInJSStack)
+        {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit(): DoubleDisplacedInJSStack\n", m_jit.getgencount(), __LINE__);
+        }
         
         switch (recovery.technique()) {
         case InPair:
         case InFPR:
         case DisplacedInJSStack:
         case DoubleDisplacedInJSStack:
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit(): InPair/InFPR/DisplacedInJSStack/DoubleDisplacedInJSStack\n", m_jit.getgencount(), __LINE__);
             m_jit.load32(
                 &bitwise_cast<EncodedValueDescriptor*>(scratch + index)->asBits.tag,
                 GPRInfo::regT0);
+
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": OSRExitCompiler::compileExit(): Loaded from 0x%08x: 0x%08x\n", m_jit.getgencount(), (unsigned int)&bitwise_cast<EncodedValueDescriptor*>(scratch + index)->asBits.tag, GPRInfo::regT0);
+
             m_jit.load32(
                 &bitwise_cast<EncodedValueDescriptor*>(scratch + index)->asBits.payload,
                 GPRInfo::regT1);
+
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": OSRExitCompiler::compileExit(): Loaded from 0x%08x: 0x%08x\n", m_jit.getgencount(), (unsigned int)&bitwise_cast<EncodedValueDescriptor*>(scratch + index)->asBits.payload, GPRInfo::regT1);
+
             m_jit.store32(
                 GPRInfo::regT0,
                 AssemblyHelpers::tagFor(operand));
@@ -280,6 +318,7 @@
             
         case UnboxedInt32InGPR:
         case Int32DisplacedInJSStack:
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit(): UnboxedInt32InGPR/Int32DisplacedInJSStack\n", m_jit.getgencount(), __LINE__);
             m_jit.load32(
                 &bitwise_cast<EncodedValueDescriptor*>(scratch + index)->asBits.payload,
                 GPRInfo::regT0);
@@ -293,6 +332,7 @@
             
         case UnboxedCellInGPR:
         case CellDisplacedInJSStack:
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit(): UnboxedCellInGPR/CellDisplacedInJSStack\n", m_jit.getgencount(), __LINE__);
             m_jit.load32(
                 &bitwise_cast<EncodedValueDescriptor*>(scratch + index)->asBits.payload,
                 GPRInfo::regT0);
@@ -306,6 +346,7 @@
             
         case UnboxedBooleanInGPR:
         case BooleanDisplacedInJSStack:
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit(): UnboxedBooleanInGPR/BooleanDisplacedInJSStack\n", m_jit.getgencount(), __LINE__);
             m_jit.load32(
                 &bitwise_cast<EncodedValueDescriptor*>(scratch + index)->asBits.payload,
                 GPRInfo::regT0);
@@ -318,6 +359,7 @@
             break;
             
         case Constant:
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit(): Constant\n", m_jit.getgencount(), __LINE__);
             m_jit.store32(
                 AssemblyHelpers::TrustedImm32(recovery.constant().tag()),
                 AssemblyHelpers::tagFor(operand));
@@ -327,6 +369,7 @@
             break;
             
         case ArgumentsThatWereNotCreated:
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit(): ArgumentsThatWereNotCreated\n", m_jit.getgencount(), __LINE__);
             haveArguments = true;
             m_jit.store32(
                 AssemblyHelpers::TrustedImm32(JSValue().tag()),
@@ -341,6 +384,8 @@
         }
     }
     
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: OSRExitCompiler::compileExit()\n", m_jit.getgencount(), __LINE__);
+
     // 8) Adjust the old JIT's execute counter. Since we are exiting OSR, we know
     //    that all new calls into this code will go to the new JIT, so the execute
     //    counter only affects call frames that performed OSR exit and call frames
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExitCompilerCommon.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExitCompilerCommon.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExitCompilerCommon.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGOSRExitCompilerCommon.cpp	2018-07-14 21:11:44.529176051 +0000
@@ -88,7 +88,9 @@
 void reifyInlinedCallFrames(CCallHelpers& jit, const OSRExitBase& exit)
 {
     ASSERT(jit.baselineCodeBlock()->jitType() == JITCode::BaselineJIT);
-    jit.storePtr(AssemblyHelpers::TrustedImmPtr(jit.baselineCodeBlock()), AssemblyHelpers::addressFor((VirtualRegister)JSStack::CodeBlock));
+    jit.storePtr(AssemblyHelpers::TrustedImmPtr(jit.baselineCodeBlock()), AssemblyHelpers::payloadFor((VirtualRegister)JSStack::CodeBlock));
+
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: reifyInlinedCallFrames()\n", jit.getgencount(), __LINE__, PPCRegisters::r14);
 
     CodeOrigin codeOrigin;
     for (codeOrigin = exit.m_codeOrigin; codeOrigin.inlineCallFrame; codeOrigin = codeOrigin.inlineCallFrame->caller) {
@@ -108,7 +110,7 @@
             callerFrameGPR = GPRInfo::callFrameRegister;
         
 #if USE(JSVALUE64)
-        jit.storePtr(AssemblyHelpers::TrustedImmPtr(baselineCodeBlock), AssemblyHelpers::addressFor((VirtualRegister)(inlineCallFrame->stackOffset + JSStack::CodeBlock)));
+        jit.storePtr(AssemblyHelpers::TrustedImmPtr(baselineCodeBlock), AssemblyHelpers::payloadFor((VirtualRegister)(inlineCallFrame->stackOffset + JSStack::CodeBlock)));
         if (!inlineCallFrame->isClosureCall)
             jit.store64(AssemblyHelpers::TrustedImm64(JSValue::encode(JSValue(inlineCallFrame->calleeConstant()->scope()))), AssemblyHelpers::addressFor((VirtualRegister)(inlineCallFrame->stackOffset + JSStack::ScopeChain)));
         jit.store64(callerFrameGPR, AssemblyHelpers::addressForByteOffset(inlineCallFrame->callerFrameOffset()));
@@ -123,7 +125,7 @@
         if (baselineCodeBlock->usesArguments())
             jit.loadPtr(AssemblyHelpers::addressFor(VirtualRegister(inlineCallFrame->stackOffset + unmodifiedArgumentsRegister(baselineCodeBlock->argumentsRegister()).offset())), GPRInfo::regT3);
 #else // USE(JSVALUE64) // so this is the 32-bit part
-        jit.storePtr(AssemblyHelpers::TrustedImmPtr(baselineCodeBlock), AssemblyHelpers::addressFor((VirtualRegister)(inlineCallFrame->stackOffset + JSStack::CodeBlock)));
+        jit.storePtr(AssemblyHelpers::TrustedImmPtr(baselineCodeBlock), AssemblyHelpers::payloadFor((VirtualRegister)(inlineCallFrame->stackOffset + JSStack::CodeBlock)));
         jit.store32(AssemblyHelpers::TrustedImm32(JSValue::CellTag), AssemblyHelpers::tagFor((VirtualRegister)(inlineCallFrame->stackOffset + JSStack::ScopeChain)));
         if (!inlineCallFrame->isClosureCall)
             jit.storePtr(AssemblyHelpers::TrustedImmPtr(inlineCallFrame->calleeConstant()->scope()), AssemblyHelpers::payloadFor((VirtualRegister)(inlineCallFrame->stackOffset + JSStack::ScopeChain)));
@@ -162,7 +164,11 @@
 void adjustAndJumpToTarget(CCallHelpers& jit, const OSRExitBase& exit)
 {
     if (exit.m_codeOrigin.inlineCallFrame)
+    {
+        jit.dprint("JIT@% 3d: " __FILE__ ":%d: Old Call Frame is 0x%08x\n", jit.getgencount(), __LINE__, PPCRegisters::r14);
         jit.addPtr(AssemblyHelpers::TrustedImm32(exit.m_codeOrigin.inlineCallFrame->stackOffset * sizeof(EncodedJSValue)), GPRInfo::callFrameRegister);
+        jit.dprint("JIT@% 3d: " __FILE__ ":%d: New Call Frame is 0x%08x\n", jit.getgencount(), __LINE__, PPCRegisters::r14);
+    }
 
     CodeBlock* baselineCodeBlock = jit.baselineCodeBlockFor(exit.m_codeOrigin);
     Vector<BytecodeAndMachineOffset>& decodedCodeMap = jit.decodedCodeMapFor(baselineCodeBlock);
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGSlowPathGenerator.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGSlowPathGenerator.h
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGSlowPathGenerator.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGSlowPathGenerator.h	2018-06-28 08:58:07.532586342 +0000
@@ -159,6 +159,7 @@
     virtual void generateInternal(SpeculativeJIT* jit) OVERRIDE
     {
         this->setUp(jit);
+        jit->m_jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit->m_jit.getgencount(), __LINE__);
         this->recordCall(jit->callOperation(this->m_function, extractResult(this->m_result)));
         this->tearDown(jit);
     }
@@ -183,6 +184,7 @@
     virtual void generateInternal(SpeculativeJIT* jit) OVERRIDE
     {
         this->setUp(jit);
+        jit->m_jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit->m_jit.getgencount(), __LINE__);
         this->recordCall(jit->callOperation(this->m_function, extractResult(this->m_result), m_argument1));
         this->tearDown(jit);
     }
@@ -211,6 +213,7 @@
     virtual void generateInternal(SpeculativeJIT* jit) OVERRIDE
     {
         this->setUp(jit);
+        jit->m_jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit->m_jit.getgencount(), __LINE__);
         this->recordCall(jit->callOperation(this->m_function, extractResult(this->m_result), m_argument1, m_argument2));
         this->tearDown(jit);
     }
@@ -241,6 +244,7 @@
     virtual void generateInternal(SpeculativeJIT* jit) OVERRIDE
     {
         this->setUp(jit);
+        jit->m_jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit->m_jit.getgencount(), __LINE__);
         this->recordCall(
             jit->callOperation(
                 this->m_function, extractResult(this->m_result), m_argument1, m_argument2,
@@ -277,6 +281,7 @@
     void generateInternal(SpeculativeJIT* jit)
     {
         this->setUp(jit);
+        jit->m_jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit->m_jit.getgencount(), __LINE__);
         this->recordCall(
             jit->callOperation(
                 this->m_function, extractResult(this->m_result), m_argument1, m_argument2,
@@ -316,6 +321,7 @@
     void generateInternal(SpeculativeJIT* jit)
     {
         this->setUp(jit);
+        jit->m_jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit->m_jit.getgencount(), __LINE__);
         this->recordCall(
             jit->callOperation(
                 this->m_function, extractResult(this->m_result), m_argument1, m_argument2,
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp	2018-07-14 21:00:07.452172291 +0000
@@ -112,6 +112,7 @@
         return;
     ASSERT(m_isCheckingArgumentTypes || m_canExit);
     m_jit.appendExitInfo(jumpToFail);
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: backwardSpeculationCheck()\n", m_jit.getgencount(), __LINE__);
     m_jit.jitCode()->appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(node), this, m_stream->size()));
 }
 
@@ -126,6 +127,8 @@
 
 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, MacroAssembler::Jump jumpToFail)
 {
+    foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::speculationCheck():\n", m_jit.getgencount(), __LINE__);
     if (!m_compileOkay)
         return;
     backwardSpeculationCheck(kind, jsValueSource, node, jumpToFail);
@@ -135,6 +138,8 @@
 
 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, MacroAssembler::Jump jumpToFail)
 {
+    foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::speculationCheck():\n", m_jit.getgencount(), __LINE__);
     ASSERT(m_isCheckingArgumentTypes || m_canExit);
     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpToFail);
 }
@@ -158,6 +163,8 @@
 
 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, const MacroAssembler::JumpList& jumpsToFail)
 {
+    foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::speculationCheck():\n", m_jit.getgencount(), __LINE__);
     if (!m_compileOkay)
         return;
     backwardSpeculationCheck(kind, jsValueSource, node, jumpsToFail);
@@ -167,6 +174,8 @@
 
 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, const MacroAssembler::JumpList& jumpsToFail)
 {
+    foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::speculationCheck():\n", m_jit.getgencount(), __LINE__);
     ASSERT(m_isCheckingArgumentTypes || m_canExit);
     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpsToFail);
 }
@@ -189,6 +198,8 @@
 
 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, MacroAssembler::Jump jumpToFail, const SpeculationRecovery& recovery)
 {
+    foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::speculationCheck():\n", m_jit.getgencount(), __LINE__);
     if (!m_compileOkay)
         return;
     backwardSpeculationCheck(kind, jsValueSource, node, jumpToFail, recovery);
@@ -198,6 +209,8 @@
 
 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge edge, MacroAssembler::Jump jumpToFail, const SpeculationRecovery& recovery)
 {
+    foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::speculationCheck():\n", m_jit.getgencount(), __LINE__);
     speculationCheck(kind, jsValueSource, edge.node(), jumpToFail, recovery);
 }
 
@@ -308,7 +321,10 @@
 #if CALLING_CONVENTION_IS_STDCALL || CPU(ARM_THUMB2)
 static double JIT_OPERATION fmodAsDFGOperation(double x, double y)
 {
-    return fmod(x, y);
+    double ret;
+    ret = fmod(x, y);
+    foddprintf("%s:%d/%s(): %f mod %f returning %f\n", __FILE__, __LINE__, __func__, x, y, ret);
+    return ret;
 }
 #else
 #define fmodAsDFGOperation fmod
@@ -3315,6 +3331,7 @@
 {
     switch (node->binaryUseKind()) {
     case Int32Use: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::compileArithMod(): Int32Use\n", m_jit.getgencount(), __LINE__);
         // In the fast path, the dividend value could be the final result
         // (in case of |dividend| < |divisor|), so we speculate it as strict int32.
         SpeculateStrictInt32Operand op1(this, node->child1());
@@ -3566,6 +3583,7 @@
     }
         
     case NumberUse: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::compileArithMod(): NumberUse\n", m_jit.getgencount(), __LINE__);
         SpeculateDoubleOperand op1(this, node->child1());
         SpeculateDoubleOperand op2(this, node->child2());
         
@@ -3575,8 +3593,13 @@
         flushRegisters();
         
         FPRResult result(this);
+
+        m_jit.dprint("JIT@% 3d: %f mod %f\n", m_jit.getgencount(), op1FPR, op2FPR);
         
         callOperation(fmodAsDFGOperation, result.fpr(), op1FPR, op2FPR);
+
+        m_jit.dprint("JIT@% 3d: Result register is %d\n", m_jit.getgencount(), (int)(result.fpr()));
+        m_jit.dprint("JIT@% 3d: Result is %f\n", m_jit.getgencount(), result.fpr());
         
         doubleResult(result.fpr(), node);
         return;
@@ -3591,9 +3614,13 @@
 // Returns true if the compare is fused with a subsequent branch.
 bool SpeculativeJIT::compare(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_EJJ operation)
 {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::compare()\n", m_jit.getgencount(), __LINE__);
+
     if (compilePeepHoleBranch(node, condition, doubleCondition, operation))
         return true;
 
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::compare()\n", m_jit.getgencount(), __LINE__);
+
     if (node->isBinaryUseKind(Int32Use)) {
         compileInt32Compare(node, condition);
         return false;
@@ -3611,7 +3638,10 @@
         return false;
     }
     
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::compare()\n", m_jit.getgencount(), __LINE__);
+
     if (node->op() == CompareEq) {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::compare()\n", m_jit.getgencount(), __LINE__);
         if (node->isBinaryUseKind(StringUse)) {
             compileStringEquality(node);
             return false;
@@ -3643,7 +3673,9 @@
         }
     }
     
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::compare()\n", m_jit.getgencount(), __LINE__);
     nonSpeculativeNonPeepholeCompare(node, condition, operation);
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::compare()\n", m_jit.getgencount(), __LINE__);
     return false;
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.h
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.h	2018-07-15 19:27:50.415003028 +0000
@@ -935,6 +935,7 @@
 
     JITCompiler::Call callOperation(P_JITOperation_E operation, GPRReg result)
     {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", m_jit.getgencount(), __LINE__);
         m_jit.setupArgumentsExecState();
         return appendCallWithExceptionCheckSetResult(operation, result);
     }
@@ -1250,6 +1251,7 @@
     }
     JITCompiler::Call callOperation(J_JITOperation_ESsiJI operation, GPRReg result, StructureStubInfo* stubInfo, GPRReg arg1, StringImpl* uid)
     {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", m_jit.getgencount(), __LINE__);
         m_jit.setupArgumentsWithExecState(TrustedImmPtr(stubInfo), arg1, TrustedImmPtr(uid));
         return appendCallWithExceptionCheckSetResult(operation, result);
     }
@@ -1410,7 +1412,7 @@
 
 // EncodedJSValue in JSVALUE32_64 is a 64-bit integer. When being compiled in ARM EABI, it must be aligned even-numbered register (r0, r2 or [sp]).
 // To avoid assemblies from using wrong registers, let's occupy r1 or r3 with a dummy argument when necessary.
-#if (COMPILER_SUPPORTS(EABI) && CPU(ARM)) || CPU(MIPS)
+#if (COMPILER_SUPPORTS(EABI) && CPU(ARM)) || CPU(MIPS) || CPU(PPC)
 #define EABI_32BIT_DUMMY_ARG      TrustedImm32(0),
 #else
 #define EABI_32BIT_DUMMY_ARG
@@ -1425,6 +1427,12 @@
 #define SH4_32BIT_DUMMY_ARG
 #endif
 
+#if CPU(BIG_ENDIAN)
+#define TAGPAYLOADREGPAIR(tag, payload) tag, payload
+#else
+#define TAGPAYLOADREGPAIR(tag, payload) payload, tag
+#endif
+
     JITCompiler::Call callOperation(Z_JITOperation_D operation, GPRReg result, FPRReg arg1)
     {
         prepareForExternalCall();
@@ -1485,12 +1493,12 @@
     }
     JITCompiler::Call callOperation(J_JITOperation_EJP operation, GPRReg resultTag, GPRReg resultPayload, GPRReg arg1Tag, GPRReg arg1Payload, void* pointer)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, TrustedImmPtr(pointer));
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), TrustedImmPtr(pointer));
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
     JITCompiler::Call callOperation(J_JITOperation_EJP operation, GPRReg resultTag, GPRReg resultPayload, GPRReg arg1Tag, GPRReg arg1Payload, GPRReg arg2)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, arg2);
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), arg2);
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
 
@@ -1506,12 +1514,14 @@
     }
     JITCompiler::Call callOperation(J_JITOperation_ESsiJI operation, GPRReg resultTag, GPRReg resultPayload, StructureStubInfo* stubInfo, GPRReg arg1Tag, GPRReg arg1Payload, StringImpl* uid)
     {
-        m_jit.setupArgumentsWithExecState(TrustedImmPtr(stubInfo), arg1Payload, arg1Tag, TrustedImmPtr(uid));
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", m_jit.getgencount(), __LINE__);
+        m_jit.setupArgumentsWithExecState(TrustedImmPtr(stubInfo), TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), TrustedImmPtr(uid));
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
     JITCompiler::Call callOperation(J_JITOperation_ESsiJI operation, GPRReg resultTag, GPRReg resultPayload, StructureStubInfo* stubInfo, int32_t arg1Tag, GPRReg arg1Payload, StringImpl* uid)
     {
-        m_jit.setupArgumentsWithExecState(TrustedImmPtr(stubInfo), arg1Payload, TrustedImm32(arg1Tag), TrustedImmPtr(uid));
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", m_jit.getgencount(), __LINE__);
+        m_jit.setupArgumentsWithExecState(TrustedImmPtr(stubInfo), TAGPAYLOADREGPAIR(TrustedImm32(arg1Tag), arg1Payload), TrustedImmPtr(uid));
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
     JITCompiler::Call callOperation(J_JITOperation_EDA operation, GPRReg resultTag, GPRReg resultPayload, FPRReg arg1, GPRReg arg2)
@@ -1521,17 +1531,17 @@
     }
     JITCompiler::Call callOperation(J_JITOperation_EJA operation, GPRReg resultTag, GPRReg resultPayload, GPRReg arg1Tag, GPRReg arg1Payload, GPRReg arg2)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, arg2);
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), arg2);
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
     JITCompiler::Call callOperation(J_JITOperation_EJA operation, GPRReg resultTag, GPRReg resultPayload, TrustedImm32 arg1Tag, GPRReg arg1Payload, GPRReg arg2)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, arg2);
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), arg2);
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
     JITCompiler::Call callOperation(J_JITOperation_EJ operation, GPRReg resultTag, GPRReg resultPayload, GPRReg arg1Tag, GPRReg arg1Payload)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag);
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload));
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
     JITCompiler::Call callOperation(J_JITOperation_EZ operation, GPRReg resultTag, GPRReg resultPayload, GPRReg arg1)
@@ -1563,50 +1573,51 @@
 
     JITCompiler::Call callOperation(P_JITOperation_EStJ operation, GPRReg result, Structure* structure, GPRReg arg2Tag, GPRReg arg2Payload)
     {
-        m_jit.setupArgumentsWithExecState(TrustedImmPtr(structure), arg2Payload, arg2Tag);
+        m_jit.setupArgumentsWithExecState(TrustedImmPtr(structure), TAGPAYLOADREGPAIR(arg2Tag, arg2Payload));
         return appendCallWithExceptionCheckSetResult(operation, result);
     }
 
     JITCompiler::Call callOperation(C_JITOperation_EJ operation, GPRReg result, GPRReg arg1Tag, GPRReg arg1Payload)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag);
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload));
         return appendCallWithExceptionCheckSetResult(operation, result);
     }
     JITCompiler::Call callOperation(S_JITOperation_J operation, GPRReg result, GPRReg arg1Tag, GPRReg arg1Payload)
     {
-        m_jit.setupArguments(arg1Payload, arg1Tag);
+        m_jit.setupArguments(TAGPAYLOADREGPAIR(arg1Tag, arg1Payload));
         return appendCallSetResult(operation, result);
     }
     JITCompiler::Call callOperation(S_JITOperation_EJ operation, GPRReg result, GPRReg arg1Tag, GPRReg arg1Payload)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag);
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload));
         return appendCallWithExceptionCheckSetResult(operation, result);
     }
 
     JITCompiler::Call callOperation(S_JITOperation_EJJ operation, GPRReg result, GPRReg arg1Tag, GPRReg arg1Payload, GPRReg arg2Tag, GPRReg arg2Payload)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, SH4_32BIT_DUMMY_ARG arg2Payload, arg2Tag);
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: callOperation(S_JITOperation_EJJ operation, GPRReg result, GPRReg arg1Tag, GPRReg arg1Payload, GPRReg arg2Tag, GPRReg arg2Payload)\n", m_jit.getgencount(), __LINE__);
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), SH4_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg2Tag, arg2Payload));
         return appendCallWithExceptionCheckSetResult(operation, result);
     }
     JITCompiler::Call callOperation(J_JITOperation_EJJ operation, GPRReg resultTag, GPRReg resultPayload, GPRReg arg1Tag, GPRReg arg1Payload, GPRReg arg2Tag, GPRReg arg2Payload)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, SH4_32BIT_DUMMY_ARG arg2Payload, arg2Tag);
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), SH4_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg2Tag, arg2Payload));
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
     JITCompiler::Call callOperation(J_JITOperation_EJJ operation, GPRReg resultTag, GPRReg resultPayload, GPRReg arg1Tag, GPRReg arg1Payload, MacroAssembler::TrustedImm32 imm)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, SH4_32BIT_DUMMY_ARG imm, TrustedImm32(JSValue::Int32Tag));
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), SH4_32BIT_DUMMY_ARG imm, TrustedImm32(JSValue::Int32Tag));
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
     JITCompiler::Call callOperation(J_JITOperation_EJJ operation, GPRReg resultTag, GPRReg resultPayload, MacroAssembler::TrustedImm32 imm, GPRReg arg2Tag, GPRReg arg2Payload)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG imm, TrustedImm32(JSValue::Int32Tag), SH4_32BIT_DUMMY_ARG arg2Payload, arg2Tag);
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG imm, TrustedImm32(JSValue::Int32Tag), SH4_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg2Tag, arg2Payload));
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
 
     JITCompiler::Call callOperation(J_JITOperation_ECJ operation, GPRReg resultTag, GPRReg resultPayload, GPRReg arg1, GPRReg arg2Tag, GPRReg arg2Payload)
     {
-        m_jit.setupArgumentsWithExecState(arg1, arg2Payload, arg2Tag);
+        m_jit.setupArgumentsWithExecState(arg1, TAGPAYLOADREGPAIR(arg2Tag, arg2Payload));
         return appendCallWithExceptionCheckSetResult(operation, resultPayload, resultTag);
     }
     JITCompiler::Call callOperation(J_JITOperation_ECJ operation, JSValueRegs result, GPRReg arg1, JSValueRegs arg2)
@@ -1628,40 +1639,40 @@
 
     JITCompiler::Call callOperation(V_JITOperation_EJPP operation, GPRReg arg1Tag, GPRReg arg1Payload, GPRReg arg2, void* pointer)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, arg2, TrustedImmPtr(pointer));
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), arg2, TrustedImmPtr(pointer));
         return appendCallWithExceptionCheck(operation);
     }
     JITCompiler::Call callOperation(V_JITOperation_ESsiJJI operation, StructureStubInfo* stubInfo, GPRReg arg1Tag, GPRReg arg1Payload, GPRReg arg2Payload, StringImpl* uid)
     {
-        m_jit.setupArgumentsWithExecState(TrustedImmPtr(stubInfo), arg1Payload, arg1Tag, arg2Payload, TrustedImm32(JSValue::CellTag), TrustedImmPtr(uid));
+        m_jit.setupArgumentsWithExecState(TrustedImmPtr(stubInfo), TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), TAGPAYLOADREGPAIR(TrustedImm32(JSValue::CellTag), arg2Payload), TrustedImmPtr(uid));
         return appendCallWithExceptionCheck(operation);
     }
     JITCompiler::Call callOperation(V_JITOperation_ECJJ operation, GPRReg arg1, GPRReg arg2Tag, GPRReg arg2Payload, GPRReg arg3Tag, GPRReg arg3Payload)
     {
-        m_jit.setupArgumentsWithExecState(arg1, arg2Payload, arg2Tag, arg3Payload, arg3Tag);
+        m_jit.setupArgumentsWithExecState(arg1, TAGPAYLOADREGPAIR(arg2Tag, arg2Payload), TAGPAYLOADREGPAIR(arg3Tag, arg3Payload));
         return appendCallWithExceptionCheck(operation);
     }
 
     JITCompiler::Call callOperation(V_JITOperation_EPZJ operation, GPRReg arg1, GPRReg arg2, GPRReg arg3Tag, GPRReg arg3Payload)
     {
-        m_jit.setupArgumentsWithExecState(arg1, arg2, EABI_32BIT_DUMMY_ARG SH4_32BIT_DUMMY_ARG arg3Payload, arg3Tag);
+        m_jit.setupArgumentsWithExecState(arg1, arg2, EABI_32BIT_DUMMY_ARG SH4_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg3Tag, arg3Payload));
         return appendCallWithExceptionCheck(operation);
     }
 
     JITCompiler::Call callOperation(V_JITOperation_EOZJ operation, GPRReg arg1, GPRReg arg2, GPRReg arg3Tag, GPRReg arg3Payload)
     {
-        m_jit.setupArgumentsWithExecState(arg1, arg2, EABI_32BIT_DUMMY_ARG SH4_32BIT_DUMMY_ARG arg3Payload, arg3Tag);
+        m_jit.setupArgumentsWithExecState(arg1, arg2, EABI_32BIT_DUMMY_ARG SH4_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg3Tag, arg3Payload));
         return appendCallWithExceptionCheck(operation);
     }
     JITCompiler::Call callOperation(V_JITOperation_EOZJ operation, GPRReg arg1, GPRReg arg2, TrustedImm32 arg3Tag, GPRReg arg3Payload)
     {
-        m_jit.setupArgumentsWithExecState(arg1, arg2, EABI_32BIT_DUMMY_ARG SH4_32BIT_DUMMY_ARG arg3Payload, arg3Tag);
+        m_jit.setupArgumentsWithExecState(arg1, arg2, EABI_32BIT_DUMMY_ARG SH4_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg3Tag, arg3Payload));
         return appendCallWithExceptionCheck(operation);
     }
 
     JITCompiler::Call callOperation(D_JITOperation_EJ operation, FPRReg result, GPRReg arg1Tag, GPRReg arg1Payload)
     {
-        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag);
+        m_jit.setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload));
         return appendCallWithExceptionCheckSetResult(operation, result);
     }
 
@@ -1784,6 +1795,12 @@
     JITCompiler::Call appendCallWithExceptionCheckSetResult(const FunctionPtr& function, GPRReg result1, GPRReg result2)
     {
         JITCompiler::Call call = appendCallWithExceptionCheck(function);
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: appendCallWithExceptionCheckSetResult(const FunctionPtr& function, GPRReg result1, GPRReg result2)\n", m_jit.getgencount(), __LINE__);
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: GPRInfo::returnValueGPR 0x%08x GPRInfo::returnValueGPR2 0x%08x\n", m_jit.getgencount(), __LINE__, GPRInfo::returnValueGPR, GPRInfo::returnValueGPR2);
+#warning I hope this is right
+#if CPU(BIG_ENDIAN)
+        m_jit.swap(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR2);
+#endif
         m_jit.setupResults(result1, result2);
         return call;
     }
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp	2018-07-15 18:35:57.268214897 +0000
@@ -44,6 +44,8 @@
 
 bool SpeculativeJIT::fillJSValue(Edge edge, GPRReg& tagGPR, GPRReg& payloadGPR, FPRReg& fpr)
 {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue()\n", m_jit.getgencount(), __LINE__);
+
     // FIXME: For double we could fill with a FPR.
     UNUSED_PARAM(fpr);
 
@@ -52,8 +54,10 @@
 
     switch (info.registerFormat()) {
     case DataFormatNone: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue(): DataFormatNone\n", m_jit.getgencount(), __LINE__);
 
         if (edge->hasConstant()) {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue(): hasConstant\n", m_jit.getgencount(), __LINE__);
             tagGPR = allocate();
             payloadGPR = allocate();
             m_jit.move(Imm32(valueOfJSConstant(edge.node()).tag()), tagGPR);
@@ -62,24 +66,29 @@
             m_gprs.retain(payloadGPR, virtualRegister, SpillOrderConstant);
             info.fillJSValue(*m_stream, tagGPR, payloadGPR, isInt32Constant(edge.node()) ? DataFormatJSInt32 : DataFormatJS);
         } else {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue(): !hasConstant\n", m_jit.getgencount(), __LINE__);
             DataFormat spillFormat = info.spillFormat();
             ASSERT(spillFormat != DataFormatNone && spillFormat != DataFormatStorage);
             tagGPR = allocate();
             payloadGPR = allocate();
             switch (spillFormat) {
             case DataFormatInt32:
+                m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue(): DataFormatInt32\n", m_jit.getgencount(), __LINE__);
                 m_jit.move(TrustedImm32(JSValue::Int32Tag), tagGPR);
                 spillFormat = DataFormatJSInt32; // This will be used as the new register format.
                 break;
             case DataFormatCell:
+                m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue(): DataFormatCell\n", m_jit.getgencount(), __LINE__);
                 m_jit.move(TrustedImm32(JSValue::CellTag), tagGPR);
                 spillFormat = DataFormatJSCell; // This will be used as the new register format.
                 break;
             case DataFormatBoolean:
+                m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue(): DataFormatBoolean\n", m_jit.getgencount(), __LINE__);
                 m_jit.move(TrustedImm32(JSValue::BooleanTag), tagGPR);
                 spillFormat = DataFormatJSBoolean; // This will be used as the new register format.
                 break;
             default:
+                m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue(): default\n", m_jit.getgencount(), __LINE__);
                 m_jit.load32(JITCompiler::tagFor(virtualRegister), tagGPR);
                 break;
             }
@@ -95,6 +104,7 @@
     case DataFormatInt32:
     case DataFormatCell:
     case DataFormatBoolean: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue(): DataFormatNone\n", m_jit.getgencount(), __LINE__);
         GPRReg gpr = info.gpr();
         // If the register has already been locked we need to take a copy.
         if (m_gprs.isLocked(gpr)) {
@@ -134,6 +144,7 @@
 
     case DataFormatJSDouble:
     case DataFormatDouble: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue(): DataFormatJSDouble/DataFormatDouble\n", m_jit.getgencount(), __LINE__);
         FPRReg oldFPR = info.fpr();
         m_fprs.lock(oldFPR);
         tagGPR = allocate();
@@ -151,6 +162,7 @@
     case DataFormatJSInt32:
     case DataFormatJSCell:
     case DataFormatJSBoolean: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillJSValue(): DataFormatJS/DataFormatJSInt32/DataFormatJSCell/DataFormatJSBoolean\n", m_jit.getgencount(), __LINE__);
         tagGPR = info.tagGPR();
         payloadGPR = info.payloadGPR();
         m_gprs.lock(tagGPR);
@@ -170,6 +182,8 @@
 
 void SpeculativeJIT::cachedGetById(CodeOrigin codeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode)
 {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::cachedGetById()\n", m_jit.getgencount(), __LINE__);
+
     JITGetByIdGenerator gen(
         m_jit.codeBlock(), codeOrigin, usedRegisters(), GPRInfo::callFrameRegister,
         JSValueRegs(baseTagGPROrNone, basePayloadGPR),
@@ -184,12 +198,14 @@
     
     OwnPtr<SlowPathGenerator> slowPath;
     if (baseTagGPROrNone == InvalidGPRReg) {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::cachedGetById(): baseTagGPROrNone == InvalidGPRReg\n", m_jit.getgencount(), __LINE__);
         slowPath = slowPathCall(
             slowCases, this, operationGetByIdOptimize,
             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(),
             static_cast<int32_t>(JSValue::CellTag), basePayloadGPR,
             identifierUID(identifierNumber));
     } else {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::cachedGetById(): have tag/payload pair\n", m_jit.getgencount(), __LINE__);
         slowPath = slowPathCall(
             slowCases, this, operationGetByIdOptimize,
             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(), baseTagGPROrNone,
@@ -360,6 +376,8 @@
 
 void SpeculativeJIT::nonSpeculativePeepholeBranch(Node* node, Node* branchNode, MacroAssembler::RelationalCondition cond, S_JITOperation_EJJ helperFunction)
 {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::nonSpeculativePeepholeBranch()\n", m_jit.getgencount(), __LINE__);
+
     BasicBlock* taken = branchNode->takenBlock();
     BasicBlock* notTaken = branchNode->notTakenBlock();
 
@@ -386,13 +404,17 @@
     
     if (isKnownNotInteger(node->child1().node()) || isKnownNotInteger(node->child2().node())) {
         GPRResult result(this);
+        GPRResult2 result2(this);
         GPRReg resultGPR = result.gpr();
+        GPRReg resultTagGPR = result2.gpr();
 
         arg1.use();
         arg2.use();
 
         flushRegisters();
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: Calling nonSpeculativeNonPeepholeCompare helper function\n", m_jit.getgencount(), __LINE__);
         callOperation(helperFunction, resultGPR, arg1TagGPR, arg1PayloadGPR, arg2TagGPR, arg2PayloadGPR);
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": nonSpeculativeNonPeepholeCompare helper function returned tag 0x%08x payload 0x%08x\n", m_jit.getgencount(), resultTagGPR, resultGPR);
 
         branchTest32(callResultCondition, resultGPR, taken);
     } else {
@@ -449,6 +471,9 @@
     virtual void generateInternal(SpeculativeJIT* jit)
     {
         this->setUp(jit);
+        jit->m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: CompareAndBoxBooleanSlowPathGenerator::generateInternal()\n", jit->m_jit.getgencount(), __LINE__);
+        jit->m_jit.dprint("JIT@% 3d: " __FILE__ ": arg1 tag 0x%08x payload 0x%08x\n", jit->m_jit.getgencount(), __LINE__, m_arg1Tag, m_arg1Payload);
+        jit->m_jit.dprint("JIT@% 3d: " __FILE__ ": arg2 tag 0x%08x payload 0x%08x\n", jit->m_jit.getgencount(), __LINE__, m_arg2Tag, m_arg2Payload);
         this->recordCall(
             jit->callOperation(
                 this->m_function, this->m_result, m_arg1Tag, m_arg1Payload, m_arg2Tag,
@@ -466,6 +491,7 @@
 
 void SpeculativeJIT::nonSpeculativeNonPeepholeCompare(Node* node, MacroAssembler::RelationalCondition cond, S_JITOperation_EJJ helperFunction)
 {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::nonSpeculativeNonPeepholeCompare()\n", m_jit.getgencount(), __LINE__);
     JSValueOperand arg1(this, node->child1());
     JSValueOperand arg2(this, node->child2());
     GPRReg arg1TagGPR = arg1.tagGPR();
@@ -476,39 +502,51 @@
     JITCompiler::JumpList slowPath;
     
     if (isKnownNotInteger(node->child1().node()) || isKnownNotInteger(node->child2().node())) {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::nonSpeculativeNonPeepholeCompare()\n", m_jit.getgencount(), __LINE__);
         GPRResult result(this);
+        GPRResult2 result2(this);
         GPRReg resultPayloadGPR = result.gpr();
+        GPRReg resultTagGPR = result2.gpr();
     
         arg1.use();
         arg2.use();
 
         flushRegisters();
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: Calling nonSpeculativeNonPeepholeCompare helper function\n", m_jit.getgencount(), __LINE__);
         callOperation(helperFunction, resultPayloadGPR, arg1TagGPR, arg1PayloadGPR, arg2TagGPR, arg2PayloadGPR);
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": nonSpeculativeNonPeepholeCompare helper function returned tag 0x%08x payload 0x%08x\n", m_jit.getgencount(), resultTagGPR, resultPayloadGPR);
         
         booleanResult(resultPayloadGPR, node, UseChildrenCalledExplicitly);
     } else {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::nonSpeculativeNonPeepholeCompare()\n", m_jit.getgencount(), __LINE__);
         GPRTemporary resultPayload(this, Reuse, arg1, PayloadWord);
         GPRReg resultPayloadGPR = resultPayload.gpr();
 
         arg1.use();
         arg2.use();
     
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::nonSpeculativeNonPeepholeCompare()\n", m_jit.getgencount(), __LINE__);
         if (!isKnownInteger(node->child1().node()))
             slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, arg1TagGPR, JITCompiler::TrustedImm32(JSValue::Int32Tag)));
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::nonSpeculativeNonPeepholeCompare()\n", m_jit.getgencount(), __LINE__);
         if (!isKnownInteger(node->child2().node()))
             slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, arg2TagGPR, JITCompiler::TrustedImm32(JSValue::Int32Tag)));
 
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::nonSpeculativeNonPeepholeCompare()\n", m_jit.getgencount(), __LINE__);
         m_jit.compare32(cond, arg1PayloadGPR, arg2PayloadGPR, resultPayloadGPR);
     
         if (!isKnownInteger(node->child1().node()) || !isKnownInteger(node->child2().node())) {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::nonSpeculativeNonPeepholeCompare()\n", m_jit.getgencount(), __LINE__);
             addSlowPathGenerator(adoptPtr(
                 new CompareAndBoxBooleanSlowPathGenerator<JITCompiler::JumpList>(
                     slowPath, this, helperFunction, resultPayloadGPR, arg1TagGPR,
                     arg1PayloadGPR, arg2TagGPR, arg2PayloadGPR)));
         }
         
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::nonSpeculativeNonPeepholeCompare()\n", m_jit.getgencount(), __LINE__);
         booleanResult(resultPayloadGPR, node, UseChildrenCalledExplicitly);
     }
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::nonSpeculativeNonPeepholeCompare()\n", m_jit.getgencount(), __LINE__);
 }
 
 void SpeculativeJIT::nonSpeculativePeepholeStrictEq(Node* node, Node* branchNode, bool invert)
@@ -609,6 +647,8 @@
 
 void SpeculativeJIT::emitCall(Node* node)
 {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::emitCall():\n", m_jit.getgencount(), __LINE__);
+
     if (node->op() != Call)
         ASSERT(node->op() == Construct);
 
@@ -624,6 +664,8 @@
     GPRReg calleePayloadGPR = callee.payloadGPR();
     use(calleeEdge);
 
+    m_jit.dprint("JIT@ xxx: " __FILE__ ": SpeculativeJIT::emitCall(): Callee tag GPR %d payload GPR %d\n", (int)calleeTagGPR, (int)calleePayloadGPR);
+
     // The call instruction's first child is either the function (normal call) or the
     // receiver (method call). subsequent children are the arguments.
     int numPassedArgs = node->numChildren() - 1;
@@ -632,7 +674,9 @@
 
     m_jit.store32(MacroAssembler::TrustedImm32(numArgs), calleeFramePayloadSlot(numArgs, JSStack::ArgumentCount));
     m_jit.storePtr(GPRInfo::callFrameRegister, calleeFrameCallerFrame(numArgs));
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::emitCall(): Storing callee payload\n", m_jit.getgencount(), __LINE__);
     m_jit.store32(calleePayloadGPR, calleeFramePayloadSlot(numArgs, JSStack::Callee));
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::emitCall(): Storing callee tag\n", m_jit.getgencount(), __LINE__);
     m_jit.store32(calleeTagGPR, calleeFrameTagSlot(numArgs, JSStack::Callee));
 
     for (int i = 0; i < numPassedArgs; i++) {
@@ -658,7 +702,9 @@
 
     m_jit.emitStoreCodeOrigin(node->codeOrigin);
     
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: Old Call Frame is 0x%08x\n", m_jit.getgencount(), __LINE__, PPCRegisters::r14);
     m_jit.addPtr(TrustedImm32(calleeFrameOffset(numArgs)), GPRInfo::callFrameRegister);
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: New Call Frame is 0x%08x\n", m_jit.getgencount(), __LINE__, PPCRegisters::r14);
     
     slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, calleeTagGPR, TrustedImm32(JSValue::CellTag)));
     slowPath.append(m_jit.branchPtrWithPatch(MacroAssembler::NotEqual, calleePayloadGPR, targetToCheck));
@@ -688,6 +734,7 @@
 
     done.link(&m_jit);
 
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: resultTagGPR 0x%08x resultPayloadGPR 0x%08x\n", m_jit.getgencount(), __LINE__, resultTagGPR, resultPayloadGPR);
     m_jit.setupResults(resultPayloadGPR, resultTagGPR);
 
     jsValueResult(resultTagGPR, resultPayloadGPR, node, DataFormatJS, UseChildrenCalledExplicitly);
@@ -930,6 +977,8 @@
 
 GPRReg SpeculativeJIT::fillSpeculateCell(Edge edge)
 {
+    m_jit.dprint("JIT@% 3d: " __FILE__ ": SpeculativeJIT::fillSpeculateCell():\n", m_jit.getgencount());
+
     AbstractValue& value = m_state.forNode(edge);
     SpeculatedType type = value.m_type;
     ASSERT((edge.useKind() != KnownCellUse && edge.useKind() != KnownStringUse) || !(value.m_type & ~SpecCell));
@@ -937,8 +986,11 @@
     VirtualRegister virtualRegister = edge->virtualRegister();
     GenerationInfo& info = generationInfoFromVirtualRegister(virtualRegister);
 
+    m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillSpeculateCell():\n", m_jit.getgencount(), __LINE__);
+
     switch (info.registerFormat()) {
     case DataFormatNone: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": SpeculativeJIT::fillSpeculateCell(): DataFormatNone\n", m_jit.getgencount());
         if (info.spillFormat() == DataFormatInt32 || info.spillFormat() == DataFormatDouble) {
             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
             return allocate();
@@ -968,6 +1020,7 @@
     }
 
     case DataFormatCell: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": SpeculativeJIT::fillSpeculateCell(): DataFormatCell\n", m_jit.getgencount());
         GPRReg gpr = info.gpr();
         m_gprs.lock(gpr);
         return gpr;
@@ -975,16 +1028,22 @@
 
     case DataFormatJSCell:
     case DataFormatJS: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": SpeculativeJIT::fillSpeculateCell(): DataFormatJS/DataFormatJSCell\n", m_jit.getgencount());
         GPRReg tagGPR = info.tagGPR();
         GPRReg payloadGPR = info.payloadGPR();
         m_gprs.lock(tagGPR);
         m_gprs.lock(payloadGPR);
         if (type & ~SpecCell)
+        {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: Calling speculationCheck()\n", m_jit.getgencount(), __LINE__);
             speculationCheck(BadType, JSValueRegs(tagGPR, payloadGPR), edge, m_jit.branch32(MacroAssembler::NotEqual, tagGPR, TrustedImm32(JSValue::CellTag)));
+            m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: speculationCheck() done\n", m_jit.getgencount(), __LINE__);
+        }
         m_gprs.unlock(tagGPR);
         m_gprs.release(tagGPR);
         m_gprs.release(payloadGPR);
         m_gprs.retain(payloadGPR, virtualRegister, SpillOrderCell);
+        m_jit.dprint("JIT@% 3d: " __FILE__ ":%d: SpeculativeJIT::fillSpeculateCell(): Calling info.fillCell\n", m_jit.getgencount(), __LINE__);
         info.fillCell(*m_stream, payloadGPR);
         return payloadGPR;
     }
@@ -995,6 +1054,7 @@
     case DataFormatDouble:
     case DataFormatJSBoolean:
     case DataFormatBoolean:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": SpeculativeJIT::fillSpeculateCell(): Other\n", m_jit.getgencount());
         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
         return allocate();
 
@@ -1805,8 +1865,11 @@
     m_jit.clearRegisterAllocationOffsets();
 #endif
 
+    m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG running op %d\n", m_jit.getgencount(), (int)op);
+
     switch (op) {
     case JSConstant:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op JSConstant\n", m_jit.getgencount());
         initConstantInfo(node);
         break;
 
@@ -1815,6 +1878,7 @@
         break;
 
     case WeakJSConstant:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op WeakJSConstant\n", m_jit.getgencount());
         m_jit.addWeakReference(node->weakConstant());
         initConstantInfo(node);
         break;
@@ -1825,6 +1889,7 @@
     }
 
     case GetLocal: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetLocal\n", m_jit.getgencount());
         SpeculatedType prediction = node->variableAccessData()->prediction();
         AbstractValue& value = m_state.variables().operand(node->local());
 
@@ -1845,6 +1910,7 @@
         
         switch (node->variableAccessData()->flushFormat()) {
         case FlushedDouble: {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetLocal: FlushedDouble\n", m_jit.getgencount());
             FPRTemporary result(this);
             m_jit.loadDouble(JITCompiler::addressFor(node->machineLocal()), result.fpr());
             VirtualRegister virtualRegister = node->virtualRegister();
@@ -1854,8 +1920,10 @@
         }
         
         case FlushedInt32: {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetLocal: FlushedInt32\n", m_jit.getgencount());
             GPRTemporary result(this);
             m_jit.load32(JITCompiler::payloadFor(node->machineLocal()), result.gpr());
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetLocal: FlushedInt32: Loaded value 0x%08x\n", m_jit.getgencount(), result.gpr());
             
             // Like int32Result, but don't useChildren - our children are phi nodes,
             // and don't represent values within this dataflow with virtual registers.
@@ -1866,6 +1934,7 @@
         }
         
         case FlushedCell: {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetLocal: FlushedCell\n", m_jit.getgencount());
             GPRTemporary result(this);
             m_jit.load32(JITCompiler::payloadFor(node->machineLocal()), result.gpr());
             
@@ -1878,6 +1947,7 @@
         }
             
         case FlushedBoolean: {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetLocal: FlushedBoolean\n", m_jit.getgencount());
             GPRTemporary result(this);
             m_jit.load32(JITCompiler::payloadFor(node->machineLocal()), result.gpr());
             
@@ -1891,10 +1961,13 @@
             
         case FlushedJSValue:
         case FlushedArguments: {
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetLocal: FlushedJSValue/FlushedArguments\n", m_jit.getgencount());
             GPRTemporary result(this);
             GPRTemporary tag(this);
             m_jit.load32(JITCompiler::payloadFor(node->machineLocal()), result.gpr());
             m_jit.load32(JITCompiler::tagFor(node->machineLocal()), tag.gpr());
+
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetLocal: FlushedJSValue/FlushedArguments: Loaded tag 0x%08x payload 0x%08x\n", m_jit.getgencount(), tag.gpr(), result.gpr());
             
             // Like jsValueResult, but don't useChildren - our children are phi nodes,
             // and don't represent values within this dataflow with virtual registers.
@@ -1933,6 +2006,7 @@
     }
 
     case SetLocal: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op SetLocal\n", m_jit.getgencount());
         // SetLocal doubles as a hint as to where a node will be stored and
         // as a speculation point. So before we speculate make sure that we
         // know where the child of this node needs to go in the virtual
@@ -2002,6 +2076,7 @@
     }
 
     case SetArgument:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op SetArgument\n", m_jit.getgencount());
         // This is a no-op; it just marks the fact that the argument is being used.
         // But it may be profitable to use this as a hook to run speculation checks
         // on arguments, thereby allowing us to trivially eliminate such checks if
@@ -2068,51 +2143,62 @@
     }
         
     case DoubleAsInt32: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op DoubleAsInt32\n", m_jit.getgencount());
         compileDoubleAsInt32(node);
         break;
     }
 
     case ValueToInt32: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op ValueToInt32\n", m_jit.getgencount());
         compileValueToInt32(node);
         break;
     }
         
     case Int32ToDouble: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op Int32ToDouble\n", m_jit.getgencount());
         compileInt32ToDouble(node);
         break;
     }
         
     case ValueAdd:
     case ArithAdd:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op ValueAdd/ArithAdd\n", m_jit.getgencount());
         compileAdd(node);
         break;
 
     case MakeRope:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op MakeRope\n", m_jit.getgencount());
         compileMakeRope(node);
         break;
 
     case ArithSub:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op ArithSub\n", m_jit.getgencount());
         compileArithSub(node);
         break;
 
     case ArithNegate:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op ArithNegate\n", m_jit.getgencount());
         compileArithNegate(node);
         break;
 
     case ArithMul:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op ArithMul\n", m_jit.getgencount());
         compileArithMul(node);
         break;
 
     case ArithIMul:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op ArithIMul\n", m_jit.getgencount());
         compileArithIMul(node);
         break;
 
     case ArithDiv: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op ArithDiv\n", m_jit.getgencount());
         compileArithDiv(node);
         break;
     }
 
     case ArithMod: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op ArithMod\n", m_jit.getgencount());
         compileArithMod(node);
         break;
     }
@@ -2270,22 +2356,26 @@
         break;
 
     case CompareGreater:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op CompareGreater\n", m_jit.getgencount());
         if (compare(node, JITCompiler::GreaterThan, JITCompiler::DoubleGreaterThan, operationCompareGreater))
             return;
         break;
 
     case CompareGreaterEq:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op CompareGreaterEq\n", m_jit.getgencount());
         if (compare(node, JITCompiler::GreaterThanOrEqual, JITCompiler::DoubleGreaterThanOrEqual, operationCompareGreaterEq))
             return;
         break;
         
     case CompareEqConstant:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op CompareEqConstant\n", m_jit.getgencount());
         ASSERT(isNullConstant(node->child2().node()));
         if (nonSpeculativeCompareNull(node, node->child1()))
             return;
         break;
 
     case CompareEq:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op CompareEq\n", m_jit.getgencount());
         if (compare(node, JITCompiler::Equal, JITCompiler::DoubleEqual, operationCompareEq))
             return;
         break;
@@ -2301,6 +2391,7 @@
         break;
 
     case StringCharCodeAt: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op StringCharCodeAt\n", m_jit.getgencount());
         compileGetCharCodeAt(node);
         break;
     }
@@ -3040,6 +3131,8 @@
         break;
 
     case Return: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op Return\n", m_jit.getgencount());
+
         ASSERT(GPRInfo::callFrameRegister != GPRInfo::regT2);
         ASSERT(GPRInfo::regT1 != GPRInfo::returnValueGPR);
         ASSERT(GPRInfo::returnValueGPR != GPRInfo::callFrameRegister);
@@ -3061,6 +3154,8 @@
             }
         }
 
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op Return: r3 = 0x%08x, r4 = 0x%08x\n", m_jit.getgencount(), PPCRegisters::r3, PPCRegisters::r4);
+
         // Grab the return address.
         m_jit.emitGetReturnPCFromCallFrameHeaderPtr(GPRInfo::regT2);
         // Restore our caller's "r".
@@ -3583,6 +3678,7 @@
     }
 
     case GetCallee: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetCallee\n", m_jit.getgencount());
         GPRTemporary result(this);
         m_jit.loadPtr(JITCompiler::payloadFor(JSStack::Callee), result.gpr());
         cellResult(result.gpr(), node);
@@ -3678,6 +3774,7 @@
     }
         
     case GetById: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetById\n", m_jit.getgencount());
         ASSERT(node->prediction());
         
         switch (node->child1().useKind()) {
@@ -3726,6 +3823,7 @@
     }
 
     case GetByIdFlush: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetByIdFlush\n", m_jit.getgencount());
         if (!node->prediction()) {
             terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
             break;
@@ -3733,6 +3831,7 @@
         
         switch (node->child1().useKind()) {
         case CellUse: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetByIdFlush: CellUse\n", m_jit.getgencount());
             SpeculateCellOperand base(this, node->child1());
             
             GPRReg baseGPR = base.gpr();
@@ -3746,13 +3845,16 @@
             
             flushRegisters();
             
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetByIdFlush: base tag xxx payload 0x%08x\n", m_jit.getgencount(), baseGPR);
             cachedGetById(node->codeOrigin, InvalidGPRReg, baseGPR, resultTagGPR, resultPayloadGPR, node->identifierNumber(), JITCompiler::Jump(), DontSpill);
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetByIdFlush: cachedGetById returned tag 0x%08x payload 0x%08x\n", m_jit.getgencount(), resultTagGPR, resultPayloadGPR);
             
             jsValueResult(resultTagGPR, resultPayloadGPR, node, UseChildrenCalledExplicitly);
             break;
         }
         
         case UntypedUse: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetByIdFlush: UntypedUse\n", m_jit.getgencount());
             JSValueOperand base(this, node->child1());
             GPRReg baseTagGPR = base.tagGPR();
             GPRReg basePayloadGPR = base.payloadGPR();
@@ -3768,7 +3870,9 @@
         
             JITCompiler::Jump notCell = m_jit.branch32(JITCompiler::NotEqual, baseTagGPR, TrustedImm32(JSValue::CellTag));
         
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetByIdFlush: base tag 0x%08x payload 0x%08x\n", m_jit.getgencount(), baseTagGPR, basePayloadGPR);
             cachedGetById(node->codeOrigin, baseTagGPR, basePayloadGPR, resultTagGPR, resultPayloadGPR, node->identifierNumber(), notCell, DontSpill);
+            m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op GetByIdFlush: cachedGetById returned tag 0x%08x payload 0x%08x\n", m_jit.getgencount(), resultTagGPR, resultPayloadGPR);
         
             jsValueResult(resultTagGPR, resultPayloadGPR, node, UseChildrenCalledExplicitly);
             break;
@@ -3786,8 +3890,11 @@
         break;
         
     case CheckFunction: {
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op CheckFunction\n", m_jit.getgencount());
         SpeculateCellOperand function(this, node->child1());
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op CheckFunction: Calling speculationCheck()\n", m_jit.getgencount());
         speculationCheck(BadFunction, JSValueSource::unboxedCell(function.gpr()), node->child1(), m_jit.branchWeakPtr(JITCompiler::NotEqual, function.gpr(), node->function()));
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op CheckFunction: speculationCheck() done\n", m_jit.getgencount());
         noResult(node);
         break;
     }
@@ -4688,6 +4795,7 @@
         break;
 
     case Phantom:
+        m_jit.dprint("JIT@% 3d: " __FILE__ ": DFG op Phantom\n", m_jit.getgencount());
         DFG_NODE_DO_TO_CHILDREN(m_jit.graph(), node, speculate);
         noResult(node);
         break;
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp	2018-07-15 07:12:08.667077618 +0000
@@ -179,6 +179,7 @@
     // Step 3: Compute value recoveries!
     valueRecoveries = Operands<ValueRecovery>(codeBlock->numParameters(), numVariables);
     for (unsigned i = 0; i < operandSources.size(); ++i) {
+        foddprintf("%s:%d/%s(): Processing operandSources[%d]\n", __FILE__, __LINE__, __func__, i);
         ValueSource& source = operandSources[i];
         if (source.isTriviallyRecoverable()) {
             valueRecoveries[i] = source.valueRecovery();
@@ -267,6 +268,7 @@
             }
 #if USE(JSVALUE32_64)
             if (info.format & DataFormatJS) {
+                foddprintf("%s:%d/%s(): index %d: tagGPR %d, payloadGPR %d\n", __FILE__, __LINE__, __func__, i, (int)info.u.pair.tagGPR, info.u.pair.payloadGPR);
                 valueRecoveries[i] = ValueRecovery::inPair(info.u.pair.tagGPR, info.u.pair.payloadGPR);
                 continue;
             }
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/ftl/FTLOSRExitCompiler.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/ftl/FTLOSRExitCompiler.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/ftl/FTLOSRExitCompiler.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/ftl/FTLOSRExitCompiler.cpp	2018-06-26 09:53:32.086649458 +0000
@@ -160,7 +160,9 @@
     jit.move(MacroAssembler::framePointerRegister, MacroAssembler::stackPointerRegister);
     jit.pop(GPRInfo::nonArgGPR0);
     jit.pop(GPRInfo::nonArgGPR0);
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: Old Call Frame is 0x%08x\n", getgencount(), __LINE__, PPCRegisters::r14);
     jit.move(GPRInfo::regT4, GPRInfo::callFrameRegister);
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: New Call Frame is 0x%08x\n", getgencount(), __LINE__, PPCRegisters::r14);
     
     handleExitCounts(jit, exit);
     reifyInlinedCallFrames(jit, exit);
Binary files clean/WebKit.161078/Source/JavaScriptCore/inspector/scripts/CodeGeneratorInspectorStrings.pyc and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/inspector/scripts/CodeGeneratorInspectorStrings.pyc differ
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/interpreter/CallFrame.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/interpreter/CallFrame.h
--- clean/WebKit.161078/Source/JavaScriptCore/interpreter/CallFrame.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/interpreter/CallFrame.h	2018-07-15 17:58:25.132263825 +0000
@@ -41,6 +41,8 @@
     // Passed as the first argument to most functions.
     class ExecState : private Register {
     public:
+        EncodedJSValue calleeAsEncodedJSValue() const { return this[JSStack::Callee].encodedJSValue(); }
+        void *calleeAsAddress() const { return (void *)&this[JSStack::Callee]; }
         JSValue calleeAsValue() const { return this[JSStack::Callee].jsValue(); }
         JSObject* callee() const { return this[JSStack::Callee].function(); }
         CodeBlock* codeBlock() const { return this[JSStack::CodeBlock].Register::codeBlock(); }
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/interpreter/Interpreter.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/interpreter/Interpreter.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/interpreter/Interpreter.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/interpreter/Interpreter.cpp	2018-06-14 05:57:54.436859969 +0000
@@ -81,8 +81,13 @@
 
 #if ENABLE(JIT)
 #include "JIT.h"
+#else
+#error 1
 #endif
 
+
+#include "JITStubsPPC.h"
+
 #define WTF_USE_GCC_COMPUTED_GOTO_WORKAROUND (ENABLE(LLINT) && !defined(__llvm__))
 
 using namespace std;
@@ -759,6 +764,8 @@
 JSValue Interpreter::execute(ProgramExecutable* program, CallFrame* callFrame, JSObject* thisObj)
 {
     SamplingScope samplingScope(this);
+
+    EXECUTEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     
     JSScope* scope = callFrame->scope();
     VM& vm = *scope->vm();
@@ -904,6 +911,7 @@
         SamplingTool::CallRecord callRecord(m_sampler.get());
         Watchdog::Scope watchdogScope(vm.watchdog);
 
+        EXECUTEDPRINTF("%s:%d/%s(): JIT'ing\n", __FILE__, __LINE__, __func__);
         result = program->generatedJITCode()->execute(&vm, &protoCallFrame, m_stack.getTopOfStack());
     }
 
@@ -915,6 +923,7 @@
 
 JSValue Interpreter::executeCall(CallFrame* callFrame, JSObject* function, CallType callType, const CallData& callData, JSValue thisValue, const ArgList& args)
 {
+    EXECUTEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = callFrame->vm();
     ASSERT(!callFrame->hadException());
     ASSERT(!vm.isCollectorBusy());
@@ -967,10 +976,16 @@
         Watchdog::Scope watchdogScope(vm.watchdog);
 
         // Execute the code:
-        if (isJSCall)
+        if (isJSCall) {
+            EXECUTEDPRINTF("%s:%d/%s(): Calling Javascript function\n", __FILE__, __LINE__, __func__);
             result = callData.js.functionExecutable->generatedJITCodeForCall()->execute(&vm, &protoCallFrame, m_stack.getTopOfStack());
-        else
+            EXECUTEDPRINTF("%s:%d/%s(): Result is %016llx\n", __FILE__, __LINE__, __func__, JSValue::encode(result));
+        } else
+        {
+            EXECUTEDPRINTF("%s:%d/%s(): Calling 0x%08x\n", __FILE__, __LINE__, __func__, callData.native.function);
             result = JSValue::decode(callToNativeFunction(reinterpret_cast<void*>(callData.native.function), &vm.topCallFrame, &protoCallFrame, m_stack.getTopOfStack()));
+            EXECUTEDPRINTF("%s:%d/%s(): Result is %016llx\n", __FILE__, __LINE__, __func__, JSValue::encode(result));
+        }
     }
 
     if (LegacyProfiler* profiler = vm.enabledProfiler())
@@ -981,6 +996,7 @@
 
 JSObject* Interpreter::executeConstruct(CallFrame* callFrame, JSObject* constructor, ConstructType constructType, const ConstructData& constructData, const ArgList& args)
 {
+    EXECUTEDPRINTF("%s:%d/%s(): Called from 0x%08x\n", __FILE__, __LINE__, __func__, __builtin_return_address(0));
     VM& vm = callFrame->vm();
     ASSERT(!callFrame->hadException());
     ASSERT(!vm.isCollectorBusy());
@@ -1036,9 +1052,15 @@
 
         // Execute the code.
         if (isJSConstruct)
+        {
+            EXECUTEDPRINTF("%s:%d/%s(): Calling Javascript construct function\n", __FILE__, __LINE__, __func__);
             result = constructData.js.functionExecutable->generatedJITCodeForConstruct()->execute(&vm, &protoCallFrame, m_stack.getTopOfStack());
+            EXECUTEDPRINTF("%s:%d/%s(): Result is %016llx\n", __FILE__, __LINE__, __func__, JSValue::encode(result));
+        }
         else {
+            EXECUTEDPRINTF("%s:%d/%s(): Calling 0x%08x\n", __FILE__, __LINE__, __func__, constructData.native.function);
             result = JSValue::decode(callToNativeFunction(reinterpret_cast<void*>(constructData.native.function), &vm.topCallFrame, &protoCallFrame, m_stack.getTopOfStack()));
+            EXECUTEDPRINTF("%s:%d/%s(): Result is %016llx\n", __FILE__, __LINE__, __func__, JSValue::encode(result));
 
             if (!callFrame->hadException())
                 RELEASE_ASSERT(result.isObject());
@@ -1194,6 +1216,7 @@
         SamplingTool::CallRecord callRecord(m_sampler.get());
         Watchdog::Scope watchdogScope(vm.watchdog);
 
+        EXECUTEDPRINTF("%s:%d/%s(): JIT'ing\n", __FILE__, __LINE__, __func__);
         result = eval->generatedJITCode()->execute(&vm, &protoCallFrame, m_stack.getTopOfStack());
     }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/interpreter/JSStackInlines.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/interpreter/JSStackInlines.h
--- clean/WebKit.161078/Source/JavaScriptCore/interpreter/JSStackInlines.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/interpreter/JSStackInlines.h	2018-06-12 14:28:02.337668727 +0000
@@ -177,6 +177,7 @@
 {
     if (newEnd >= m_end)
         return true;
+
     return growSlowCase(newEnd);
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/interpreter/Register.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/interpreter/Register.h
--- clean/WebKit.161078/Source/JavaScriptCore/interpreter/Register.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/interpreter/Register.h	2018-06-12 14:28:02.337668727 +0000
@@ -87,8 +87,17 @@
     private:
         union {
             EncodedJSValue value;
-            CallFrame* callFrame;
-            CodeBlock* codeBlock;
+	    struct
+	    {
+#if USE(JSVALUE32_64) && CPU(BIG_ENDIAN)
+		void *dummy;
+#endif
+		union
+		{
+                    CallFrame* callFrame;
+                    CodeBlock* codeBlock;
+		} u;
+	    } ptr;
             EncodedValueDescriptor encodedValue;
             double number;
             int64_t integer;
@@ -127,13 +136,13 @@
 
     ALWAYS_INLINE Register& Register::operator=(CallFrame* callFrame)
     {
-        u.callFrame = callFrame;
+        u.ptr.u.callFrame = callFrame;
         return *this;
     }
 
     ALWAYS_INLINE Register& Register::operator=(CodeBlock* codeBlock)
     {
-        u.codeBlock = codeBlock;
+        u.ptr.u.codeBlock = codeBlock;
         return *this;
     }
 
@@ -144,12 +153,12 @@
 
     ALWAYS_INLINE CallFrame* Register::callFrame() const
     {
-        return u.callFrame;
+        return u.ptr.u.callFrame;
     }
     
     ALWAYS_INLINE CodeBlock* Register::codeBlock() const
     {
-        return u.codeBlock;
+        return u.ptr.u.codeBlock;
     }
 
     ALWAYS_INLINE int32_t Register::unboxedInt32() const
Binary files clean/WebKit.161078/Source/JavaScriptCore/jit/.JITCall32_64.cpp.swp and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/.JITCall32_64.cpp.swp differ
Binary files clean/WebKit.161078/Source/JavaScriptCore/jit/.Repatch.cpp.swp and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/.Repatch.cpp.swp differ
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/AssemblyHelpers.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/AssemblyHelpers.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/AssemblyHelpers.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/AssemblyHelpers.h	2018-06-26 12:37:43.674396359 +0000
@@ -127,6 +127,41 @@
     }
 #endif
 
+#if CPU(PPC)
+    ALWAYS_INLINE void preserveReturnAddressAfterCall(RegisterID reg)
+    {
+        m_assembler.mflr(reg);
+    }
+
+    ALWAYS_INLINE void restoreReturnAddressBeforeReturn(RegisterID reg)
+    {
+        m_assembler.mtlr(reg);
+    }
+
+    ALWAYS_INLINE void restoreReturnAddressBeforeReturn(Address address)
+    {
+        COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+        load32(address, PPCRegisters::r0);
+        m_assembler.mtlr(PPCRegisters::r0);
+    }
+#endif
+
+#if 1
+#warning This is a test
+    void emitGetFromCallFrameHeaderPtr(JSStack::CallFrameHeaderEntry entry, GPRReg to)
+    {
+        loadPtr(Address(GPRInfo::callFrameRegister, entry * sizeof(Register) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)), to);
+    }
+    void emitPutToCallFrameHeader(GPRReg from, JSStack::CallFrameHeaderEntry entry)
+    {
+        storePtr(from, Address(GPRInfo::callFrameRegister, entry * sizeof(Register) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)));
+    }
+
+    void emitPutImmediateToCallFrameHeader(void* value, JSStack::CallFrameHeaderEntry entry)
+    {
+        storePtr(TrustedImmPtr(value), Address(GPRInfo::callFrameRegister, entry * sizeof(Register) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)));
+    }
+#else
     void emitGetFromCallFrameHeaderPtr(JSStack::CallFrameHeaderEntry entry, GPRReg to)
     {
         loadPtr(Address(GPRInfo::callFrameRegister, entry * sizeof(Register)), to);
@@ -140,6 +175,7 @@
     {
         storePtr(TrustedImmPtr(value), Address(GPRInfo::callFrameRegister, entry * sizeof(Register)));
     }
+#endif
 
     void emitGetCallerFrameFromCallFrameHeaderPtr(RegisterID to)
     {
@@ -257,7 +293,7 @@
         move(TrustedImmPtr(scratchBuffer->activeLengthPtr()), GPRInfo::regT0);
         storePtr(TrustedImmPtr(scratchSize), GPRInfo::regT0);
 
-#if CPU(X86_64) || CPU(ARM) || CPU(ARM64) || CPU(MIPS) || CPU(SH4)
+#if CPU(X86_64) || CPU(ARM) || CPU(ARM64) || CPU(MIPS) || CPU(SH4) || CPU(PPC)
         move(TrustedImmPtr(buffer), GPRInfo::argumentGPR2);
         move(TrustedImmPtr(argument), GPRInfo::argumentGPR1);
         move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/CCallHelpers.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/CCallHelpers.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/CCallHelpers.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/CCallHelpers.h	2018-07-17 13:54:14.811095484 +0000
@@ -672,6 +672,198 @@
             swap(destB, destC);
     }
 
+    template<GPRReg destA, GPRReg destB, GPRReg destC, GPRReg destD>
+    void setupFourStubArgsGPR(GPRReg srcA, GPRReg srcB, GPRReg srcC, GPRReg srcD)
+    {
+        // If neither of srcB/srcC are in our way, then we can move srcA into place.
+        // Then we can use setupTwoStubArgs to fix srcB/srcC.
+        if (srcB != destA && srcC != destA && srcD != destA) {
+            move(srcA, destA);
+            setupThreeStubArgsGPR<destB, destC, destD>(srcB, srcC, srcD);
+            return;
+        }
+        
+        // If neither of srcA/srcC are in our way, then we can move srcB into place.
+        // Then we can use setupTwoStubArgs to fix srcA/srcC.
+        if (srcA != destB && srcC != destB && srcD != destB) {
+            move(srcB, destB);
+            setupThreeStubArgsGPR<destA, destC, destD>(srcA, srcC, srcD);
+            return;
+        }
+        
+        // If neither of srcA/srcB are in our way, then we can move srcC into place.
+        // Then we can use setupTwoStubArgs to fix srcA/srcB.
+        if (srcA != destC && srcB != destC && srcD != destC) {
+            move(srcC, destC);
+            setupThreeStubArgsGPR<destA, destB, destD>(srcA, srcB, srcD);
+            return;
+        }
+
+        if (srcA != destD && srcB != destD && srcC != destD) {
+            move(srcD, destD);
+            setupThreeStubArgsGPR<destA, destB, destC>(srcA, srcB, srcC);
+            return;
+        }
+
+        // If we get here, we haven't been able to move any of srcA/srcB/srcC.
+        // Since all three are blocked, then all three must already be in the argument register.
+        // But are they in the right ones?
+        
+        // First, ensure srcA is in place.
+        if (srcA != destA) {
+            swap(srcA, destA);
+            
+            // If srcA wasn't in argumentGPR1, one of srcB/srcC must be.
+            ASSERT(srcB == destA || srcC == destA || srcD == destA);
+            // If srcB was in argumentGPR1 it no longer is (due to the swap).
+            // Otherwise srcC must have been. Mark him as moved.
+            if (srcB == destA)
+                srcB = srcA;
+            else if (srcC == destA)
+                srcC = srcA;
+            else
+                srcD = srcA;
+        }
+
+        setupThreeStubArgsGPR<destB, destC, destD>(srcB, srcC, srcD);
+    }
+
+    template<GPRReg destA, GPRReg destB, GPRReg destC, GPRReg destD, GPRReg destE>
+    void setupFiveStubArgsGPR(GPRReg srcA, GPRReg srcB, GPRReg srcC, GPRReg srcD, GPRReg srcE)
+    {
+        // If neither of srcB/srcC are in our way, then we can move srcA into place.
+        // Then we can use setupTwoStubArgs to fix srcB/srcC.
+        if (srcB != destA && srcC != destA && srcD != destA && srcE != destA) {
+            move(srcA, destA);
+            setupFourStubArgsGPR<destB, destC, destD, destE>(srcB, srcC, srcD, srcE);
+            return;
+        }
+        
+        // If neither of srcA/srcC are in our way, then we can move srcB into place.
+        // Then we can use setupTwoStubArgs to fix srcA/srcC.
+        if (srcA != destB && srcC != destB && srcD != destB && srcE != destB) {
+            move(srcB, destB);
+            setupFourStubArgsGPR<destA, destC, destD, destE>(srcA, srcC, srcD, srcE);
+            return;
+        }
+        
+        // If neither of srcA/srcB are in our way, then we can move srcC into place.
+        // Then we can use setupTwoStubArgs to fix srcA/srcB.
+        if (srcA != destC && srcB != destC && srcD != destC && srcE != destC) {
+            move(srcC, destC);
+            setupFourStubArgsGPR<destA, destB, destD, destE>(srcA, srcB, srcD, srcE);
+            return;
+        }
+
+        if (srcA != destD && srcB != destD && srcC != destD && srcE != destD) {
+            move(srcD, destD);
+            setupFourStubArgsGPR<destA, destB, destC, destE>(srcA, srcB, srcC, srcE);
+            return;
+        }
+
+        if (srcA != destE && srcB != destE && srcC != destE && srcD != destE) {
+            move(srcE, destE);
+            setupFourStubArgsGPR<destA, destB, destC, destD>(srcA, srcB, srcC, srcD);
+            return;
+        }
+
+        // If we get here, we haven't been able to move any of srcA/srcB/srcC.
+        // Since all three are blocked, then all three must already be in the argument register.
+        // But are they in the right ones?
+        
+        // First, ensure srcA is in place.
+        if (srcA != destA) {
+            swap(srcA, destA);
+            
+            // If srcA wasn't in argumentGPR1, one of srcB/srcC must be.
+            ASSERT(srcB == destA || srcC == destA || srcD == destA || srcE == destA || srcF == destA);
+            // If srcB was in argumentGPR1 it no longer is (due to the swap).
+            // Otherwise srcC must have been. Mark him as moved.
+            if (srcB == destA)
+                srcB = srcA;
+            else if (srcC == destA)
+                srcC = srcA;
+            else if (srcD == destA)
+                srcE = srcA;
+            else
+                srcE = srcA;
+        }
+
+        setupFourStubArgsGPR<destB, destC, destD, destE>(srcB, srcC, srcD, srcE);
+    }
+
+    template<GPRReg destA, GPRReg destB, GPRReg destC, GPRReg destD, GPRReg destE, GPRReg destF>
+    void setupSixStubArgsGPR(GPRReg srcA, GPRReg srcB, GPRReg srcC, GPRReg srcD, GPRReg srcE, GPRReg srcF)
+    {
+        // If neither of srcB/srcC are in our way, then we can move srcA into place.
+        // Then we can use setupTwoStubArgs to fix srcB/srcC.
+        if (srcB != destA && srcC != destA && srcD != destA && srcE != destA && srcF != destA) {
+            move(srcA, destA);
+            setupFiveStubArgsGPR<destB, destC, destD, destE, destF>(srcB, srcC, srcD, srcE, srcF);
+            return;
+        }
+        
+        // If neither of srcA/srcC are in our way, then we can move srcB into place.
+        // Then we can use setupTwoStubArgs to fix srcA/srcC.
+        if (srcA != destB && srcC != destB && srcD != destB && srcE != destB && srcF != destB) {
+            move(srcB, destB);
+            setupFiveStubArgsGPR<destA, destC, destD, destE, destF>(srcA, srcC, srcD, srcE, srcF);
+            return;
+        }
+        
+        // If neither of srcA/srcB are in our way, then we can move srcC into place.
+        // Then we can use setupTwoStubArgs to fix srcA/srcB.
+        if (srcA != destC && srcB != destC && srcD != destC && srcE != destC && srcF != destC) {
+            move(srcC, destC);
+            setupFiveStubArgsGPR<destA, destB, destD, destE, destF>(srcA, srcB, srcD, srcE, srcF);
+            return;
+        }
+
+        if (srcA != destD && srcB != destD && srcC != destD && srcE != destD && srcF != destD) {
+            move(srcD, destD);
+            setupFiveStubArgsGPR<destA, destB, destC, destE, destF>(srcA, srcB, srcC, srcE, srcF);
+            return;
+        }
+
+        if (srcA != destE && srcB != destE && srcC != destE && srcD != destE && srcF != destE) {
+            move(srcE, destE);
+            setupFiveStubArgsGPR<destA, destB, destC, destD, destF>(srcA, srcB, srcC, srcD, srcF);
+            return;
+        }
+
+        if (srcA != destF && srcB != destF && srcC != destF && srcD != destF && srcE != destF) {
+            move(srcF, destF);
+            setupFiveStubArgsGPR<destA, destB, destC, destD, destE>(srcA, srcB, srcC, srcD, srcE);
+            return;
+        }
+
+        // If we get here, we haven't been able to move any of srcA/srcB/srcC.
+        // Since all three are blocked, then all three must already be in the argument register.
+        // But are they in the right ones?
+        
+        // First, ensure srcA is in place.
+        if (srcA != destA) {
+            swap(srcA, destA);
+            
+            // If srcA wasn't in argumentGPR1, one of srcB/srcC must be.
+            ASSERT(srcB == destA || srcC == destA || srcD == destA || srcE == destA || srcF == destA);
+            // If srcB was in argumentGPR1 it no longer is (due to the swap).
+            // Otherwise srcC must have been. Mark him as moved.
+            if (srcB == destA)
+                srcB = srcA;
+            else if (srcC == destA)
+                srcC = srcA;
+            else if (srcD == destA)
+                srcE = srcA;
+            else if (srcE == destA)
+                srcE = srcA;
+            else
+                srcF = srcA;
+        }
+
+        setupFiveStubArgsGPR<destB, destC, destD, destE, destF>(srcB, srcC, srcD, srcE, srcF);
+    }
+
 #if CPU(X86_64) || CPU(ARM64)
     template<FPRReg destA, FPRReg destB>
     void setupTwoStubArgsFPR(FPRReg srcA, FPRReg srcB)
@@ -730,7 +922,8 @@
         setupThreeStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR2, GPRInfo::argumentGPR3>(arg1, arg2, arg3);
     }
 
-#if CPU(MIPS) || (OS(WINDOWS) && CPU(X86_64))
+#if CPU(PPC)
+#elif CPU(MIPS) || (OS(WINDOWS) && CPU(X86_64))
 #define POKE_ARGUMENT_OFFSET 4
 #else
 #define POKE_ARGUMENT_OFFSET 0
@@ -930,6 +1123,55 @@
         setupStubArguments(arg1, arg2);
         move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
     }
+#elif CPU(PPC)
+    ALWAYS_INLINE void setupArguments(FPRReg arg1)
+    {
+        moveDouble(arg1, FPRInfo::argumentFPR0);
+    }
+
+    ALWAYS_INLINE void setupArguments(FPRReg arg1, FPRReg arg2)
+    {
+        if (arg2 != FPRInfo::argumentFPR0) {
+            moveDouble(arg1, FPRInfo::argumentFPR0);
+            moveDouble(arg2, FPRInfo::argumentFPR1);
+        } else if (arg1 != FPRInfo::argumentFPR1) {
+            moveDouble(arg2, FPRInfo::argumentFPR1);
+            moveDouble(arg1, FPRInfo::argumentFPR0);
+        } else {
+            // Swap arg1, arg2.
+            moveDouble(FPRInfo::argumentFPR0, PPCRegisters::f7);
+            moveDouble(FPRInfo::argumentFPR1, FPRInfo::argumentFPR0);
+            moveDouble(PPCRegisters::f7, FPRInfo::argumentFPR1);
+        }
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(FPRReg arg1, GPRReg arg2)
+    {
+        moveDouble(arg1, FPRInfo::argumentFPR0);
+        move(arg2, GPRInfo::argumentGPR1);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, FPRReg arg3)
+    {
+        moveDouble(arg3, FPRInfo::argumentFPR0);
+        setupStubArguments(arg1, arg2);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32, FPRReg arg2, GPRReg arg3)
+    {
+        moveDouble(arg2, FPRInfo::argumentFPR0);
+        move(arg3, GPRInfo::argumentGPR1);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, TrustedImm32, FPRReg arg4)
+    {
+        moveDouble(arg4, FPRInfo::argumentFPR0);
+        setupStubArguments(arg1, arg2);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
 #else
 #error "JIT not supported on this platform."
 #endif
@@ -969,6 +1211,7 @@
         move(arg4, GPRInfo::argumentGPR3);
     }
     
+#if 0
     ALWAYS_INLINE void setupArguments(GPRReg arg1, GPRReg arg2, TrustedImmPtr arg3, TrustedImm32 arg4, GPRReg arg5, GPRReg arg6)
     {
         poke(arg6, POKE_ARGUMENT_OFFSET + 1);
@@ -977,6 +1220,7 @@
         move(arg3, GPRInfo::argumentGPR2);
         move(arg4, GPRInfo::argumentGPR3);
     }
+#endif
 
     ALWAYS_INLINE void setupArguments(TrustedImmPtr arg1)
     {
@@ -1155,6 +1399,14 @@
         move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
     }
 
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, TrustedImm32 arg2, GPRReg arg3, GPRReg arg4)
+    {
+        setupTwoStubArgsGPR<GPRInfo::argumentGPR3, GPRInfo::argumentGPR4>(arg3, arg4);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg2, GPRInfo::argumentGPR2);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
     ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, TrustedImm32 arg2, GPRReg arg3)
     {
         move(arg3, GPRInfo::argumentGPR3);
@@ -1270,6 +1522,7 @@
 
     ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImmPtr arg1, GPRReg arg2, GPRReg arg3, TrustedImmPtr arg4)
     {
+        COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         poke(arg4, POKE_ARGUMENT_OFFSET);
         setupArgumentsWithExecState(arg1, arg2, arg3);
     }
@@ -1517,11 +1770,38 @@
         setupThreeStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR3, GPRInfo::argumentGPR4>(arg1, arg3, arg4);
     }
 
-    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, TrustedImmPtr arg2, TrustedImm32 arg3, GPRReg arg4)
+    void setupStubArguments1245(GPRReg arg1, GPRReg arg2, GPRReg arg4, GPRReg arg5)
     {
-        setupTwoStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR4>(arg1, arg4);
-        move(arg2, GPRInfo::argumentGPR2);
+        setupFourStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR2, GPRInfo::argumentGPR4, GPRInfo::argumentGPR5>(arg1, arg2, arg4, arg5);
+    }
+
+    /* With exec state */
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, GPRReg arg3, GPRReg arg4)
+    {
+        setupFourStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR4>(arg1, arg2, arg3, arg4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, GPRReg arg3, TrustedImm32 arg4)
+    {
+        setupThreeStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR2, GPRInfo::argumentGPR3>(arg1, arg2, arg3);
+        move(arg4, GPRInfo::argumentGPR4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, GPRReg arg3, TrustedImmPtr arg4)
+    {
+        setupThreeStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR2, GPRInfo::argumentGPR3>(arg1, arg2, arg3);
+        move(arg4, GPRInfo::argumentGPR4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, TrustedImm32 arg3, TrustedImm32 arg4)
+    {
+        setupTwoStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR2>(arg1, arg2);
         move(arg3, GPRInfo::argumentGPR3);
+        move(arg4, GPRInfo::argumentGPR4);
         move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
     }
 
@@ -1532,6 +1812,53 @@
         move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
     }
 
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, TrustedImmPtr arg2, TrustedImm32 arg3, GPRReg arg4)
+    {
+        setupTwoStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR4>(arg1, arg4);
+        move(arg2, GPRInfo::argumentGPR2);
+        move(arg3, GPRInfo::argumentGPR3);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, GPRReg arg2, GPRReg arg3, GPRReg arg4)
+    {
+        setupThreeStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR4>(arg2, arg3, arg4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+        move(arg1, GPRInfo::argumentGPR1);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, GPRReg arg2, GPRReg arg3, TrustedImm32 arg4)
+    {
+        setupTwoStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3>(arg2, arg3);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg4, GPRInfo::argumentGPR4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, GPRReg arg2, GPRReg arg3, TrustedImmPtr arg4)
+    {
+        setupTwoStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3>(arg2, arg3);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg4, GPRInfo::argumentGPR4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, GPRReg arg2, TrustedImm32 arg3, GPRReg arg4)
+    {
+        setupTwoStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR4>(arg2, arg4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg3, GPRInfo::argumentGPR3);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImmPtr arg1, GPRReg arg2, GPRReg arg3, TrustedImm32 arg4)
+    {
+        setupTwoStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3>(arg2, arg3);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg4, GPRInfo::argumentGPR4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
     ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImmPtr arg1, GPRReg arg2, GPRReg arg3, TrustedImmPtr arg4)
     {
         setupTwoStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3>(arg2, arg3);
@@ -1540,6 +1867,32 @@
         move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
     }
 
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImmPtr arg1, GPRReg arg2, TrustedImm32 arg3, TrustedImmPtr arg4)
+    {
+        move(arg2, GPRInfo::argumentGPR2);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg3, GPRInfo::argumentGPR3);
+        move(arg4, GPRInfo::argumentGPR4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImmPtr arg1, TrustedImm32 arg2, GPRReg arg3, TrustedImmPtr arg4)
+    {
+        move(arg3, GPRInfo::argumentGPR3);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg2, GPRInfo::argumentGPR2);
+        move(arg4, GPRInfo::argumentGPR4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    /* Without exec state */
+    ALWAYS_INLINE void setupArguments(GPRReg arg1, GPRReg arg2, TrustedImmPtr arg3, TrustedImm32 arg4, GPRReg arg5)
+    {
+        setupThreeStubArgsGPR<GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR4>(arg1, arg2, arg5);
+        move(arg3, GPRInfo::argumentGPR2);
+        move(arg4, GPRInfo::argumentGPR3);
+    }
+
     ALWAYS_INLINE void setupArguments(GPRReg arg1, TrustedImmPtr arg2, GPRReg arg3, GPRReg arg4, TrustedImmPtr arg5)
     {
         setupThreeStubArgsGPR<GPRInfo::argumentGPR0, GPRInfo::argumentGPR2, GPRInfo::argumentGPR3>(arg1, arg3, arg4);
@@ -1547,12 +1900,140 @@
         move(arg5, GPRInfo::argumentGPR4);
     }
 
-    ALWAYS_INLINE void setupArguments(GPRReg arg1, GPRReg arg2, TrustedImmPtr arg3, TrustedImm32 arg4, GPRReg arg5)
+#endif
+
+#if NUMBER_OF_ARGUMENT_REGISTERS >= 6
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, GPRReg arg3, GPRReg arg4, GPRReg arg5)
     {
-        setupThreeStubArgsGPR<GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR4>(arg1, arg2, arg5);
+        setupFiveStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR4, GPRInfo::argumentGPR5>(arg1, arg2, arg3, arg4, arg5);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, TrustedImm32 arg3, GPRReg arg4, GPRReg arg5)
+    {
+        setupStubArguments1245(arg1, arg2, arg4, arg5);
+        move(arg3, GPRInfo::argumentGPR3);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, TrustedImm32 arg3, GPRReg arg4, TrustedImm32 arg5)
+    {
+        setupThreeStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR2, GPRInfo::argumentGPR4>(arg1, arg2, arg4);
+        move(arg3, GPRInfo::argumentGPR3);
+        move(arg5, GPRInfo::argumentGPR5);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, TrustedImm32 arg3, TrustedImm32 arg4, GPRReg arg5)
+    {
+        setupThreeStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR2, GPRInfo::argumentGPR5>(arg1, arg2, arg5);
+        move(arg3, GPRInfo::argumentGPR3);
+        move(arg4, GPRInfo::argumentGPR4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, TrustedImmPtr arg3, GPRReg arg4, GPRReg arg5)
+    {
+        setupStubArguments1245(arg1, arg2, arg4, arg5);
+        move(arg3, GPRInfo::argumentGPR3);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArguments(GPRReg arg1, GPRReg arg2, TrustedImmPtr arg3, TrustedImm32 arg4, GPRReg arg5, GPRReg arg6)
+    {
+        setupFourStubArgsGPR<GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR4, GPRInfo::argumentGPR5>(arg1, arg2, arg5, arg6);
         move(arg3, GPRInfo::argumentGPR2);
         move(arg4, GPRInfo::argumentGPR3);
     }
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, GPRReg arg2, GPRReg arg3, GPRReg arg4, GPRReg arg5)
+    {
+        setupFourStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR4, GPRInfo::argumentGPR5>(arg2, arg3, arg4, arg5);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+        move(arg1, GPRInfo::argumentGPR1);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, GPRReg arg2, GPRReg arg3, GPRReg arg4, TrustedImmPtr arg5)
+    {
+        setupThreeStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR4>(arg2, arg3, arg4);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg5, GPRInfo::argumentGPR5);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, GPRReg arg2, GPRReg arg3, TrustedImm32 arg4, TrustedImm32 arg5)
+    {
+        setupTwoStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3>(arg2, arg3);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg4, GPRInfo::argumentGPR4);
+        move(arg5, GPRInfo::argumentGPR5);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, TrustedImm32 arg2, TrustedImm32 arg3, GPRReg arg4, GPRReg arg5)
+    {
+        setupTwoStubArgsGPR<GPRInfo::argumentGPR4, GPRInfo::argumentGPR5>(arg4, arg5);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg2, GPRInfo::argumentGPR2);
+        move(arg3, GPRInfo::argumentGPR3);
+    }
+
+#endif
+
+#if NUMBER_OF_ARGUMENT_REGISTERS >= 7
+    /* With exec state */
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(GPRReg arg1, GPRReg arg2, GPRReg arg3, GPRReg arg4, GPRReg arg5, GPRReg arg6)
+    {
+        setupSixStubArgsGPR<GPRInfo::argumentGPR1, GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR4, GPRInfo::argumentGPR5, GPRInfo::argumentGPR6>(arg1, arg2, arg3, arg4, arg5, arg6);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImmPtr arg1, GPRReg arg2, GPRReg arg3, GPRReg arg4, GPRReg arg5, TrustedImmPtr arg6)
+    {
+        setupFourStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR4, GPRInfo::argumentGPR5>(arg2, arg3, arg4, arg5);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg6, GPRInfo::argumentGPR6);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImmPtr arg1, GPRReg arg2, GPRReg arg3, GPRReg arg4, TrustedImm32 arg5, TrustedImmPtr arg6)
+    {
+        setupThreeStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR4>(arg2, arg3, arg4);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg5, GPRInfo::argumentGPR5);
+        move(arg6, GPRInfo::argumentGPR6);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImmPtr arg1, GPRReg arg2, GPRReg arg3, TrustedImm32 arg4, GPRReg arg5, TrustedImmPtr arg6)
+    {
+        setupThreeStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR5>(arg2, arg3, arg5);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg5, GPRInfo::argumentGPR4);
+        move(arg6, GPRInfo::argumentGPR6);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+    }
+#endif
+
+#if NUMBER_OF_ARGUMENT_REGISTERS >= 8
+    /* With exec state */
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, GPRReg arg2, GPRReg arg3, GPRReg arg4, GPRReg arg5, GPRReg arg6, GPRReg arg7)
+    {
+        setupSixStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR4, GPRInfo::argumentGPR5, GPRInfo::argumentGPR6, GPRInfo::argumentGPR7>(arg2, arg3, arg4, arg5, arg6, arg7);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+        move(arg1, GPRInfo::argumentGPR1);
+    }
+
+    ALWAYS_INLINE void setupArgumentsWithExecState(TrustedImm32 arg1, GPRReg arg2, GPRReg arg3, TrustedImm32 arg4, TrustedImm32 arg5, GPRReg arg6, GPRReg arg7)
+    {
+        setupFourStubArgsGPR<GPRInfo::argumentGPR2, GPRInfo::argumentGPR3, GPRInfo::argumentGPR6, GPRInfo::argumentGPR7>(arg2, arg3, arg6, arg7);
+        move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
+        move(arg1, GPRInfo::argumentGPR1);
+        move(arg4, GPRInfo::argumentGPR4);
+        move(arg5, GPRInfo::argumentGPR5);
+    }
 #endif
 
     void setupResults(GPRReg destA, GPRReg destB)
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/FPRInfo.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/FPRInfo.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/FPRInfo.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/FPRInfo.h	2018-06-28 06:28:42.952308622 +0000
@@ -395,6 +395,67 @@
 
 #endif // ENABLE(JIT)
 
+#if CPU(PPC)
+
+class FPRInfo {
+public:
+    typedef FPRReg RegisterType;
+    static const unsigned numberOfRegisters = 6;
+
+    // Temporary registers.
+    // f7 is use by the MacroAssembler as fpTempRegister.
+    static const FPRReg fpRegT0 = PPCRegisters::f0;
+    static const FPRReg fpRegT1 = PPCRegisters::f1;
+    static const FPRReg fpRegT2 = PPCRegisters::f2;
+    static const FPRReg fpRegT3 = PPCRegisters::f3;
+    static const FPRReg fpRegT4 = PPCRegisters::f4;
+    static const FPRReg fpRegT5 = PPCRegisters::f5;
+    static const FPRReg returnValueFPR = PPCRegisters::f1; // fpRegT1
+
+    static const FPRReg argumentFPR0 = PPCRegisters::f1; // fpRegT1
+    static const FPRReg argumentFPR1 = PPCRegisters::f2; // fpRegT2
+    static const FPRReg argumentFPR2 = PPCRegisters::f3; // fpRegT3
+    static const FPRReg argumentFPR3 = PPCRegisters::f4; // fpRegT4
+
+    // FPRReg mapping is direct, the machine regsiter numbers can
+    // be used directly as indices into the FPR RegisterBank.
+    COMPILE_ASSERT(PPCRegisters::f0 == 0, f0_is_0);
+    COMPILE_ASSERT(PPCRegisters::f1 == 1, f1_is_1);
+    COMPILE_ASSERT(PPCRegisters::f2 == 2, f2_is_2);
+    COMPILE_ASSERT(PPCRegisters::f3 == 3, f3_is_3);
+    COMPILE_ASSERT(PPCRegisters::f4 == 4, f4_is_4);
+    COMPILE_ASSERT(PPCRegisters::f5 == 5, f5_is_5);
+    static FPRReg toRegister(unsigned index)
+    {
+        return (FPRReg)index;
+    }
+    static unsigned toIndex(FPRReg reg)
+    {
+        return (unsigned)reg;
+    }
+
+    static const char* debugName(FPRReg reg)
+    {
+        ASSERT(reg != InvalidFPRReg);
+        ASSERT(static_cast<int>(reg) < 32);
+        static const char* nameForRegister[32] = {
+            "f0", "f1", "f2", "f3",
+            "f4", "f5", "f6", "f7",
+            "f8", "f9", "f10", "f11",
+            "f12", "f13", "f14", "f15",
+            "f16", "f17", "f18", "f19",
+            "f20", "f21", "f22", "f23",
+            "f24", "f25", "f26", "f27",
+            "f28", "f29", "f30", "f31"
+        };
+        return nameForRegister[reg];
+    }
+
+    static const unsigned InvalidIndex = 0xffffffff;
+};
+
+#endif
+
 } // namespace JSC
 
 namespace WTF {
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/GPRInfo.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/GPRInfo.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/GPRInfo.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/GPRInfo.h	2018-06-12 14:28:02.341668760 +0000
@@ -767,7 +767,90 @@
     static const unsigned InvalidIndex = 0xffffffff;
 };
 
-#endif // CPU(SH4)
+#endif
+
+#if CPU(PPC)
+#define NUMBER_OF_ARGUMENT_REGISTERS 8
+
+class GPRInfo {
+public:
+    typedef GPRReg RegisterType;
+    static const unsigned numberOfRegisters = 8;
+    static const unsigned numberOfArgumentRegisters = NUMBER_OF_ARGUMENT_REGISTERS;
+
+    // Temporary registers.
+    static const GPRReg regT0 = PPCRegisters::r3;
+    static const GPRReg regT1 = PPCRegisters::r4;
+    static const GPRReg regT2 = PPCRegisters::r5;
+    static const GPRReg regT3 = PPCRegisters::r15;
+    static const GPRReg regT4 = PPCRegisters::r16;
+    static const GPRReg regT5 = PPCRegisters::r17;
+    static const GPRReg regT6 = PPCRegisters::r18;
+    static const GPRReg regT7 = PPCRegisters::r19;
+    // These registers match the baseline JIT.
+    static const GPRReg cachedResultRegister = regT0;
+    static const GPRReg cachedResultRegister2 = regT1;
+    static const GPRReg callFrameRegister = PPCRegisters::r14;
+    // These constants provide the names for the general purpose argument & return value registers.
+    static const GPRReg argumentGPR0 = PPCRegisters::r3; // regT0
+    static const GPRReg argumentGPR1 = PPCRegisters::r4; // regT1
+    static const GPRReg argumentGPR2 = PPCRegisters::r5; // regT2
+    static const GPRReg argumentGPR3 = PPCRegisters::r6;
+    static const GPRReg argumentGPR4 = PPCRegisters::r7;
+    static const GPRReg argumentGPR5 = PPCRegisters::r8;
+    static const GPRReg argumentGPR6 = PPCRegisters::r9;
+    static const GPRReg argumentGPR7 = PPCRegisters::r10;
+    static const GPRReg nonArgGPR0 = PPCRegisters::r15; // regT4
+    static const GPRReg nonArgGPR1 = PPCRegisters::r16; // regT5
+    static const GPRReg nonArgGPR2 = PPCRegisters::r17; // regT6
+    static const GPRReg returnValueGPR = PPCRegisters::r3; // regT0
+    static const GPRReg returnValueGPR2 = PPCRegisters::r4; // regT1
+    static const GPRReg nonPreservedNonReturnGPR = PPCRegisters::r5;
+
+    static GPRReg toRegister(unsigned index)
+    {
+        ASSERT(index < numberOfRegisters);
+        static const GPRReg registerForIndex[numberOfRegisters] = { regT0, regT1, regT2, regT3, regT4, regT5, regT6, regT7 };
+        return registerForIndex[index];
+    }
+
+    static unsigned toIndex(GPRReg reg)
+    {
+        ASSERT(static_cast<unsigned>(reg) != InvalidGPRReg);
+        ASSERT(static_cast<unsigned>(reg) < 32);
+        static const unsigned indexForRegister[32] =
+        {
+            InvalidIndex, InvalidIndex, InvalidIndex, 0, 1, 2, InvalidIndex, InvalidIndex,
+            InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, 3,
+            4, 5, 6, 7, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex,
+            InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex
+        };
+        unsigned result = indexForRegister[reg];
+        ASSERT(result != InvalidIndex);
+        return result;
+    }
+
+    static const char* debugName(GPRReg reg)
+    {
+        ASSERT(static_cast<unsigned>(reg) != InvalidGPRReg);
+        ASSERT(static_cast<unsigned>(reg) < 32);
+        static const char* nameForRegister[32] = {
+            "r0", "r1", "r2", "r3",
+            "r4", "r5", "r6", "r7",
+            "r8", "r9", "r10", "r11",
+            "r12", "r13", "r14", "r15"
+            "r16", "r17", "r18", "r19"
+            "r20", "r21", "r22", "r23"
+            "r24", "r25", "r26", "r27"
+            "r28", "r29", "r30", "r31"
+        };
+        return nameForRegister[reg];
+    }
+
+    static const unsigned InvalidIndex = 0xffffffff;
+};
+
+#endif // CPU(PPC)
 
 // The baseline JIT uses "accumulator" style execution with regT0 (for 64-bit)
 // and regT0 + regT1 (for 32-bit) serving as the accumulator register(s) for
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JIT.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JIT.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JIT.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JIT.cpp	2018-07-15 10:52:38.249017217 +0000
@@ -118,15 +118,26 @@
 
 #define DEFINE_OP(name) \
     case name: { \
+        COMPILEDPRINTF("Compiling: %s\n", # name); \
+	dprint("JIT@% 3d: Executing: " # name "\n", getgencount()); \
         emit_##name(currentInstruction); \
         NEXT_OPCODE(name); \
     }
 
+#if JITCOMPILEDEBUG
 #define DEFINE_SLOWCASE_OP(name) \
     case name: { \
+        foddprintf("Compiling slow: %s\n", # name); \
         emitSlow_##name(currentInstruction, iter); \
         NEXT_OPCODE(name); \
     }
+#else
+#define DEFINE_SLOWCASE_OP(name) \
+    case name: { \
+        emitSlow_##name(currentInstruction, iter); \
+        NEXT_OPCODE(name); \
+    }
+#endif
 
 void JIT::privateCompileMainPass()
 {
@@ -359,6 +370,8 @@
         if (m_disassembler)
             m_disassembler->setForBytecodeSlowPath(m_bytecodeOffset, label());
 
+	COMPILEDPRINTF("%s:%d/%s(): Compiling %d slow\n", __FILE__, __LINE__, __func__, m_interpreter->getOpcodeID(currentInstruction->u.opcode));
+
         switch (m_interpreter->getOpcodeID(currentInstruction->u.opcode)) {
         DEFINE_SLOWCASE_OP(op_add)
         DEFINE_SLOWCASE_OP(op_bitand)
@@ -454,6 +467,8 @@
 
 CompilationResult JIT::privateCompile(JITCompilationEffort effort)
 {
+	COMPILEDPRINTF("%s:%d/%s: Entering\n", __FILE__, __LINE__, __func__);
+
 #if ENABLE(VALUE_PROFILER)
     DFG::CapabilityLevel level = m_codeBlock->capabilityLevel();
     switch (level) {
@@ -508,17 +523,39 @@
     if (m_randomGenerator.getUint32() & 1)
         nop();
 
+	COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__);
+
     preserveReturnAddressAfterCall(regT2);
+
+	dprint("JIT@% 3d: prologue: Entering Javascript function\n", getgencount());
+
+        dprint("JIT@% 3d: prologue: Coming from %08x\n", getgencount(), regT2);
+        dprint("JIT@% 3d: prologue: r1 = %08x\n", getgencount(), PPCRegisters::r1);
+
+        dprint("JIT@% 3d: prologue: regT0 = %08x\n", getgencount(), PPCRegisters::r3);
+        dprint("JIT@% 3d: prologue: regT1 = %08x\n", getgencount(), PPCRegisters::r4);
+        dprint("JIT@% 3d: prologue: regT2 = %08x\n", getgencount(), PPCRegisters::r5);
+        dprint("JIT@% 3d: prologue: regT3 = %08x\n", getgencount(), PPCRegisters::r15);
+        dprint("JIT@% 3d: prologue: regT4 = %08x\n", getgencount(), PPCRegisters::r16);
+        dprint("JIT@% 3d: prologue: callFrameRegister = %08x\n", getgencount(), PPCRegisters::r14);
+        m_assembler.mflr(PPCRegisters::r0);
+        dprint("JIT@% 3d: prologue: LR = %08x\n", getgencount(), PPCRegisters::r0);
+
+	dprint("JIT@% 3d: " __FILE__ ":%d: ReturnPC@%08x <- %08x, r1 = %08x\n", getgencount(), __LINE__, callFrameRegister, regT2, PPCRegisters::r1);
+
     emitPutReturnPCToCallFrameHeader(regT2);
     emitPutImmediateToCallFrameHeader(m_codeBlock, JSStack::CodeBlock);
 
+	dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     Label beginLabel(this);
 
+	dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     sampleCodeBlock(m_codeBlock);
 #if ENABLE(OPCODE_SAMPLING)
     sampleInstruction(m_codeBlock->instructions().begin());
 #endif
 
+	dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     Jump stackCheck;
     if (m_codeBlock->codeType() == FunctionCode) {
 #if ENABLE(VALUE_PROFILER)
@@ -542,6 +579,12 @@
 #endif
 
         addPtr(TrustedImm32(virtualRegisterForLocal(frameRegisterCountFor(m_codeBlock)).offset() * sizeof(Register)), callFrameRegister, regT1);
+
+#if 0
+	load32(m_vm->addressOfJSStackLimit(), PPCRegisters::r6);
+	dprint("JIT@% 3d: Stack check: %08x regT1 %08x\n", getgencount(), PPCRegisters::r6, regT1);
+#endif
+
         stackCheck = branchPtr(Above, AbsoluteAddress(m_vm->addressOfJSStackLimit()), regT1);
     }
 
@@ -557,22 +600,40 @@
     Label arityCheck;
     if (m_codeBlock->codeType() == FunctionCode) {
         stackCheck.link(this);
+
+	dprint("JIT@% 3d: Stack overflow\n", getgencount());
+
         m_bytecodeOffset = 0;
         callOperationWithCallFrameRollbackOnException(operationStackCheck, m_codeBlock);
 #ifndef NDEBUG
         m_bytecodeOffset = (unsigned)-1; // Reset this, in order to guard its use with ASSERTs.
 #endif
+
+	dprint("JIT@% 3d: Jumping to function\n", getgencount());
+
         jump(functionBody);
 
         arityCheck = label();
         store8(TrustedImm32(0), &m_codeBlock->m_shouldAlwaysBeInlined);
+	COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__);
         preserveReturnAddressAfterCall(regT2);
+
+	dprint("JIT@% 3d: " __FILE__ ":%d: ReturnPC@%08x <- %08x, r1 = %08x\n", getgencount(), __LINE__, callFrameRegister, regT2, PPCRegisters::r1);
+
         emitPutReturnPCToCallFrameHeader(regT2);
         emitPutImmediateToCallFrameHeader(m_codeBlock, JSStack::CodeBlock);
 
+	dprint("JIT@% 3d: Restarting function?\n", getgencount());
+
         load32(payloadFor(JSStack::ArgumentCount), regT1);
+
+	dprint("JIT@% 3d: Argument count: %d\n", getgencount(), regT1);
+	dprint("JIT@% 3d: codeblock params: %d\n", getgencount(), (int)m_codeBlock->m_numParameters);
+
         branch32(AboveOrEqual, regT1, TrustedImm32(m_codeBlock->m_numParameters)).linkTo(beginLabel, this);
 
+	dprint("JIT@% 3d: Nope\n", getgencount());
+
         m_bytecodeOffset = 0;
 
         callOperationWithCallFrameRollbackOnException(m_codeBlock->m_isConstructor ? operationConstructArityCheck : operationCallArityCheck);
@@ -585,6 +646,8 @@
         m_bytecodeOffset = (unsigned)-1; // Reset this, in order to guard its use with ASSERTs.
 #endif
 
+	dprint("JIT@% 3d: Restarting function\n", getgencount());
+
         jump(beginLabel);
     }
 
@@ -597,7 +660,10 @@
 
     LinkBuffer patchBuffer(*m_vm, this, m_codeBlock, effort);
     if (patchBuffer.didFailToAllocate())
+    {
+	COMPILEDPRINTF("%s:%d/%s: Failing\n", __FILE__, __LINE__, __func__);
         return CompilationFailed;
+    }
 
     // Translate vPC offsets into addresses in JIT generated code, for switch tables.
     for (unsigned i = 0; i < m_switches.size(); ++i) {
@@ -708,6 +774,8 @@
     dataLogF("JIT generated code for %p at [%p, %p).\n", m_codeBlock, result.executableMemory()->start(), result.executableMemory()->end());
 #endif
     
+	COMPILEDPRINTF("%s:%d/%s: Leaving\n", __FILE__, __LINE__, __func__);
+
     return CompilationSuccessful;
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITArithmetic32_64.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITArithmetic32_64.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITArithmetic32_64.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITArithmetic32_64.cpp	2018-07-16 07:38:18.067205825 +0000
@@ -509,8 +509,13 @@
     notInt32Op1.append(branch32(NotEqual, regT1, TrustedImm32(JSValue::Int32Tag)));
     notInt32Op2.append(branch32(NotEqual, regT3, TrustedImm32(JSValue::Int32Tag)));
 
+	dprint("JIT@% 3d: op_add: Both operands are integers, %08x + %08x\n", getgencount(), regT0, regT2);
+
     // Int32 case.
     addSlowCase(branchAdd32(Overflow, regT2, regT0));
+
+	dprint("JIT@% 3d: op_add: Result is %08x\n", getgencount(), regT0);
+
     emitStoreInt32(dst, regT0, (op1 == dst || op2 == dst));
 
     if (!supportsFloatingPoint()) {
@@ -527,10 +532,18 @@
 
 void JIT::emitAdd32Constant(int dst, int op, int32_t constant, ResultType opType)
 {
+	dprint("JIT@% 3d: op_add: Value is constant %08x\n", getgencount(), constant);
+
     // Int32 case.
     emitLoad(op, regT1, regT2);
+
+	dprint("JIT@% 3d: op_add: Source is %08x:%08x\n", getgencount(), regT1, regT2);
+
     Jump notInt32 = branch32(NotEqual, regT1, TrustedImm32(JSValue::Int32Tag));
     addSlowCase(branchAdd32(Overflow, regT2, Imm32(constant), regT0));
+
+	dprint("JIT@% 3d: op_add: Result is %08x\n", getgencount(), regT0);
+
     emitStoreInt32(dst, regT0, (op == dst));
 
     // Double case.
@@ -541,6 +554,9 @@
     Jump end = jump();
 
     notInt32.link(this);
+
+	dprint("JIT@% 3d: op_add: Not integer\n", getgencount(), regT0);
+
     if (!opType.definitelyIsNumber())
         addSlowCase(branch32(Above, regT1, TrustedImm32(JSValue::LowestTag)));
     move(Imm32(constant), regT2);
@@ -592,6 +608,8 @@
         }
     }
 
+	dprint("JIT@% 3d: op_add: slow path\n", getgencount());
+
     JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_add);
     slowPathCall.call();
 }
@@ -635,10 +653,18 @@
 
 void JIT::emitSub32Constant(int dst, int op, int32_t constant, ResultType opType)
 {
+	dprint("JIT@% 3d: op_sub: Value is constant %08x\n", getgencount(), constant);
+
     // Int32 case.
     emitLoad(op, regT1, regT0);
+
+	dprint("JIT@% 3d: op_sub: Source is %08x:%08x\n", getgencount(), regT1, regT0);
+
     Jump notInt32 = branch32(NotEqual, regT1, TrustedImm32(JSValue::Int32Tag));
     addSlowCase(branchSub32(Overflow, regT0, Imm32(constant), regT2, regT3));   
+
+	dprint("JIT@% 3d: op_sub: Result is %08x\n", getgencount(), regT2);
+
     emitStoreInt32(dst, regT2, (op == dst));
 
     // Double case.
@@ -699,12 +725,16 @@
         // Double case 1: Op1 is not int32; Op2 is unknown.
         notInt32Op1.link(this);
 
+	dprint("JIT@% 3d: op_add: Op1 is not int32; Op2 is unknown, opcodeid %08x\n", getgencount(), (int)opcodeID);
+
         ASSERT(op1IsInRegisters);
 
         // Verify Op1 is double.
         if (!types.first().definitelyIsNumber())
             addSlowCase(branch32(Above, regT1, TrustedImm32(JSValue::LowestTag)));
 
+	dprint("JIT@% 3d: op_add: Op1 is a double\n", getgencount());
+
         if (!op2IsInRegisters)
             emitLoad(op2, regT3, regT2);
 
@@ -713,19 +743,31 @@
         if (!types.second().definitelyIsNumber())
             addSlowCase(branch32(NotEqual, regT3, TrustedImm32(JSValue::Int32Tag)));
 
+	dprint("JIT@% 3d: op_add: Converting %d to float\n", getgencount(), regT2);
+
         convertInt32ToDouble(regT2, fpRegT0);
+
+	dprint("JIT@% 3d: op_add: Result is %f\n", getgencount(), fpRegT0);
+
         Jump doTheMath = jump();
 
         // Load Op2 as double into double register.
         doubleOp2.link(this);
         emitLoadDouble(op2, fpRegT0);
 
+	dprint("JIT@% 3d: op_add: Loaded %f into fpRegT0\n", getgencount(), fpRegT0);
+
         // Do the math.
         doTheMath.link(this);
+
+	dprint("JIT@% 3d: op_add: doTheMath\n", getgencount());
+
         switch (opcodeID) {
             case op_mul:
                 emitLoadDouble(op1, fpRegT2);
+	        dprint("JIT@% 3d: op_mul: %f * %f\n", getgencount(), fpRegT2, fpRegT0);
                 mulDouble(fpRegT2, fpRegT0);
+	        dprint("JIT@% 3d: op_mul: Result is %f\n", getgencount(), fpRegT0);
                 emitStoreDouble(dst, fpRegT0);
                 break;
             case op_add:
@@ -788,7 +830,9 @@
                 addJump(branchDouble(DoubleGreaterThanOrEqual, fpRegT2, fpRegT0), dst);
                 break;
             case op_jnless:
+	        dprint("JIT@% 3d: op_add: op_jnless\n", getgencount());
                 emitLoadDouble(op1, fpRegT2);
+	        dprint("JIT@% 3d: op_add: Loaded %f to fpRegT2\n", getgencount(), fpRegT2);
                 addJump(branchDouble(DoubleLessThanOrEqualOrUnordered, fpRegT0, fpRegT2), dst);
                 break;
             case op_jnlesseq:
@@ -815,13 +859,19 @@
         // Double case 2: Op1 is int32; Op2 is not int32.
         notInt32Op2.link(this);
 
+	dprint("JIT@% 3d: op_add: Op1 is int32; Op2 is not int32\n", getgencount());
+
         ASSERT(op2IsInRegisters);
 
         if (!op1IsInRegisters)
             emitLoadPayload(op1, regT0);
 
+	dprint("JIT@% 3d: op_add: Converting %d to float\n", getgencount(), regT0);
+
         convertInt32ToDouble(regT0, fpRegT0);
 
+	dprint("JIT@% 3d: op_add: Result is %f\n", getgencount(), fpRegT0);
+
         // Verify op2 is double.
         if (!types.second().definitelyIsNumber())
             addSlowCase(branch32(Above, regT3, TrustedImm32(JSValue::LowestTag)));
@@ -830,21 +880,25 @@
         switch (opcodeID) {
             case op_mul:
                 emitLoadDouble(op2, fpRegT2);
+	        dprint("JIT@% 3d: op_mul: %f * %f\n", getgencount(), fpRegT2, fpRegT0);
                 mulDouble(fpRegT2, fpRegT0);
                 emitStoreDouble(dst, fpRegT0);
                 break;
             case op_add:
                 emitLoadDouble(op2, fpRegT2);
+	        dprint("JIT@% 3d: op_mul: %f + %f\n", getgencount(), fpRegT2, fpRegT0);
                 addDouble(fpRegT2, fpRegT0);
                 emitStoreDouble(dst, fpRegT0);
                 break;
             case op_sub:
                 emitLoadDouble(op2, fpRegT2);
+	        dprint("JIT@% 3d: op_mul: %f - %f\n", getgencount(), fpRegT2, fpRegT0);
                 subDouble(fpRegT2, fpRegT0);
                 emitStoreDouble(dst, fpRegT0);
                 break;
             case op_div: {
                 emitLoadDouble(op2, fpRegT2);
+	        dprint("JIT@% 3d: op_mul: %f / %f\n", getgencount(), fpRegT2, fpRegT0);
                 divDouble(fpRegT2, fpRegT0);
 #if ENABLE(VALUE_PROFILER)
                 // Is the result actually an integer? The DFG JIT would really like to know. If it's
@@ -892,7 +946,9 @@
                 addJump(branchDouble(DoubleGreaterThanOrEqual, fpRegT0, fpRegT1), dst);
                 break;
             case op_jnless:
+	        dprint("JIT@% 3d: op_add: op_jnless\n", getgencount());
                 emitLoadDouble(op2, fpRegT1);
+	        dprint("JIT@% 3d: op_add: Loaded %f to fpRegT1\n", getgencount(), fpRegT1);
                 addJump(branchDouble(DoubleLessThanOrEqualOrUnordered, fpRegT1, fpRegT0), dst);
                 break;
             case op_jnlesseq:
@@ -910,6 +966,8 @@
             default:
                 RELEASE_ASSERT_NOT_REACHED();
         }
+
+	dprint("JIT@% 3d: op_add: result is %f\n", getgencount(), fpRegT0);
     }
 
     end.link(this);
@@ -924,6 +982,8 @@
     int op2 = currentInstruction[3].u.operand;
     OperandTypes types = OperandTypes::fromInt(currentInstruction[4].u.operand);
 
+    dprint("emit_op_mul()\n");
+
 #if ENABLE(VALUE_PROFILER)
     m_codeBlock->addSpecialFastCaseProfile(m_bytecodeOffset);
 #endif
@@ -948,6 +1008,8 @@
     }
     Jump end = jump();
 
+    dprint("doing emitBinaryDoubleOp()\n");
+
     // Double case.
     emitBinaryDoubleOp(op_mul, dst, op1, op2, types, notInt32Op1, notInt32Op2);
     end.link(this);
@@ -960,6 +1022,8 @@
     int op2 = currentInstruction[3].u.operand;
     OperandTypes types = OperandTypes::fromInt(currentInstruction[4].u.operand);
 
+    dprint("emitSlow_op_mul()\n");
+
     Jump overflow = getSlowCase(iter); // overflow check
     linkSlowCase(iter); // zero result check
 
@@ -1114,8 +1178,10 @@
     numeratorPositive.link(this);
     emitStoreInt32(dst, regT1, (op1 == dst || op2 == dst));
 #else
+    dprint("JIT@% 3d: op_mod: pre-call Call frame 0x%08x\n", getgencount(), PPCRegisters::r14);
     JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_mod);
     slowPathCall.call();
+    dprint("JIT@% 3d: op_mod: post-call Call frame 0x%08x\n", getgencount(), PPCRegisters::r14);
 #endif
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITCall32_64.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITCall32_64.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITCall32_64.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITCall32_64.cpp	2018-07-16 10:05:10.517458254 +0000
@@ -55,11 +55,15 @@
 {
     unsigned dst = currentInstruction[1].u.operand;
 
+    dprint("JIT@% 3d: " __FILE__ ":%d: Current Call Frame is 0x%08x\n", getgencount(), __LINE__, PPCRegisters::r14);
+
     emitLoad(dst, regT1, regT0);
     emitGetReturnPCFromCallFrameHeaderPtr(regT2);
     emitGetCallerFrameFromCallFrameHeaderPtr(callFrameRegister);
 
     restoreReturnAddressBeforeReturn(regT2);
+    dprint("JIT@% 3d: " __FILE__ ":%d: New Call Frame is 0x%08x\n", getgencount(), __LINE__, PPCRegisters::r14);
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     ret();
 }
 
@@ -77,6 +81,7 @@
     emitGetCallerFrameFromCallFrameHeaderPtr(callFrameRegister);
 
     restoreReturnAddressBeforeReturn(regT2);
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     ret();
 
     notJSCell.link(this);
@@ -87,6 +92,7 @@
     emitGetCallerFrameFromCallFrameHeaderPtr(callFrameRegister);
 
     restoreReturnAddressBeforeReturn(regT2);
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     ret();
 }
 
@@ -107,6 +113,7 @@
 
 void JIT::emitSlow_op_construct(Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
+    dprint("JIT@% 3d: emitSlow_op_construct: Calling compileOpCallSlowCase()\n", getgencount());
     compileOpCallSlowCase(op_construct, currentInstruction, iter, m_callLinkInfoIndex++);
 }
 
@@ -127,6 +134,7 @@
 
 void JIT::emit_op_construct(Instruction* currentInstruction)
 {
+    dprint("JIT@% 3d: emit_op_construct: Calling compileOpCall()\n", getgencount());
     compileOpCall(op_construct, currentInstruction, m_callLinkInfoIndex++);
 }
 
@@ -199,6 +207,7 @@
 void JIT::compileCallEval(Instruction* instruction)
 {
     callOperationWithCallFrameRollbackOnException(operationCallEval);
+    swap(regT0, regT1);
     addSlowCase(branch32(Equal, regT1, TrustedImm32(JSValue::EmptyValueTag)));
     emitGetCallerFrameFromCallFrameHeaderPtr(callFrameRegister);
 
@@ -237,13 +246,21 @@
         - Caller restores callFrameRegister after return.
     */
     
+    dprint("JIT@% 3d: compileOpCall:\n", getgencount());
     if (opcodeID == op_call_varargs)
+    {
+    dprint("JIT@% 3d: compileOpCall:\n", getgencount());
         compileLoadVarargs(instruction);
+    }
     else {
+    dprint("JIT@% 3d: compileOpCall:\n", getgencount());
         int argCount = instruction[3].u.operand;
         int registerOffset = -instruction[4].u.operand;
         
+    dprint("JIT@% 3d: compileOpCall: registerOffset = %d\n", getgencount(), registerOffset);
+
         if (opcodeID == op_call && shouldEmitProfiling()) {
+    dprint("JIT@% 3d: compileOpCall:\n", getgencount());
             emitLoad(registerOffset + CallFrame::argumentOffsetIncludingThis(0), regT0, regT1);
             Jump done = branch32(NotEqual, regT0, TrustedImm32(JSValue::CellTag));
             loadPtr(Address(regT1, JSCell::structureOffset()), regT1);
@@ -251,15 +268,26 @@
             done.link(this);
         }
     
+    dprint("JIT@% 3d: compileOpCall: registerOffset = %d\n", getgencount(), registerOffset);
+
+    dprint("JIT@% 3d: compileOpCall: size to add to call frame: 0x%08x\n", getgencount(), registerOffset * sizeof(Register));
+    dprint("JIT@% 3d: compileOpCall: callFrameRegister = 0x%08x\n", getgencount(), callFrameRegister);
+
         addPtr(TrustedImm32(registerOffset * sizeof(Register)), callFrameRegister, regT3);
 
+    dprint("JIT@% 3d: compileOpCall: New callframe address is 0x%08x (old 0x%08x)\n", getgencount(), regT3, callFrameRegister);
         store32(TrustedImm32(argCount), payloadFor(JSStack::ArgumentCount, regT3));
+    dprint("JIT@% 3d: compileOpCall:\n", getgencount());
     } // regT3 holds newCallFrame with ArgumentCount initialized.
     
     uint32_t locationBits = CallFrame::Location::encodeAsBytecodeInstruction(instruction);
     store32(TrustedImm32(locationBits), tagFor(JSStack::ArgumentCount, callFrameRegister));
     emitLoad(callee, regT1, regT0); // regT1, regT0 holds callee.
 
+    dprint("JIT@% 3d: callFrameRegister 0x%08x\n", getgencount(), callFrameRegister);
+    dprint("JIT@% 3d: Callee offset 0x%08x\n", getgencount(), static_cast<VirtualRegister>(callee).offset());
+    dprint("JIT@% 3d: callee@%d tag %08x payload %08x\n", getgencount(), callee, regT1, regT0);
+
     storePtr(callFrameRegister, Address(regT3, CallFrame::callerFrameOffset()));
     emitStore(JSStack::Callee, regT1, regT0, regT3);
     move(regT3, callFrameRegister);
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITCode.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITCode.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITCode.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITCode.cpp	2018-06-14 05:10:41.370355881 +0000
@@ -30,6 +30,14 @@
 #include "Operations.h"
 #include <wtf/PrintStream.h>
 
+#include <assembler/MacroAssembler.h>
+
+#include "JITStubsPPC.h"
+
+extern "C" { void foddprintf(const char *, ...); }
+
+void DumpDumpSpaces();
+
 namespace JSC {
 
 JITCode::JITCode(JITType jitType)
@@ -43,9 +51,30 @@
 
 JSValue JITCode::execute(VM* vm, ProtoCallFrame* protoCallFrame, Register* topOfStack)
 {
+	unsigned int *code;
+	unsigned int codesize;
+	unsigned int i;
+	unsigned long long ret;
+
+	code = (unsigned int *)executableAddress();
+	EXECUTEDPRINTF("%s:%d/%s(): Calling ctiTrampoline() to start executing at address %08x, size %d\n", __FILE__, __LINE__, __func__, executableAddress(), size());
+
+#if 1
+	{
+	::DumpDumpSpaces();
+	}
+#endif
+
     ASSERT(!vm->topCallFrame || ((Register*)(vm->topCallFrame) >= topOfStack));
 
-    JSValue result = JSValue::decode(callToJavaScript(executableAddress(), &vm->topCallFrame, protoCallFrame, topOfStack));
+	EXECUTEDPRINTF("JIT: %s:%d/%s(): Calling JIT code at 0x%08x\n", __FILE__, __LINE__, __func__, executableAddress());
+
+    ret = callToJavaScript(executableAddress(), &vm->topCallFrame, protoCallFrame, topOfStack);
+    ret = (ret<<32)|(ret>>32);
+    JSValue result = JSValue::decode(ret);
+
+	EXECUTEDPRINTF("JIT: %s:%d/%s(): JS return value is %016llx, called from 0x%08x\n", __FILE__, __LINE__, __func__, result.encode(result), __builtin_return_address(0));
+
     return vm->exception() ? jsNull() : result;
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITExceptions.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITExceptions.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITExceptions.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITExceptions.cpp	2018-06-12 14:28:02.349668826 +0000
@@ -39,16 +39,20 @@
 #include "Operations.h"
 #include "VM.h"
 
+#include "JITStubsPPC.h"
+
 namespace JSC {
 
 void genericUnwind(VM* vm, ExecState* callFrame, JSValue exceptionValue)
 {
+    EXECUTEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     RELEASE_ASSERT(exceptionValue);
     HandlerInfo* handler = vm->interpreter->unwind(callFrame, exceptionValue); // This may update callFrame.
 
     void* catchRoutine;
     Instruction* catchPCForInterpreter = 0;
     if (handler) {
+    EXECUTEDPRINTF("%s:%d/%s(): Have handler\n", __FILE__, __LINE__, __func__);
         catchPCForInterpreter = &callFrame->codeBlock()->instructions()[handler->target];
 #if ENABLE(JIT)
         catchRoutine = handler->nativeCode.executableAddress();
@@ -56,12 +60,17 @@
         catchRoutine = catchPCForInterpreter->u.pointer;
 #endif
     } else
+{
+    EXECUTEDPRINTF("%s:%d/%s(): No handler\n", __FILE__, __LINE__, __func__);
         catchRoutine = LLInt::getCodePtr(returnFromJavaScript);
+}
     
     vm->callFrameForThrow = callFrame;
     vm->targetMachinePCForThrow = catchRoutine;
     vm->targetInterpreterPCForThrow = catchPCForInterpreter;
     
+    EXECUTEDPRINTF("%s:%d/%s(): catchRoutine 0x%08x\n", __FILE__, __LINE__, __func__, (unsigned int)catchRoutine);
+
     RELEASE_ASSERT(catchRoutine);
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITInlineCacheGenerator.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITInlineCacheGenerator.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITInlineCacheGenerator.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITInlineCacheGenerator.cpp	2018-07-17 12:46:20.140698398 +0000
@@ -102,18 +102,35 @@
 
 void JITByIdGenerator::generateFastPathChecks(MacroAssembler& jit, GPRReg butterfly)
 {
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: regT1 0x%08x, regT0 0x%08x\n", jit.getgencount(), __LINE__, GPRInfo::regT1, GPRInfo::regT0);
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: regT3 0x%08x, regT2 0x%08x\n", jit.getgencount(), __LINE__, GPRInfo::regT3, GPRInfo::regT2);
+
+#if 0
+    MacroAssembler::Jump j1 = jit.branch32(MacroAssembler::NotEqual, GPRInfo::regT3, MacroAssembler::TrustedImm32(0xffffffff));
+    MacroAssembler::Jump j2 = jit.branch32(MacroAssembler::NotEqual, GPRInfo::regT2, MacroAssembler::TrustedImm32(0x0000021a));
+    jit.breakpoint();
+    j1.link(&jit);
+    j2.link(&jit);
+#endif
+
     m_structureCheck = jit.patchableBranchPtrWithPatch(
         MacroAssembler::NotEqual,
         MacroAssembler::Address(m_base.payloadGPR(), JSCell::structureOffset()),
         m_structureImm, MacroAssembler::TrustedImmPtr(reinterpret_cast<void*>(unusedPointer)));
     
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: regT1 0x%08x, regT0 0x%08x\n", jit.getgencount(), __LINE__, GPRInfo::regT1, GPRInfo::regT0);
     m_propertyStorageLoad = jit.convertibleLoadPtr(
         MacroAssembler::Address(m_base.payloadGPR(), JSObject::butterflyOffset()), butterfly);
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: regT1 0x%08x, regT0 0x%08x\n", jit.getgencount(), __LINE__, GPRInfo::regT1, GPRInfo::regT0);
 }
 
 void JITGetByIdGenerator::generateFastPath(MacroAssembler& jit)
 {
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: regT1 0x%08x, regT0 0x%08x\n", jit.getgencount(), __LINE__, GPRInfo::regT1, GPRInfo::regT0);
+
     generateFastPathChecks(jit, m_value.payloadGPR());
+
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: regT1 0x%08x, regT0 0x%08x\n", jit.getgencount(), __LINE__, GPRInfo::regT1, GPRInfo::regT0);
     
 #if USE(JSVALUE64)
     m_loadOrStore = jit.load64WithCompactAddressOffsetPatch(
@@ -121,11 +138,14 @@
 #else
     m_tagLoadOrStore = jit.load32WithCompactAddressOffsetPatch(
         MacroAssembler::Address(m_value.payloadGPR(), 0), m_value.tagGPR()).label();
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: regT1 0x%08x, regT0 0x%08x\n", jit.getgencount(), __LINE__, GPRInfo::regT1, GPRInfo::regT0);
     m_loadOrStore = jit.load32WithCompactAddressOffsetPatch(
         MacroAssembler::Address(m_value.payloadGPR(), 0), m_value.payloadGPR()).label();
 #endif
     
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: regT1 0x%08x, regT0 0x%08x\n", jit.getgencount(), __LINE__, GPRInfo::regT1, GPRInfo::regT0);
     m_done = jit.label();
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: regT1 0x%08x, regT0 0x%08x\n", jit.getgencount(), __LINE__, GPRInfo::regT1, GPRInfo::regT0);
 }
 
 JITPutByIdGenerator::JITPutByIdGenerator(
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITInlines.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITInlines.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITInlines.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITInlines.h	2018-07-16 09:54:39.752615105 +0000
@@ -56,12 +56,12 @@
 
 ALWAYS_INLINE void JIT::emitGetFromCallFrameHeaderPtr(JSStack::CallFrameHeaderEntry entry, RegisterID to, RegisterID from)
 {
-    loadPtr(Address(from, entry * sizeof(Register)), to);
+    loadPtr(payloadFor(entry, from), to);
 }
 
 ALWAYS_INLINE void JIT::emitGetFromCallFrameHeader32(JSStack::CallFrameHeaderEntry entry, RegisterID to, RegisterID from)
 {
-    load32(Address(from, entry * sizeof(Register)), to);
+    load32(payloadFor(entry, from), to);
 }
 
 #if USE(JSVALUE64)
@@ -94,6 +94,8 @@
 {
     ASSERT(m_bytecodeOffset != (unsigned)-1); // This method should only be called during hot/cold path generation, so that m_bytecodeOffset is set.
 
+    COMPILEDPRINTF("%s:%d/%s(): Apparently we're gonna call %08x\n", __FILE__, __LINE__, __func__, function.executableAddress());
+
     Call nakedCall = nearCall();
     m_calls.append(CallRecord(nakedCall, m_bytecodeOffset, function.executableAddress()));
     return nakedCall;
@@ -116,6 +118,9 @@
 {
     updateTopCallFrame();
     MacroAssembler::Call call = appendCall(function);
+#if 0 && CPU(BIG_ENDIAN)
+    swap(returnValueGPR, returnValueGPR2);
+#endif
     exceptionCheck();
     return call;
 }
@@ -124,6 +129,9 @@
 {
     updateTopCallFrame(); // The callee is responsible for setting topCallFrame to their caller
     MacroAssembler::Call call = appendCall(function);
+#if 0 && CPU(BIG_ENDIAN)
+    swap(returnValueGPR, returnValueGPR2);
+#endif
     exceptionCheckWithCallFrameRollback();
     return call;
 }
@@ -134,157 +142,200 @@
 #if USE(JSVALUE64)
     emitPutVirtualRegister(dst, returnValueGPR);
 #else
+#if 1
+    swap(returnValueGPR2, returnValueGPR);
+    emitStore(dst, returnValueGPR2, returnValueGPR);
+#else
+#if CPU(BIG_ENDIAN)
+    emitStore(dst, returnValueGPR, returnValueGPR2);
+#else
     emitStore(dst, returnValueGPR2, returnValueGPR);
 #endif
+#endif
+#endif
     return call;
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::appendCallWithExceptionCheckSetJSValueResultWithProfile(const FunctionPtr& function, int dst)
 {
     MacroAssembler::Call call = appendCallWithExceptionCheck(function);
+#if CPU(BIG_ENDIAN)
+    swap(returnValueGPR2, returnValueGPR);
+#endif
     emitValueProfilingSite(regT4);
 #if USE(JSVALUE64)
     emitPutVirtualRegister(dst, returnValueGPR);
 #else
+#if 1
+    emitStore(dst, returnValueGPR2, returnValueGPR);
+#else
+#if CPU(BIG_ENDIAN)
+    emitStore(dst, returnValueGPR, returnValueGPR2);
+#else
     emitStore(dst, returnValueGPR2, returnValueGPR);
 #endif
+#endif
+#endif
     return call;
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(C_JITOperation_E operation)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsExecState();
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(C_JITOperation_EO operation, GPRReg arg)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(arg);
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(C_JITOperation_ESt operation, Structure* structure)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(structure));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(C_JITOperation_EZ operation, int32_t arg)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImm32(arg));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_E operation, int dst)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsExecState();
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EAapJcpZ operation, int dst, ArrayAllocationProfile* arg1, GPRReg arg2, int32_t arg3)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(arg1), arg2, TrustedImm32(arg3));
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EAapJcpZ operation, int dst, ArrayAllocationProfile* arg1, const JSValue* arg2, int32_t arg3)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(arg1), TrustedImmPtr(arg2), TrustedImm32(arg3));
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EC operation, int dst, JSCell* cell)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(cell));
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_EC operation, JSCell* cell)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(cell));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EP operation, int dst, void* pointer)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(pointer));
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(WithProfileTag, J_JITOperation_EPc operation, int dst, Instruction* bytecodePC)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(bytecodePC));
     return appendCallWithExceptionCheckSetJSValueResultWithProfile(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EZ operation, int dst, int32_t arg)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImm32(arg));
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(P_JITOperation_EZ operation, int32_t op)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImm32(op));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(S_JITOperation_ECC operation, RegisterID regOp1, RegisterID regOp2)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(regOp1, regOp2);
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(S_JITOperation_EOJss operation, RegisterID regOp1, RegisterID regOp2)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(regOp1, regOp2);
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_E operation)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsExecState();
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_EC operation, RegisterID regOp)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(regOp);
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_ECC operation, RegisterID regOp1, RegisterID regOp2)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(regOp1, regOp2);
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_EPc operation, Instruction* bytecodePC)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(bytecodePC));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_EZ operation, int32_t op)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImm32(op));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperationWithCallFrameRollbackOnException(J_JITOperation_E operation)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsExecState();
     return appendCallWithCallFrameRollbackOnException(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperationWithCallFrameRollbackOnException(V_JITOperation_ECb operation, CodeBlock* pointer)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(pointer));
     return appendCallWithCallFrameRollbackOnException(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperationWithCallFrameRollbackOnException(Z_JITOperation_E operation)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsExecState();
     return appendCallWithCallFrameRollbackOnException(operation);
 }
@@ -293,48 +344,56 @@
 #if USE(JSVALUE64)
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(F_JITOperation_EJZ operation, GPRReg arg1, int32_t arg3)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(arg1, TrustedImm32(arg3));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(F_JITOperation_EFJJ operation, GPRReg arg1, GPRReg arg2, GPRReg arg3)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(arg1, arg2, arg3);
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_ESsiJJI operation, StructureStubInfo* stubInfo, RegisterID regOp1, RegisterID regOp2, StringImpl* uid)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(stubInfo), regOp1, regOp2, TrustedImmPtr(uid));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_EJJJ operation, RegisterID regOp1, RegisterID regOp2, RegisterID regOp3)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(regOp1, regOp2, regOp3);
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(JIT::WithProfileTag, J_JITOperation_ESsiJI operation, int dst, StructureStubInfo* stubInfo, GPRReg arg1, StringImpl* uid)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(stubInfo), arg1, TrustedImmPtr(uid));
     return appendCallWithExceptionCheckSetJSValueResultWithProfile(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(JIT::WithProfileTag, J_JITOperation_EJJ operation, int dst, GPRReg arg1, GPRReg arg2)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(arg1, arg2);
     return appendCallWithExceptionCheckSetJSValueResultWithProfile(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EAapJ operation, int dst, ArrayAllocationProfile* arg1, GPRReg arg2)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(TrustedImmPtr(arg1), arg2);
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EJ operation, int dst, GPRReg arg1)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(arg1);
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
@@ -347,6 +406,7 @@
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EJJ operation, int dst, GPRReg arg1, GPRReg arg2)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(arg1, arg2);
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
@@ -410,7 +470,7 @@
 
 // EncodedJSValue in JSVALUE32_64 is a 64-bit integer. When being compiled in ARM EABI, it must be aligned even-numbered register (r0, r2 or [sp]).
 // To avoid assemblies from using wrong registers, let's occupy r1 or r3 with a dummy argument when necessary.
-#if (COMPILER_SUPPORTS(EABI) && CPU(ARM)) || CPU(MIPS)
+#if (COMPILER_SUPPORTS(EABI) && CPU(ARM)) || CPU(MIPS) || CPU(PPC)
 #define EABI_32BIT_DUMMY_ARG      TrustedImm32(0),
 #else
 #define EABI_32BIT_DUMMY_ARG
@@ -425,123 +485,149 @@
 #define SH4_32BIT_DUMMY_ARG
 #endif
 
+#if CPU(BIG_ENDIAN)
+#define TAGPAYLOADREGPAIR(tag, payload) tag, payload
+#else
+#define TAGPAYLOADREGPAIR(tag, payload) payload, tag
+#endif
+
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperationNoExceptionCheck(V_JITOperation_EJ operation, GPRReg arg1Tag, GPRReg arg1Payload)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload));
     updateTopCallFrame();
     return appendCall(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(F_JITOperation_EJZ operation, GPRReg arg1Tag, GPRReg arg1Payload, int32_t arg2)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
 #if CPU(SH4)
     // We have to put arg3 in the 4th argument register (r7) as 64-bit value arg2 will be put on stack for sh4 architecure.
     setupArgumentsWithExecState(arg1Payload, arg1Tag, TrustedImm32(arg2));
 #else
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, TrustedImm32(arg2));
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), TrustedImm32(arg2));
 #endif
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(F_JITOperation_EFJJ operation, GPRReg arg1, GPRReg arg2Tag, GPRReg arg2Payload, GPRReg arg3Tag, GPRReg arg3Payload)
 {
-    setupArgumentsWithExecState(arg1, arg2Payload, arg2Tag, arg3Payload, arg3Tag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(arg1, TAGPAYLOADREGPAIR(arg2Tag, arg2Payload), TAGPAYLOADREGPAIR(arg3Tag, arg3Payload));
     return appendCallWithExceptionCheck(operation);
 }
     
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EAapJ operation, int dst, ArrayAllocationProfile* arg1, GPRReg arg2Tag, GPRReg arg2Payload)
 {
-    setupArgumentsWithExecState(TrustedImmPtr(arg1), arg2Payload, arg2Tag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(TrustedImmPtr(arg1), TAGPAYLOADREGPAIR(arg2Tag, arg2Payload));
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EJ operation, int dst, GPRReg arg1Tag, GPRReg arg1Payload)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload));
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(JIT::WithProfileTag, J_JITOperation_ESsiJI operation, int dst, StructureStubInfo* stubInfo, GPRReg arg1Tag, GPRReg arg1Payload, StringImpl* uid)
 {
-    setupArgumentsWithExecState(TrustedImmPtr(stubInfo), arg1Payload, arg1Tag, TrustedImmPtr(uid));
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(TrustedImmPtr(stubInfo), TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), TrustedImmPtr(uid));
     return appendCallWithExceptionCheckSetJSValueResultWithProfile(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EJIdc operation, int dst, GPRReg arg1Tag, GPRReg arg1Payload, const Identifier* arg2)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, TrustedImmPtr(arg2));
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), TrustedImmPtr(arg2));
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(J_JITOperation_EJJ operation, int dst, GPRReg arg1Tag, GPRReg arg1Payload, GPRReg arg2Tag, GPRReg arg2Payload)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, SH4_32BIT_DUMMY_ARG arg2Payload, arg2Tag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), SH4_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg2Tag, arg2Payload));
     return appendCallWithExceptionCheckSetJSValueResult(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(JIT::WithProfileTag, J_JITOperation_EJJ operation, int dst, GPRReg arg1Tag, GPRReg arg1Payload, GPRReg arg2Tag, GPRReg arg2Payload)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, SH4_32BIT_DUMMY_ARG arg2Payload, arg2Tag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), SH4_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg2Tag, arg2Payload));
     return appendCallWithExceptionCheckSetJSValueResultWithProfile(operation, dst);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(P_JITOperation_EJS operation, GPRReg arg1Tag, GPRReg arg1Payload, size_t arg2)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, TrustedImmPtr(arg2));
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), TrustedImmPtr(arg2));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(S_JITOperation_EJ operation, RegisterID argTag, RegisterID argPayload)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG argPayload, argTag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(argTag, argPayload));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(S_JITOperation_EJJ operation, RegisterID arg1Tag, RegisterID arg1Payload, RegisterID arg2Tag, RegisterID arg2Payload)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG arg1Payload, arg1Tag, SH4_32BIT_DUMMY_ARG arg2Payload, arg2Tag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg1Tag, arg1Payload), SH4_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(arg2Tag, arg2Payload));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_ECICC operation, RegisterID regOp1, const Identifier* identOp2, RegisterID regOp3, RegisterID regOp4)
 {
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     setupArgumentsWithExecState(regOp1, TrustedImmPtr(identOp2), regOp3, regOp4);
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_EJ operation, RegisterID regOp1Tag, RegisterID regOp1Payload)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG regOp1Payload, regOp1Tag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(regOp1Tag, regOp1Payload));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_EIdJZ operation, const Identifier* identOp1, RegisterID regOp2Tag, RegisterID regOp2Payload, int32_t op3)
 {
-    setupArgumentsWithExecState(TrustedImmPtr(identOp1), regOp2Payload, regOp2Tag, TrustedImm32(op3));
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(TrustedImmPtr(identOp1), TAGPAYLOADREGPAIR(regOp2Tag, regOp2Payload), TrustedImm32(op3));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_ESsiJJI operation, StructureStubInfo* stubInfo, RegisterID regOp1Tag, RegisterID regOp1Payload, RegisterID regOp2Tag, RegisterID regOp2Payload, StringImpl* uid)
 {
-    setupArgumentsWithExecState(TrustedImmPtr(stubInfo), regOp1Payload, regOp1Tag, regOp2Payload, regOp2Tag, TrustedImmPtr(uid));
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(TrustedImmPtr(stubInfo), TAGPAYLOADREGPAIR(regOp1Tag, regOp1Payload), TAGPAYLOADREGPAIR(regOp2Tag, regOp2Payload), TrustedImmPtr(uid));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_EJJJ operation, RegisterID regOp1Tag, RegisterID regOp1Payload, RegisterID regOp2Tag, RegisterID regOp2Payload, RegisterID regOp3Tag, RegisterID regOp3Payload)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG regOp1Payload, regOp1Tag, SH4_32BIT_DUMMY_ARG regOp2Payload, regOp2Tag, regOp3Payload, regOp3Tag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    dprint("JIT@% 3d: " __FILE__ ":%d: regT5/r17: 0x%08x\n", getgencount(), __LINE__, regT5);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(regOp1Tag, regOp1Payload), SH4_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(regOp2Tag, regOp2Payload), TAGPAYLOADREGPAIR(regOp3Tag, regOp3Payload));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_EJZ operation, RegisterID regOp1Tag, RegisterID regOp1Payload, int32_t op2)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG regOp1Payload, regOp1Tag, TrustedImm32(op2));
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(regOp1Tag, regOp1Payload), TrustedImm32(op2));
     return appendCallWithExceptionCheck(operation);
 }
 
 ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(V_JITOperation_EJZJ operation, RegisterID regOp1Tag, RegisterID regOp1Payload, int32_t op2, RegisterID regOp3Tag, RegisterID regOp3Payload)
 {
-    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG regOp1Payload, regOp1Tag, TrustedImm32(op2), EABI_32BIT_DUMMY_ARG regOp3Payload, regOp3Tag);
+    dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+    setupArgumentsWithExecState(EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(regOp1Tag, regOp1Payload), TrustedImm32(op2), EABI_32BIT_DUMMY_ARG TAGPAYLOADREGPAIR(regOp3Tag, regOp3Payload));
     return appendCallWithExceptionCheck(operation);
 }
 
@@ -563,6 +649,8 @@
 
 ALWAYS_INLINE void JIT::addSlowCase(Jump jump)
 {
+	COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+
     ASSERT(m_bytecodeOffset != (unsigned)-1); // This method should only be called during hot/cold path generation, so that m_bytecodeOffset is set.
 
     m_slowCases.append(SlowCaseEntry(jump, m_bytecodeOffset));
@@ -570,6 +658,7 @@
 
 ALWAYS_INLINE void JIT::addSlowCase(JumpList jumpList)
 {
+	COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     ASSERT(m_bytecodeOffset != (unsigned)-1); // This method should only be called during hot/cold path generation, so that m_bytecodeOffset is set.
 
     const JumpList::JumpVector& jumpVector = jumpList.jumps();
@@ -580,6 +669,7 @@
 
 ALWAYS_INLINE void JIT::addSlowCase()
 {
+	COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     ASSERT(m_bytecodeOffset != (unsigned)-1); // This method should only be called during hot/cold path generation, so that m_bytecodeOffset is set.
     
     Jump emptyJump; // Doing it this way to make Windows happy.
@@ -681,6 +771,8 @@
 }
 
 #if ENABLE(VALUE_PROFILER)
+extern int BreakOnInvalidValue;
+
 inline void JIT::emitValueProfilingSite(ValueProfile* valueProfile, RegisterID bucketCounterRegister)
 {
     ASSERT(shouldEmitProfiling());
@@ -699,8 +791,19 @@
         store64(value, valueProfile->m_buckets);
 #else
         EncodedValueDescriptor* descriptor = bitwise_cast<EncodedValueDescriptor*>(valueProfile->m_buckets);
+        dprint("JIT@% 3d: " __FILE__ ":%d: Storing tag 0x%08x payload 0x%08x\n", getgencount(), __LINE__, valueTag, value);
         store32(value, &descriptor->asBits.payload);
         store32(valueTag, &descriptor->asBits.tag);
+
+        if (BreakOnInvalidValue)
+        {
+            Jump jump1 = branch32(Above, valueTag, TrustedImm32(0xfffffff0));
+            Jump jump2 = branch32(NotEqual, value, TrustedImm32(0xfffffffb));
+            dprint("JIT@% 3d: " __FILE__ ":%d: Breakpoint\n", getgencount(), __LINE__);
+            breakpoint();
+            jump1.link(this);
+            jump2.link(this);
+        }
 #endif
         return;
     }
@@ -714,6 +817,7 @@
 #if USE(JSVALUE64)
     store64(value, BaseIndex(scratch, bucketCounterRegister, TimesEight));
 #elif USE(JSVALUE32_64)
+    dprint("JIT@% 3d: " __FILE__ ":%d: Storing tag 0x%08x payload 0x%08x\n", getgencount(), __LINE__, valueTag, value);
     store32(value, BaseIndex(scratch, bucketCounterRegister, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
     store32(valueTag, BaseIndex(scratch, bucketCounterRegister, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 #endif
@@ -879,6 +983,7 @@
 
 inline void JIT::emitStore(int index, RegisterID tag, RegisterID payload, RegisterID base)
 {
+    dprint("JIT@% 3d: Storing to %d: 0x%08x:0x%08x\n", getgencount(), index, tag, payload);
     store32(payload, payloadFor(index, base));
     store32(tag, tagFor(index, base));
 }
@@ -899,9 +1004,13 @@
 
 inline void JIT::emitStoreCell(int index, RegisterID payload, bool indexIsCell)
 {
+    dprint("JIT@% 3d: Storing cell to %d: 0xfffffffb:0x%08x\n", getgencount(), index, payload);
+
     store32(payload, payloadFor(index, callFrameRegister));
     if (!indexIsCell)
+    {
         store32(TrustedImm32(JSValue::CellTag), tagFor(index, callFrameRegister));
+    }
 }
 
 inline void JIT::emitStoreBool(int index, RegisterID payload, bool indexIsBool)
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITOpcodes.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITOpcodes.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITOpcodes.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITOpcodes.cpp	2018-06-12 14:28:02.353668859 +0000
@@ -71,6 +71,7 @@
 
 void JIT::emit_op_end(Instruction* currentInstruction)
 {
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     RELEASE_ASSERT(returnValueGPR != callFrameRegister);
     emitGetVirtualRegister(currentInstruction[1].u.operand, returnValueGPR);
     restoreReturnAddressBeforeReturn(Address(callFrameRegister, CallFrame::returnPCOffset()));
@@ -255,26 +256,36 @@
 
 void JIT::emit_op_ret(Instruction* currentInstruction)
 {
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+	foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+
     ASSERT(callFrameRegister != regT1);
     ASSERT(regT1 != returnValueGPR);
     ASSERT(returnValueGPR != callFrameRegister);
 
+	foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     // Return the result in %eax.
     emitGetVirtualRegister(currentInstruction[1].u.operand, returnValueGPR);
 
+	foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     // Grab the return address.
     emitGetReturnPCFromCallFrameHeaderPtr(regT1);
 
+	foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     // Restore our caller's "r".
     emitGetCallerFrameFromCallFrameHeaderPtr(callFrameRegister);
 
+	foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     // Return.
     restoreReturnAddressBeforeReturn(regT1);
+	foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     ret();
 }
 
 void JIT::emit_op_ret_object_or_this(Instruction* currentInstruction)
 {
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
+
     ASSERT(callFrameRegister != regT1);
     ASSERT(regT1 != returnValueGPR);
     ASSERT(returnValueGPR != callFrameRegister);
@@ -497,6 +508,7 @@
     // We could inline the case where you have a valid cache, but
     // this call doesn't seem to be hot.
     Label isObject(this);
+    dprint("JIT@% 3d: " __FILE__ ":%d: regT0 = 0x%08x\n", getgencount(), __LINE__, regT0);
     callOperation(operationGetPNames, regT0);
     emitStoreCell(dst, returnValueGPR);
     load32(Address(regT0, OBJECT_OFFSETOF(JSPropertyNameIterator, m_jsStringsSize)), regT3);
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITOpcodes32_64.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITOpcodes32_64.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITOpcodes32_64.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITOpcodes32_64.cpp	2018-06-26 10:03:33.095606030 +0000
@@ -48,6 +48,8 @@
 {
     Call nativeCall;
 
+	dprint("JIT@% 3d: " __FILE__ ":%d/privateCompileCTINativeCall(): Starting\n", getgencount(), __LINE__, regT0);
+
     emitPutImmediateToCallFrameHeader(0, JSStack::CodeBlock);
     storePtr(callFrameRegister, &m_vm->topCallFrame);
 
@@ -67,20 +69,24 @@
 
     subPtr(TrustedImm32(16 - sizeof(void*)), stackPointerRegister); // Align stack after call.
 
+    dprint("JIT@% 3d: " __FILE__ ":%d: Old Call Frame is 0x%08x\n", getgencount(), __LINE__, PPCRegisters::r14);
     move(regT0, callFrameRegister); // Eagerly restore caller frame register to avoid loading from stack.
+    dprint("JIT@% 3d: " __FILE__ ":%d: New Call Frame is 0x%08x\n", getgencount(), __LINE__, PPCRegisters::r14);
 
     // call the function
     nativeCall = call();
 
     addPtr(TrustedImm32(16 - sizeof(void*)), stackPointerRegister);
 
-#elif CPU(ARM) || CPU(SH4) || CPU(MIPS)
+#elif CPU(ARM) || CPU(SH4) || CPU(MIPS) || CPU(PPC)
     // Load caller frame's scope chain into this callframe so that whatever we call can get to its global data.
     emitGetCallerFrameFromCallFrameHeaderPtr(regT2);
     emitGetFromCallFrameHeaderPtr(JSStack::ScopeChain, regT1, regT2);
     emitPutCellToCallFrameHeader(regT1, JSStack::ScopeChain);
 
+    dprint("JIT@% 3d: " __FILE__ ":%d: Saving return address\n", getgencount(), __LINE__);
     preserveReturnAddressAfterCall(regT3); // Callee preserved
+    dprint("JIT@% 3d: " __FILE__ ":%d: Return address is 0x%08x\n", getgencount(), __LINE__, regT3);
     emitPutReturnPCToCallFrameHeader(regT3);
 
 #if CPU(MIPS)
@@ -93,12 +99,19 @@
     move(callFrameRegister, argumentGPR0);
 
     emitGetFromCallFrameHeaderPtr(JSStack::Callee, argumentGPR1);
+    dprint("JIT@% 3d: " __FILE__ ":%d: Old Call Frame is 0x%08x\n", getgencount(), __LINE__, PPCRegisters::r14);
     move(regT2, callFrameRegister); // Eagerly restore caller frame register to avoid loading from stack.
+    dprint("JIT@% 3d: " __FILE__ ":%d: New Call Frame is 0x%08x\n", getgencount(), __LINE__, PPCRegisters::r14);
     loadPtr(Address(argumentGPR1, OBJECT_OFFSETOF(JSFunction, m_executable)), regT2);
 
     // call the function
     nativeCall = call();
 
+#if CPU(BIG_ENDIAN)
+    /* This function is only used to call functions that return 64 bit values, so we can do the endian hack here */
+    swap(regT0, regT1);
+#endif
+
 #if CPU(MIPS)
     // Restore stack space
     addPtr(TrustedImm32(16), stackPointerRegister);
@@ -113,12 +126,15 @@
     // Check for an exception
     Jump sawException = branch32(NotEqual, AbsoluteAddress(reinterpret_cast<char*>(vm->addressOfException()) + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), TrustedImm32(JSValue::EmptyValueTag)); 
 
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d: End of privateCompileCTINativeCall without exception, regT1 0x%08x, regT0 0x%08x\n", getgencount(), __LINE__, regT1, regT0);
     // Return.
     ret();
 
     // Handle an exception
     sawException.link(this);
 
+	dprint("JIT@% 3d: " __FILE__ ":%d: Got exception\n", getgencount(), __LINE__, regT0);
+
     // Grab the return address.
     preserveReturnAddressAfterCall(regT1);
 
@@ -126,6 +142,8 @@
     storePtr(regT1, regT2);
     storePtr(callFrameRegister, &m_vm->topCallFrame);
 
+	COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+
 #if CPU(X86)
     addPtr(TrustedImm32(-12), stackPointerRegister);
     push(callFrameRegister);
@@ -152,11 +170,14 @@
 {
     int dst = currentInstruction[1].u.operand;
     int src = currentInstruction[2].u.operand;
+
+    dprint("JIT@ xxx: Moving from %d to %d\n", src, dst);
     
     if (m_codeBlock->isConstantRegisterIndex(src))
         emitStore(dst, getConstantOperand(src));
     else {
         emitLoad(src, regT1, regT0);
+    dprint("JIT@% 3d: " __FILE__ ":%d: Moving value 0x%08x 0x%08x\n", getgencount(), __LINE__, regT1, regT0);
         emitStore(dst, regT1, regT0);
     }
 }
@@ -175,6 +196,8 @@
 {
     ASSERT(returnValueGPR != callFrameRegister);
     emitLoad(currentInstruction[1].u.operand, regT1, regT0);
+
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
     restoreReturnAddressBeforeReturn(Address(callFrameRegister, CallFrame::returnPCOffset()));
     ret();
 }
@@ -197,6 +220,9 @@
 
     move(TrustedImmPtr(allocator), allocatorReg);
     emitAllocateJSObject(allocatorReg, TrustedImmPtr(structure), resultReg, scratchReg);
+
+	dprint("JIT@% 3d: op_new_object: stored in %d: Result %08x\n", getgencount(), currentInstruction[1].u.operand, resultReg);
+
     emitStoreCell(currentInstruction[1].u.operand, resultReg);
 }
 
@@ -337,8 +363,11 @@
     int value = currentInstruction[2].u.operand;
     
     emitLoadTag(value, regT0);
+    dprint("JIT@% 3d: op_is_number: tag %08x\n", getgencount(), regT0);
     add32(TrustedImm32(1), regT0);
+    dprint("JIT@% 3d: op_is_number: Comparing %08x to 0xfffffffa\n", getgencount(), regT0);
     compare32(Below, regT0, TrustedImm32(JSValue::LowestTag + 1), regT0);
+    dprint("JIT@% 3d: op_is_number: result is %08x\n", getgencount(), regT0);
     emitStoreBool(dst, regT0);
 }
 
@@ -440,6 +469,8 @@
 
     emitLoad(cond, regT1, regT0);
 
+	dprint("JIT@% 3d: op_jfalse: after tag %08x payload %08x\n", getgencount(), regT1, regT0);
+
     ASSERT((JSValue::BooleanTag + 1 == JSValue::Int32Tag) && !(JSValue::Int32Tag + 1));
     addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::BooleanTag)));
     addJump(branchTest32(Zero, regT0), target);
@@ -452,11 +483,14 @@
 
     linkSlowCase(iter);
 
+	dprint("JIT@% 3d: op_jfalse: Slow path\n", getgencount());
+
     if (supportsFloatingPoint()) {
         // regT1 contains the tag from the hot path.
         Jump notNumber = branch32(Above, regT1, TrustedImm32(JSValue::LowestTag));
 
         emitLoadDouble(cond, fpRegT0);
+	dprint("JIT@% 3d: op_jfalse: Loaded %f\n", getgencount(), fpRegT0);
         emitJumpSlowToHot(branchDoubleZeroOrNaN(fpRegT0, fpRegT1), target);
         emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jfalse));
 
@@ -474,8 +508,11 @@
 
     emitLoad(cond, regT1, regT0);
 
+	dprint("JIT@% 3d: op_jtrue: tag %08x payload %08x\n", getgencount(), regT1, regT0);
+
     ASSERT((JSValue::BooleanTag + 1 == JSValue::Int32Tag) && !(JSValue::Int32Tag + 1));
     addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::BooleanTag)));
+	dprint("JIT@% 3d: op_jtrue: fast path\n", getgencount(), regT1, regT0);
     addJump(branchTest32(NonZero, regT0), target);
 }
 
@@ -486,13 +523,18 @@
 
     linkSlowCase(iter);
 
+	dprint("JIT@% 3d: op_jtrue: slow path\n", getgencount(), regT1, regT0);
+
     if (supportsFloatingPoint()) {
         // regT1 contains the tag from the hot path.
         Jump notNumber = branch32(Above, regT1, TrustedImm32(JSValue::LowestTag));
 
         emitLoadDouble(cond, fpRegT0);
+	dprint("JIT@% 3d: op_jtrue: Loaded double %f\n", getgencount(), fpRegT0);
         emitJumpSlowToHot(branchDoubleNonZero(fpRegT0, fpRegT1), target);
+	dprint("JIT@% 3d: op_jtrue: What\n", getgencount());
         emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jtrue));
+	dprint("JIT@% 3d: op_jtrue: The\n", getgencount());
 
         notNumber.link(this);
     }
@@ -570,13 +612,24 @@
     int src1 = currentInstruction[2].u.operand;
     int src2 = currentInstruction[3].u.operand;
 
+	dprint("JIT@% 3d: op_eq: src1 %d\n", getgencount(), src1);
+	dprint("JIT@% 3d: op_eq: src2 %d\n", getgencount(), src2);
+
     emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
+	dprint("JIT@% 3d: op_eq: src1: tag %08x payload %08x\n", getgencount(), regT1, regT0);
+	dprint("JIT@% 3d: op_eq: src2: tag %08x payload %08x\n", getgencount(), regT3, regT2);
     addSlowCase(branch32(NotEqual, regT1, regT3));
     addSlowCase(branch32(Equal, regT1, TrustedImm32(JSValue::CellTag)));
     addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::LowestTag)));
 
+	dprint("JIT@% 3d: op_eq: fast path\n", getgencount());
+
+	dprint("JIT@% 3d: op_eq: regT0 %08x regT2 %08x\n", getgencount(), regT0, regT2);
+
     compare32(Equal, regT0, regT2, regT0);
 
+	dprint("JIT@% 3d: op_eq: result %08x\n", getgencount(), regT0);
+
     emitStoreBool(dst, regT0);
 }
 
@@ -595,6 +648,8 @@
     genericCase.append(branchPtr(NotEqual, Address(regT0, JSCell::structureOffset()), TrustedImmPtr(m_vm->stringStructure.get())));
     genericCase.append(branchPtr(NotEqual, Address(regT2, JSCell::structureOffset()), TrustedImmPtr(m_vm->stringStructure.get())));
 
+	dprint("JIT@% 3d: op_eq: slow path\n", getgencount());
+
     // String case.
     callOperation(operationCompareStringEq, regT0, regT2);
     storeResult.append(jump());
@@ -602,6 +657,7 @@
     // Generic case.
     genericCase.append(getSlowCase(iter)); // doubles
     genericCase.link(this);
+	dprint("JIT@% 3d: op_eq: generic path\n", getgencount());
     emitLoad(op1, regT1, regT0);
     emitLoad(op2, regT3, regT2);
     callOperation(operationCompareEq, regT1, regT0, regT3, regT2);
@@ -617,10 +673,14 @@
     int src2 = currentInstruction[3].u.operand;
 
     emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
+    dprint("JIT@% 3d: op_neq: 0: tag 0x%08x payload 0x%08x\n", getgencount(), regT1, regT0);
+    dprint("JIT@% 3d: op_neq: 1: tag 0x%08x payload 0x%08x\n", getgencount(), regT3, regT2);
     addSlowCase(branch32(NotEqual, regT1, regT3));
     addSlowCase(branch32(Equal, regT1, TrustedImm32(JSValue::CellTag)));
     addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::LowestTag)));
 
+    dprint("JIT@% 3d: op_neq: Doing compare32()\n", getgencount());
+
     compare32(NotEqual, regT0, regT2, regT0);
 
     emitStoreBool(dst, regT0);
@@ -636,9 +696,12 @@
     genericCase.append(getSlowCase(iter)); // tags not equal
 
     linkSlowCase(iter); // tags equal and JSCell
+    dprint("JIT@% 3d: op_neq: Slow path\n", getgencount());
     genericCase.append(branchPtr(NotEqual, Address(regT0, JSCell::structureOffset()), TrustedImmPtr(m_vm->stringStructure.get())));
     genericCase.append(branchPtr(NotEqual, Address(regT2, JSCell::structureOffset()), TrustedImmPtr(m_vm->stringStructure.get())));
 
+    dprint("JIT@% 3d: op_neq: String case\n", getgencount());
+
     // String case.
     callOperation(operationCompareStringEq, regT0, regT2);
     storeResult.append(jump());
@@ -646,10 +709,13 @@
     // Generic case.
     genericCase.append(getSlowCase(iter)); // doubles
     genericCase.link(this);
+    dprint("JIT@% 3d: op_neq: Generic case\n", getgencount());
     callOperation(operationCompareEq, regT1, regT0, regT3, regT2);
 
     storeResult.link(this);
+    dprint("JIT@% 3d: op_neq: Done, 0x%08x\n", getgencount(), returnValueGPR);
     xor32(TrustedImm32(0x1), returnValueGPR);
+    dprint("JIT@% 3d: op_neq: Result 0x%08x\n", getgencount(), returnValueGPR);
     emitStoreBool(dst, returnValueGPR);
 }
 
@@ -775,6 +841,8 @@
 
 void JIT::emit_op_throw(Instruction* currentInstruction)
 {
+	COMPILEDPRINTF("%s:%d/%s:\n", __FILE__, __LINE__, __func__);
+
     ASSERT(regT0 == returnValueGPR);
     emitLoad(currentInstruction[1].u.operand, regT1, regT0);
     callOperationNoExceptionCheck(operationThrow, regT1, regT0);
@@ -792,6 +860,7 @@
     JumpList isNotObject;
 
     emitLoad(base, regT1, regT0);
+    dprint("JIT@% 3d: " __FILE__ ":%d: regT1 = 0x%08x, regT0 = 0x%08x\n", getgencount(), __LINE__, regT1, regT0);
     if (!m_codeBlock->isKnownNotImmediate(base))
         isNotObject.append(branch32(NotEqual, regT1, TrustedImm32(JSValue::CellTag)));
     if (VirtualRegister(base) != m_codeBlock->thisRegister() || m_codeBlock->isStrictMode()) {
@@ -802,6 +871,7 @@
     // We could inline the case where you have a valid cache, but
     // this call doesn't seem to be hot.
     Label isObject(this);
+    dprint("JIT@% 3d: " __FILE__ ":%d: regT0 = 0x%08x\n", getgencount(), __LINE__, regT0);
     callOperation(operationGetPNames, regT0);
     emitStoreCell(dst, returnValueGPR);
     load32(Address(regT0, OBJECT_OFFSETOF(JSPropertyNameIterator, m_jsStringsSize)), regT3);
@@ -809,12 +879,16 @@
     store32(TrustedImm32(0), intPayloadFor(i));
     store32(TrustedImm32(Int32Tag), intTagFor(size));
     store32(regT3, payloadFor(size));
+    dprint("JIT@% 3d: property count %08x\n", getgencount(), regT3);
     Jump end = jump();
 
     isNotObject.link(this);
+    dprint("JIT@% 3d: Isn't an object\n", getgencount());
+
     addJump(branch32(Equal, regT1, TrustedImm32(JSValue::NullTag)), breakTarget);
     addJump(branch32(Equal, regT1, TrustedImm32(JSValue::UndefinedTag)), breakTarget);
     callOperation(operationToObject, base, regT1, regT0);
+    dprint("JIT@% 3d: " __FILE__ ":%d: New regT1 = 0x%08x, regT0 = 0x%08x\n", getgencount(), __LINE__, regT1, regT0);
     jump().linkTo(isObject, this);
 
     end.link(this);
@@ -832,13 +906,27 @@
     JumpList callHasProperty;
 
     Label begin(this);
+
+    load32(intPayloadFor(size), regT0);
+
+    dprint("JIT@% 3d: property count %08x\n", getgencount(), regT0);
+
     load32(intPayloadFor(i), regT0);
+
+    dprint("JIT@% 3d: property num %08x\n", getgencount(), regT0);
+
     Jump end = branch32(Equal, regT0, intPayloadFor(size));
 
     // Grab key @ i
     loadPtr(payloadFor(it), regT1);
+
+    dprint("JIT@% 3d: Iterator %08x\n", getgencount(), regT1);
+
     loadPtr(Address(regT1, OBJECT_OFFSETOF(JSPropertyNameIterator, m_jsStrings)), regT2);
-    load32(BaseIndex(regT2, regT0, TimesEight), regT2);
+    load32(BaseIndex(regT2, regT0, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)), regT2);
+
+    dprint("JIT@% 3d: regT2 %08x\n", getgencount(), regT2);
+
     store32(TrustedImm32(JSValue::CellTag), tagFor(dst));
     store32(regT2, payloadFor(dst));
 
@@ -871,7 +959,7 @@
 
     // Slow case: Ask the object if i is valid.
     callHasProperty.link(this);
-    loadPtr(addressFor(dst), regT1);
+    loadPtr(payloadFor(dst), regT1);
     callOperation(operationHasProperty, regT0, regT1);
 
     // Test for valid key.
@@ -1051,6 +1139,8 @@
 {
     int dst = currentInstruction[1].u.operand;
 
+	dprint("JIT@% 3d: init_lazy_reg: stored in %dx\n", getgencount(), dst);
+
     emitStore(dst, JSValue());
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITOperationWrappers.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITOperationWrappers.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITOperationWrappers.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITOperationWrappers.h	2018-06-12 14:28:02.357668892 +0000
@@ -326,6 +326,73 @@
 #define _J_FUNCTION_WRAPPER_WITH_RETURN_ADDRESS_EJI(function)  FUNCTION_WRAPPER_WITH_RETURN_ADDRESS(function, 0, SH4_SCRATCH_REGISTER)
 #define _V_FUNCTION_WRAPPER_WITH_RETURN_ADDRESS_EJJI(function) FUNCTION_WRAPPER_WITH_RETURN_ADDRESS(function, 8, SH4_SCRATCH_REGISTER)
 
+#elif COMPILER(GCC) && CPU(PPC)
+
+#define _J_FUNCTION_WRAPPER_WITH_RETURN_ADDRESS_E(function) \
+    asm ( \
+    ".text" "\n" \
+    ".globl " SYMBOL_STRING(function) "\n" \
+    HIDE_SYMBOL(function) "\n" \
+    SYMBOL_STRING(function) ":" "\n" \
+	"stwu %r1,-16(%r1)" "\n" \
+	"mflr %r4" "\n" \
+	"stw %r4,20(%r1)" "\n" \
+	"addi %r4,%r1,20" "\n" \
+        "b " LOCAL_REFERENCE(function) "WithReturnAddress" "\n" \
+    );
+
+#define _J_FUNCTION_WRAPPER_WITH_RETURN_ADDRESS_ECI(function) \
+    asm ( \
+    ".text" "\n" \
+    ".globl " SYMBOL_STRING(function) "\n" \
+    HIDE_SYMBOL(function) "\n" \
+    SYMBOL_STRING(function) ":" "\n" \
+	"stwu %r1,-16(%r1)" "\n" \
+	"mflr %r6" "\n" \
+	"stw %r6,20(%r1)" "\n" \
+	"addi %r6,%r1,20" "\n" \
+        "b " LOCAL_REFERENCE(function) "WithReturnAddress" "\n" \
+    );
+
+#define _J_FUNCTION_WRAPPER_WITH_RETURN_ADDRESS_EJI(function) \
+    asm ( \
+    ".text" "\n" \
+    ".globl " SYMBOL_STRING(function) "\n" \
+    HIDE_SYMBOL(function) "\n" \
+    SYMBOL_STRING(function) ":" "\n" \
+	"stwu %r1,-16(%r1)" "\n" \
+	"mflr %r8" "\n" \
+	"stw %r8,20(%r1)" "\n" \
+	"addi %r8,%r1,20" "\n" \
+        "b " LOCAL_REFERENCE(function) "WithReturnAddress" "\n" \
+    );
+
+#define _V_FUNCTION_WRAPPER_WITH_RETURN_ADDRESS_EJJI(function) \
+    asm ( \
+    ".text" "\n" \
+    ".globl " SYMBOL_STRING(function) "\n" \
+    HIDE_SYMBOL(function) "\n" \
+    SYMBOL_STRING(function) ":" "\n" \
+	"stwu %r1,-16(%r1)" "\n" \
+	"mflr %r10" "\n" \
+	"stw %r10,20(%r1)" "\n" \
+	"addi %r10,%r1,20" "\n" \
+        "b " LOCAL_REFERENCE(function) "WithReturnAddress" "\n" \
+    );
+
+#define _V_FUNCTION_WRAPPER_WITH_RETURN_ADDRESS_EJCI(function) \
+    asm ( \
+    ".text" "\n" \
+    ".globl " SYMBOL_STRING(function) "\n" \
+    HIDE_SYMBOL(function) "\n" \
+    SYMBOL_STRING(function) ":" "\n" \
+	"stwu %r1,-16(%r1)" "\n" \
+	"mflr %r9" "\n" \
+	"stw %r9,20(%r1)" "\n" \
+	"addi %r9,%r1,20" "\n" \
+        "b " LOCAL_REFERENCE(function) "WithReturnAddress" "\n" \
+    );
+
 #elif COMPILER(MSVC) && CPU(X86)
 
 #define _J_FUNCTION_WRAPPER_WITH_RETURN_ADDRESS_EJI(function) \
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITOperations.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITOperations.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITOperations.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITOperations.cpp	2018-07-17 12:44:39.867953766 +0000
@@ -119,6 +119,7 @@
 
 EncodedJSValue JIT_OPERATION operationGetById(ExecState* exec, StructureStubInfo*, EncodedJSValue base, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -130,6 +131,7 @@
 
 EncodedJSValue JIT_OPERATION operationGetByIdBuildList(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
 
@@ -148,6 +150,7 @@
 
 EncodedJSValue JIT_OPERATION operationGetByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): base 0x%016llx\n", __FILE__, __LINE__, __func__, base);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     Identifier ident = uid->isEmptyUnique() ? Identifier::from(PrivateName(uid)) : Identifier(vm, uid);
@@ -157,18 +160,21 @@
     PropertySlot slot(baseValue);
     JSValue result = baseValue.get(exec, ident, slot);
     
-    if (accessType == static_cast<AccessType>(stubInfo->accessType)) {
+#warning Remove this 0 && again, it is here for testing
+    if (0 && accessType == static_cast<AccessType>(stubInfo->accessType)) {
         if (stubInfo->seen)
             repatchGetByID(exec, baseValue, ident, slot, *stubInfo);
         else
             stubInfo->seen = true;
     }
 
+    CALLBACKDPRINTF("%s:%d/%s(): Done, returning 0x%016llx\n", __FILE__, __LINE__, __func__, JSValue::encode(result));
     return JSValue::encode(result);
 }
 
 EncodedJSValue JIT_OPERATION operationInOptimize(ExecState* exec, StructureStubInfo* stubInfo, JSCell* base, StringImpl* key)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -195,6 +201,7 @@
 
 EncodedJSValue JIT_OPERATION operationIn(ExecState* exec, StructureStubInfo*, JSCell* base, StringImpl* key)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
 
@@ -209,6 +216,7 @@
 
 EncodedJSValue JIT_OPERATION operationGenericIn(ExecState* exec, JSCell* base, EncodedJSValue key)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
 
@@ -217,24 +225,37 @@
 
 EncodedJSValue JIT_OPERATION operationCallCustomGetter(ExecState* exec, JSCell* base, PropertySlot::GetValueFunc function, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
+    unsigned long long ret;
     
     Identifier ident(vm, uid);
     
-    return function(exec, JSValue::encode(base), JSValue::encode(base), ident);
+    ret = function(exec, JSValue::encode(base), JSValue::encode(base), ident);
+    ret = (ret<<32)|(ret>>32);
+    return ret;
 }
 
 EncodedJSValue JIT_OPERATION operationCallGetter(ExecState* exec, JSCell* base, JSCell* getterSetter)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, base 0x%08x, getterSetter 0x%08x\n", __FILE__, __LINE__, __func__, exec, base, getterSetter);
+    EncodedJSValue ret;
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
 
-    return JSValue::encode(callGetter(exec, base, getterSetter));
+    ret = JSValue::encode_endian_workaround(callGetter(exec, base, getterSetter));
+
+#if 0
+    CALLBACKDPRINTF("%s:%d/%s(): ret = 0x%016llx\n", __FILE__, __LINE__, __func__, ret);
+#endif
+
+    return ret;
 }
 
 void JIT_OPERATION operationPutByIdStrict(ExecState* exec, StructureStubInfo*, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -245,6 +266,7 @@
 
 void JIT_OPERATION operationPutByIdNonStrict(ExecState* exec, StructureStubInfo*, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -255,6 +277,7 @@
 
 void JIT_OPERATION operationPutByIdDirectStrict(ExecState* exec, StructureStubInfo*, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -265,6 +288,7 @@
 
 void JIT_OPERATION operationPutByIdDirectNonStrict(ExecState* exec, StructureStubInfo*, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -275,6 +299,7 @@
 
 void JIT_OPERATION operationPutByIdStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, stubInfo 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, stubInfo, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -298,6 +323,7 @@
 
 void JIT_OPERATION operationPutByIdNonStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, stubInfo 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, stubInfo, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -321,6 +347,7 @@
 
 void JIT_OPERATION operationPutByIdDirectStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, stubInfo 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, stubInfo, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -344,6 +371,7 @@
 
 void JIT_OPERATION operationPutByIdDirectNonStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, stubInfo 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, stubInfo, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -367,6 +395,7 @@
 
 void JIT_OPERATION operationPutByIdStrictBuildList(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, stubInfo 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, stubInfo, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -387,6 +416,7 @@
 
 void JIT_OPERATION operationPutByIdNonStrictBuildList(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, stubInfo 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, stubInfo, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -407,6 +437,7 @@
 
 void JIT_OPERATION operationPutByIdDirectStrictBuildList(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, stubInfo 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, stubInfo, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -427,6 +458,7 @@
 
 void JIT_OPERATION operationPutByIdDirectNonStrictBuildList(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, StringImpl* uid)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, stubInfo 0x%08x, encodedValue 0x%016llx, encodedBase 0x%016llx, uid 0x%08x\n", __FILE__, __LINE__, __func__, exec, stubInfo, encodedValue, encodedBase, uid);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -447,6 +479,7 @@
 
 void JIT_OPERATION operationReallocateStorageAndFinishPut(ExecState* exec, JSObject* base, Structure* structure, PropertyOffset offset, EncodedJSValue value)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, base 0x%08x, structure 0x%08x, offset %d, value 0x%016llx\n", __FILE__, __LINE__, __func__, exec, base, structure, offset, value);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
 
@@ -458,6 +491,7 @@
 
 static void putByVal(CallFrame* callFrame, JSValue baseValue, JSValue subscript, JSValue value)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     if (LIKELY(subscript.isUInt32())) {
         uint32_t i = subscript.asUInt32();
         if (baseValue.isObject()) {
@@ -478,6 +512,7 @@
             baseValue.put(callFrame, property, value, slot);
         }
     }
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
 }
 
 static void directPutByVal(CallFrame* callFrame, JSObject* baseObject, JSValue subscript, JSValue value)
@@ -501,11 +536,18 @@
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
 
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+
     JSValue baseValue = JSValue::decode(encodedBaseValue);
     JSValue subscript = JSValue::decode(encodedSubscript);
     JSValue value = JSValue::decode(encodedValue);
 
+    CALLBACKDPRINTF("%s:%d/%s(): baseValue 0x%016llx\n", __FILE__, __LINE__, __func__, encodedBaseValue);
+    CALLBACKDPRINTF("%s:%d/%s(): subscript 0x%016llx\n", __FILE__, __LINE__, __func__, encodedSubscript);
+    CALLBACKDPRINTF("%s:%d/%s(): value 0x%016llx\n", __FILE__, __LINE__, __func__, encodedValue);
+
     if (baseValue.isObject() && subscript.isInt32()) {
+        CALLBACKDPRINTF("%s:%d/%s(): object + int32\n", __FILE__, __LINE__, __func__);
         // See if it's worth optimizing at all.
         JSObject* object = asObject(baseValue);
         bool didOptimize = false;
@@ -539,7 +581,9 @@
         }
     }
 
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     putByVal(exec, baseValue, subscript, value);
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
 }
 
 void JIT_OPERATION operationDirectPutByVal(ExecState* callFrame, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
@@ -614,6 +658,7 @@
 
 EncodedJSValue JIT_OPERATION operationCallEval(ExecState* execCallee)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     CallFrame* callerFrame = execCallee->callerFrame();
     ASSERT(execCallee->callerFrame()->codeBlock()->codeType() != FunctionCode
         || !execCallee->callerFrame()->codeBlock()->needsFullScopeChain()
@@ -624,13 +669,20 @@
     execCallee->setCodeBlock(0);
 
     if (!isHostFunction(execCallee->calleeAsValue(), globalFuncEval))
+    {
+    CALLBACKDPRINTF("%s:%d/%s(): !isHostFunction\n", __FILE__, __LINE__, __func__);
         return JSValue::encode(JSValue());
+    }
 
     VM* vm = &execCallee->vm();
     JSValue result = eval(execCallee);
     if (vm->exception())
+    {
+        CALLBACKDPRINTF("%s:%d/%s(): exception\n", __FILE__, __LINE__, __func__);
         return EncodedJSValue();
+    }
     
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     return JSValue::encode(result);
 }
 
@@ -650,6 +702,7 @@
     
         if (callType == CallTypeHost) {
             NativeCallFrameTracer tracer(vm, execCallee);
+            CALLBACKDPRINTF("%s:%d/%s(): setCallee(0x%016llx)\n", __FILE__, __LINE__, __func__, JSValue::encode(callee));
             execCallee->setCallee(asObject(callee));
             vm->hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));
             if (vm->exception())
@@ -672,6 +725,7 @@
     
     if (constructType == ConstructTypeHost) {
         NativeCallFrameTracer tracer(vm, execCallee);
+        CALLBACKDPRINTF("%s:%d/%s(): setCallee(0x%016llx)\n", __FILE__, __LINE__, __func__, JSValue::encode(callee));
         execCallee->setCallee(asObject(callee));
         vm->hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));
         if (vm->exception())
@@ -691,6 +745,7 @@
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
+    CALLBACKDPRINTF("%s:%d/%s(): execCallee 0x%08x, &JSStack::Callee: 0x%08x, JSStack::Callee: 0x%016llx\n", __FILE__, __LINE__, __func__, execCallee, execCallee->calleeAsAddress(), execCallee->calleeAsEncodedJSValue());
     JSValue calleeAsValue = execCallee->calleeAsValue();
     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
     if (!calleeAsFunctionCell)
@@ -858,6 +913,8 @@
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
+    CALLBACKDPRINTF("%s:%d/%s(): encodedOp 0x%016llx\n", __FILE__, __LINE__, __func__, encodedOp);
+
     return JSValue::decode(encodedOp).toBoolean(exec);
 }
 
@@ -866,6 +923,8 @@
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
 
+    CALLBACKDPRINTF("%s:%d/%s(): encodedOp1 0x%016llx, encodedOp2 0x%016llx\n", __FILE__, __LINE__, __func__, encodedOp1, encodedOp2);
+
     return JSValue::equalSlowCaseInline(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
 }
 
@@ -895,6 +954,7 @@
 
 EncodedJSValue JIT_OPERATION operationNewArrayWithProfile(ExecState* exec, ArrayAllocationProfile* profile, const JSValue* values, int size)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     return JSValue::encode(constructArrayNegativeIndexed(exec, profile, values, size));
@@ -902,6 +962,7 @@
 
 EncodedJSValue JIT_OPERATION operationNewArrayBufferWithProfile(ExecState* exec, ArrayAllocationProfile* profile, const JSValue* values, int size)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     return JSValue::encode(constructArray(exec, profile, values, size));
@@ -909,6 +970,7 @@
 
 EncodedJSValue JIT_OPERATION operationNewArrayWithSizeAndProfile(ExecState* exec, ArrayAllocationProfile* profile, EncodedJSValue size)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     JSValue sizeValue = JSValue::decode(size);
@@ -917,6 +979,7 @@
 
 EncodedJSValue JIT_OPERATION operationNewFunction(ExecState* exec, JSCell* functionExecutable)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     ASSERT(functionExecutable->inherits(FunctionExecutable::info()));
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
@@ -925,6 +988,7 @@
 
 JSCell* JIT_OPERATION operationNewObject(ExecState* exec, Structure* structure)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
     
@@ -933,6 +997,7 @@
 
 EncodedJSValue JIT_OPERATION operationNewRegexp(ExecState* exec, void* regexpPtr)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     RegExp* regexp = static_cast<RegExp*>(regexpPtr);
@@ -1312,6 +1377,7 @@
 
 EncodedJSValue JIT_OPERATION operationCheckHasInstance(ExecState* exec, EncodedJSValue encodedValue, EncodedJSValue encodedBaseVal)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
     NativeCallFrameTracer tracer(vm, exec);
 
@@ -1333,6 +1399,7 @@
 
 JSCell* JIT_OPERATION operationCreateActivation(ExecState* exec, int32_t offset)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     JSActivation* activation = JSActivation::create(vm, exec, exec->registers() + offset, exec->codeBlock());
@@ -1342,6 +1409,7 @@
 
 JSCell* JIT_OPERATION operationCreateArguments(ExecState* exec)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     // NB: This needs to be exceedingly careful with top call frame tracking, since it
@@ -1353,6 +1421,7 @@
 
 EncodedJSValue JIT_OPERATION operationGetArgumentsLength(ExecState* exec, int32_t argumentsRegister)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     // Here we can assume that the argumernts were created. Because otherwise the JIT code would
@@ -1367,6 +1436,7 @@
 
 static JSValue getByVal(ExecState* exec, JSValue baseValue, JSValue subscript, ReturnAddressPtr returnAddress)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     if (LIKELY(baseValue.isCell() && subscript.isString())) {
         if (JSValue result = baseValue.asCell()->fastGetOwnProperty(exec, asString(subscript)->value(exec)))
             return result;
@@ -1392,6 +1462,7 @@
     
 EncodedJSValue JIT_OPERATION operationGetByValGeneric(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     JSValue baseValue = JSValue::decode(encodedBase);
@@ -1403,6 +1474,7 @@
 
 EncodedJSValue JIT_OPERATION operationGetByValDefault(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     JSValue baseValue = JSValue::decode(encodedBase);
@@ -1448,6 +1520,7 @@
     
 EncodedJSValue JIT_OPERATION operationGetByValString(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     JSValue baseValue = JSValue::decode(encodedBase);
@@ -1494,6 +1567,7 @@
 
 EncodedJSValue JIT_OPERATION operationDeleteById(ExecState* exec, EncodedJSValue encodedBase, const Identifier* identifier)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
 
@@ -1519,6 +1593,7 @@
 
 EncodedJSValue JIT_OPERATION operationInstanceOf(ExecState* exec, EncodedJSValue encodedValue, EncodedJSValue encodedProto)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     JSValue value = JSValue::decode(encodedValue);
@@ -1552,6 +1627,7 @@
 
 EncodedJSValue JIT_OPERATION operationToObject(ExecState* exec, EncodedJSValue value)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     return JSValue::encode(JSValue::decode(value).toObject(exec));
@@ -1615,6 +1691,7 @@
 
 EncodedJSValue JIT_OPERATION operationResolveScope(ExecState* exec, int32_t identifierIndex)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     const Identifier& ident = exec->codeBlock()->identifier(identifierIndex);
@@ -1623,6 +1700,7 @@
 
 EncodedJSValue JIT_OPERATION operationGetFromScope(ExecState* exec, Instruction* bytecodePC)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     VM& vm = exec->vm();
     NativeCallFrameTracer tracer(&vm, exec);
     CodeBlock* codeBlock = exec->codeBlock();
@@ -1757,9 +1835,23 @@
 // requires it.
 extern "C" EncodedJSValue HOST_CALL_RETURN_VALUE_OPTION getHostCallReturnValueWithExecState(ExecState* exec)
 {
+    EncodedJSValue ret;
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x\n", __FILE__, __LINE__, __func__, exec);
     if (!exec)
-        return JSValue::encode(JSValue());
-    return JSValue::encode(exec->vm().hostCallReturnValue);
+    {
+        ret = JSValue::encode_endian_workaround(JSValue());
+    }
+    else
+    {
+        ret = JSValue::encode_endian_workaround(exec->vm().hostCallReturnValue);
+    }
+#if 0
+#warning Remove this too
+	ret = (ret<<32)|(ret>>32);
+#endif
+    CALLBACKDPRINTF("%s:%d/%s(): ret 0x%016llx\n", __FILE__, __LINE__, __func__, ret);
+
+    return ret;
 }
 
 #if COMPILER(GCC) && CPU(X86_64)
@@ -1848,6 +1940,17 @@
     "2: .long " LOCAL_REFERENCE(getHostCallReturnValueWithExecState) "-1b\n"
 );
 
+#elif COMPILER(GCC) && CPU(PPC)
+asm (
+".text" "\n"
+".globl " SYMBOL_STRING(getHostCallReturnValue) "\n"
+HIDE_SYMBOL(getHostCallReturnValue) "\n"
+SYMBOL_STRING(getHostCallReturnValue) ":" "\n"
+    "lwz %r14, 0(%r14)" "\n"
+    "mr %r3,%r14" "\n"
+    "b " LOCAL_REFERENCE(getHostCallReturnValueWithExecState) "\n"
+);
+
 #elif COMPILER(MSVC) && CPU(X86)
 extern "C" {
     __declspec(naked) EncodedJSValue HOST_CALL_RETURN_VALUE_OPTION getHostCallReturnValue()
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITPropertyAccess.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITPropertyAccess.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITPropertyAccess.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITPropertyAccess.cpp	2018-07-16 08:12:00.370088299 +0000
@@ -168,7 +168,10 @@
 {
     JumpList slowCases;
     
+        dprint("JIT@% 3d: emitContiguousGetByVal:\n", jit.getgencount());
+
     badType = patchableBranch32(NotEqual, regT2, TrustedImm32(expectedShape));
+        dprint("JIT@% 3d: emitContiguousGetByVal: after badType\n", jit.getgencount());
     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT2);
     slowCases.append(branch32(AboveOrEqual, regT1, Address(regT2, Butterfly::offsetOfPublicLength())));
     load64(BaseIndex(regT2, regT1, TimesEight), regT0);
@@ -181,6 +184,8 @@
 {
     JumpList slowCases;
 
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal:\n", jit.getgencount());
+
     add32(TrustedImm32(-ArrayStorageShape), regT2, regT3);
     badType = patchableBranch32(Above, regT3, TrustedImm32(SlowPutArrayStorageShape - ArrayStorageShape));
 
@@ -1046,11 +1051,14 @@
     PatchableJump badType;
     JumpList slowCases;
     
+        dprint("JIT@% 3d: JIT::privateCompileGetByVal:\n", getgencount());
+
     switch (arrayMode) {
     case JITInt32:
         slowCases = emitInt32GetByVal(currentInstruction, badType);
         break;
     case JITDouble:
+        dprint("JIT@% 3d: JIT::privateCompileGetByVal: JITDouble\n", getgencount());
         slowCases = emitDoubleGetByVal(currentInstruction, badType);
         break;
     case JITContiguous:
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITPropertyAccess32_64.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITPropertyAccess32_64.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITPropertyAccess32_64.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITPropertyAccess32_64.cpp	2018-07-17 12:07:38.127453683 +0000
@@ -83,6 +83,11 @@
 {
     JSInterfaceJIT jit(vm);
     JumpList failures;
+
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit.getgencount(), __LINE__);
+
+        jit.dprint("JIT@% 3d: op_get_by_val: stringGetByValStubGenerator\n", jit.getgencount());
+
     failures.append(jit.branchPtr(NotEqual, Address(regT0, JSCell::structureOffset()), TrustedImmPtr(vm->stringStructure.get())));
     
     // Load string length to regT1, and start the process of loading the data pointer into regT0
@@ -129,12 +134,18 @@
     ArrayProfile* profile = currentInstruction[4].u.arrayProfile;
     
     emitLoad2(base, regT1, regT0, property, regT3, regT2);
+
+        dprint("JIT@% 3d: op_get_by_val: Base: tag 0x%08x payload 0x%08x\n", getgencount(), regT1, regT0);
+        dprint("JIT@% 3d: op_get_by_val: property: tag 0x%08x payload 0x%08x\n", getgencount(), regT3, regT2);
     
     addSlowCase(branch32(NotEqual, regT3, TrustedImm32(JSValue::Int32Tag)));
     emitJumpSlowCaseIfNotJSCell(base, regT1);
     loadPtr(Address(regT0, JSCell::structureOffset()), regT1);
     emitArrayProfilingSite(regT1, regT3, profile);
+        dprint("JIT@% 3d: op_get_by_val: Shape before masking: 0x%08x\n", getgencount(), regT1);
+        dprint("JIT@% 3d: op_get_by_val: Mask: 0x%08x\n", getgencount(), IndexingShapeMask);
     and32(TrustedImm32(IndexingShapeMask), regT1);
+        dprint("JIT@% 3d: op_get_by_val: Shape after masking: 0x%08x\n", getgencount(), regT1);
 
     PatchableJump badType;
     JumpList slowCases;
@@ -142,21 +153,26 @@
     JITArrayMode mode = chooseArrayMode(profile);
     switch (mode) {
     case JITInt32:
+        dprint("JIT@% 3d: op_get_by_val: JITInt32\n", getgencount());
         slowCases = emitInt32GetByVal(currentInstruction, badType);
         break;
     case JITDouble:
+        dprint("JIT@% 3d: op_get_by_val: JITDouble\n", getgencount());
         slowCases = emitDoubleGetByVal(currentInstruction, badType);
         break;
     case JITContiguous:
+        dprint("JIT@% 3d: op_get_by_val: JITContiguous\n", getgencount());
         slowCases = emitContiguousGetByVal(currentInstruction, badType);
         break;
     case JITArrayStorage:
+        dprint("JIT@% 3d: op_get_by_val: JITArrayStorage\n", getgencount());
         slowCases = emitArrayStorageGetByVal(currentInstruction, badType);
         break;
     default:
         CRASH();
     }
     
+        dprint("JIT@% 3d: op_get_by_val: After emitting GetByVal code\n", getgencount());
     addSlowCase(badType);
     addSlowCase(slowCases);
     
@@ -168,9 +184,11 @@
     resultOK.link(this);
 #endif
 
+        dprint("JIT@% 3d: op_get_by_val: Storing to %d: tag 0x%08x payload 0x%08x\n", getgencount(), dst, regT1, regT0);
     emitValueProfilingSite(regT4);
     emitStore(dst, regT1, regT0);
     
+        dprint("JIT@% 3d: op_get_by_val: Done\n", getgencount());
     m_byValCompilationInfo.append(ByValCompilationInfo(m_bytecodeOffset, badType, mode, done));
 }
 
@@ -178,13 +196,27 @@
 {
     JumpList slowCases;
     
+        dprint("JIT@% 3d: JIT::emitContiguousGetByVal:\n", getgencount());
+
+        dprint("JIT@% 3d: JIT::emitContiguousGetByVal: regT1: 0x%08x\n", getgencount(), regT1);
+        dprint("JIT@% 3d: JIT::emitContiguousGetByVal: expectedShape: 0x%08x\n", getgencount(), (int)expectedShape);
+
     badType = patchableBranch32(NotEqual, regT1, TrustedImm32(expectedShape));
+
+        dprint("JIT@% 3d: JIT::emitContiguousGetByVal: after badType\n", getgencount());
+
+        dprint("JIT@% 3d: JIT::emitContiguousGetByVal: Index, I think: %d\n", getgencount(), regT2);
     
     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, Butterfly::offsetOfPublicLength())));
+
+        dprint("JIT@% 3d: JIT::emitContiguousGetByVal: Made it past the length check\n", getgencount());
     
     load32(BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)), regT1); // tag
     load32(BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)), regT0); // payload
+
+        dprint("JIT@% 3d: JIT::emitContiguousGetByVal: Loaded tag 0x%08x payload 0x%08x\n", getgencount(), regT1, regT0);
+
     slowCases.append(branch32(Equal, regT1, TrustedImm32(JSValue::EmptyValueTag)));
     
     return slowCases;
@@ -194,14 +226,20 @@
 {
     JumpList slowCases;
     
+        dprint("JIT@% 3d: JIT::emitDoubleGetByVal: regT1 0x%08x, expected 0x%08x\n", getgencount(), regT1, DoubleShape);
+
     badType = patchableBranch32(NotEqual, regT1, TrustedImm32(DoubleShape));
     
     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, Butterfly::offsetOfPublicLength())));
     
     loadDouble(BaseIndex(regT3, regT2, TimesEight), fpRegT0);
+        dprint("JIT@% 3d: JIT::emitDoubleGetByVal: Loaded value %f\n", getgencount(), regT1, fpRegT0);
     slowCases.append(branchDouble(DoubleNotEqualOrUnordered, fpRegT0, fpRegT0));
+
+        dprint("JIT@% 3d: JIT::emitDoubleGetByVal: doing moveDoubleToInts on %f\n", getgencount(), fpRegT0);
     moveDoubleToInts(fpRegT0, regT0, regT1);
+        dprint("JIT@% 3d: JIT::emitDoubleGetByVal: Result of moveDoubleToInts is tag 0x%08x payload 0x%08x\n", getgencount(), regT1, regT0);
     
     return slowCases;
 }
@@ -210,15 +248,29 @@
 {
     JumpList slowCases;
     
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal:\n", getgencount());
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal: regT0 is 0x%08x\n", getgencount(), regT0);
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal: regT1 is 0x%08x\n", getgencount(), regT1);
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal: regT2 is 0x%08x\n", getgencount(), regT2);
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal: regT3 is 0x%08x\n", getgencount(), regT3);
     add32(TrustedImm32(-ArrayStorageShape), regT1, regT3);
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal: regT3 is now 0x%08x\n", getgencount(), regT3);
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal: Comparing to 0x%08x\n", getgencount(), SlowPutArrayStorageShape - ArrayStorageShape);
     badType = patchableBranch32(Above, regT3, TrustedImm32(SlowPutArrayStorageShape - ArrayStorageShape));
     
+#if 0
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal: Past badtype\n", getgencount());
+#endif
     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal: ArrayStorage 0x%08x\n", getgencount(), regT3);
+	
     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, ArrayStorage::vectorLengthOffset())));
     
     load32(BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(ArrayStorage, m_vector[0]) + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), regT1); // tag
     load32(BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(ArrayStorage, m_vector[0]) + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), regT0); // payload
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal: Loaded tag 0x%08x payload 0x%08x\n", getgencount(), regT1, regT0);
     slowCases.append(branch32(Equal, regT1, TrustedImm32(JSValue::EmptyValueTag)));
+        dprint("JIT@% 3d: JIT::emitArrayStorageGetByVal: Done\n", getgencount());
     
     return slowCases;
 }
@@ -233,32 +285,44 @@
     linkSlowCase(iter); // property int32 check
     linkSlowCaseIfNotJSCell(iter, base); // base cell check
 
+        dprint("JIT@% 3d: op_get_by_val: Slow path 1\n", getgencount());
+
     Jump nonCell = jump();
     linkSlowCase(iter); // base array check
+        dprint("JIT@% 3d: op_get_by_val: Slow path 2\n", getgencount());
+        dprint("JIT@% 3d: op_get_by_val: Line %d\n", getgencount(), __LINE__);
     Jump notString = branchPtr(NotEqual, Address(regT0, JSCell::structureOffset()), TrustedImmPtr(m_vm->stringStructure.get()));
+        dprint("JIT@% 3d: op_get_by_val: Line %d\n", getgencount(), __LINE__);
     emitNakedCall(m_vm->getCTIStub(stringGetByValStubGenerator).code());
     Jump failed = branchTestPtr(Zero, regT0);
+        dprint("JIT@% 3d: op_get_by_val: Line %d\n", getgencount(), __LINE__);
     emitStore(dst, regT1, regT0);
     emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_get_by_val));
     failed.link(this);
+        dprint("JIT@% 3d: op_get_by_val: Line %d\n", getgencount(), __LINE__);
     notString.link(this);
+        dprint("JIT@% 3d: op_get_by_val: Line %d\n", getgencount(), __LINE__);
     nonCell.link(this);
+        dprint("JIT@% 3d: op_get_by_val: Line %d\n", getgencount(), __LINE__);
     
     Jump skipProfiling = jump();
 
     linkSlowCase(iter); // vector length check
     linkSlowCase(iter); // empty value
     
+        dprint("JIT@% 3d: op_get_by_val: Line %d\n", getgencount(), __LINE__);
     emitArrayProfileOutOfBoundsSpecialCase(profile);
     
     skipProfiling.link(this);
     
     Label slowPath = label();
     
+        dprint("JIT@% 3d: op_get_by_val: Line %d\n", getgencount(), __LINE__);
     emitLoad(base, regT1, regT0);
     emitLoad(property, regT3, regT2);
     Call call = callOperation(operationGetByValDefault, dst, regT1, regT0, regT3, regT2);
 
+        dprint("JIT@% 3d: op_get_by_val: Line %d\n", getgencount(), __LINE__);
     m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
     m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
     m_byValInstructionIndex++;
@@ -458,6 +522,23 @@
     emitLoad(base, regT2, regT1);
     emitLoad(property, regT3, regT0);
     emitLoad(value, regT5, regT4);
+
+    dprint("JIT@% 3d: " __FILE__ ":%d: op_put_by_val: regT5/r17: 0x%08x\n", getgencount(), __LINE__, regT5);
+
+    if (!isDirect)
+    {
+        dprint("JIT@% 3d: op_put_by_val: Gonna call operationPutByVal\n", getgencount());
+        dprint("JIT@% 3d: op_put_by_val: base 0x%08x:0x%08x\n", getgencount(), regT2, regT1);
+        dprint("JIT@% 3d: op_put_by_val: property 0x%08x:0x%08x\n", getgencount(), regT3, regT0);
+        dprint("JIT@% 3d: op_put_by_val: value 0x%08x:0x%08x\n", getgencount(), regT5, regT4);
+    }
+    else
+    {
+        dprint("JIT@% 3d: op_put_by_val: Gonna call operationDirectPutByVal\n", getgencount());
+    }
+
+    dprint("JIT@% 3d: " __FILE__ ":%d: op_put_by_val: regT5/r17: 0x%08x\n", getgencount(), __LINE__, regT5);
+
     Call call = callOperation(isDirect ? operationDirectPutByVal : operationPutByVal, regT2, regT1, regT3, regT0, regT5, regT4);
 #endif
 
@@ -473,6 +554,9 @@
     const Identifier* ident = &(m_codeBlock->identifier(currentInstruction[3].u.operand));
     
     emitLoad(base, regT1, regT0);
+
+    dprint("JIT@% 3d: op_get_by_id: regT1 0x%08x, regT0 0x%08x\n", getgencount(), regT1, regT0);
+
     emitJumpSlowCaseIfNotJSCell(base, regT1);
 
     if (*ident == m_vm->propertyNames->length && shouldEmitProfiling()) {
@@ -488,6 +572,8 @@
     m_getByIds.append(gen);
 
     emitValueProfilingSite(regT4);
+    dprint("JIT@% 3d: op_get_by_id: Storing to %d\n", getgencount(), dst);
+    dprint("JIT@% 3d: op_get_by_id: Storing regT1 0x%08x, regT0 0x%08x\n", getgencount(), regT1, regT0);
     emitStore(dst, regT1, regT0);
 }
 
@@ -503,7 +589,9 @@
     JITGetByIdGenerator& gen = m_getByIds[m_getByIdIndex++];
     
     Label coldPathBegin = label();
-    
+    dprint("JIT@% 3d: op_get_by_id: slow path\n", getgencount());
+
+	/* Goes to ALWAYS_INLINE MacroAssembler::Call JIT::callOperation(JIT::WithProfileTag, J_JITOperation_ESsiJI operation, int dst, StructureStubInfo* stubInfo, GPRReg arg1Tag, GPRReg arg1Payload, StringImpl* uid) */
     Call call = callOperation(WithProfile, operationGetByIdOptimize, resultVReg, gen.stubInfo(), regT1, regT0, ident->impl());
     
     gen.reportSlowPathCall(coldPathBegin, call);
@@ -519,15 +607,17 @@
     int value = currentInstruction[3].u.operand;
     int direct = currentInstruction[8].u.operand;
     
+	dprint("JIT@% 3d: emit_op_put_by_id: Executing\n", getgencount());
+
     emitWriteBarrier(base, value, ShouldFilterBaseAndValue);
 
     emitLoad2(base, regT1, regT0, value, regT3, regT2);
     
+	dprint("JIT@% 3d: emit_op_put_by_id: base %d tag %08x payload %08x\n", getgencount(), base, regT1, regT0);
+	dprint("JIT@% 3d: emit_op_put_by_id: value %d tag %08x payload %08x\n", getgencount(), value, regT3, regT2);
+
     emitJumpSlowCaseIfNotJSCell(base, regT1);
     
-    emitLoad(base, regT1, regT0);
-    emitLoad(value, regT3, regT2);
-
     JITPutByIdGenerator gen(
         m_codeBlock, CodeOrigin(m_bytecodeOffset), RegisterSet::specialRegisters(),
         callFrameRegister, JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2),
@@ -547,9 +637,15 @@
     linkSlowCaseIfNotJSCell(iter, base);
     linkSlowCase(iter);
     
+    dprint("JIT@% 3d: op_put_by_id: slow path\n", getgencount());
+
     Label coldPathBegin(this);
     
     JITPutByIdGenerator& gen = m_putByIds[m_putByIdIndex++];
+
+#if 0
+    breakpoint();
+#endif
     
     Call call = callOperation(
         gen.slowPathFunction(), gen.stubInfo(), regT3, regT2, regT1, regT0, ident->impl());
@@ -694,21 +790,33 @@
     ResolveType resolveType = static_cast<ResolveType>(currentInstruction[3].u.operand);
     unsigned depth = currentInstruction[4].u.operand;
 
+	dprint("JIT@% 3d: op_resolve_scope: resolveType %d\n", getgencount(), resolveType);
+
     switch (resolveType) {
     case GlobalProperty:
     case GlobalVar:
     case GlobalPropertyWithVarInjectionChecks:
     case GlobalVarWithVarInjectionChecks:
+
+	dprint("JIT@% 3d: op_resolve_scope: Global\n", getgencount());
+
         emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
         move(TrustedImm32(JSValue::CellTag), regT1);
         move(TrustedImmPtr(m_codeBlock->globalObject()), regT0);
+	dprint("JIT@% 3d: op_resolve_scope: storing to %d: tag %08x payload %08x\n", getgencount(), dst, regT1, regT0);
         emitStore(dst, regT1, regT0);
         break;
     case ClosureVar:
     case ClosureVarWithVarInjectionChecks:
+
+	dprint("JIT@% 3d: op_resolve_scope: Closure\n", getgencount());
+
         emitResolveClosure(dst, needsVarInjectionChecks(resolveType), depth);
         break;
     case Dynamic:
+
+	dprint("JIT@% 3d: op_resolve_scope: Dynamic\n", getgencount());
+
         addSlowCase(jump());
         break;
     }
@@ -723,8 +831,13 @@
         return;
 
     linkSlowCase(iter);
+
+	dprint("JIT@% 3d: op_resolve_scope: slow path\n", getgencount());
+
     int32_t indentifierIndex = currentInstruction[2].u.operand;
     callOperation(operationResolveScope, dst, indentifierIndex);
+
+    dprint("JIT@% 3d: regT0 %08x, regT1 %08x\n", getgencount(), regT0, regT1);
 }
 
 void JIT::emitLoadWithStructureCheck(int scope, Structure** structureSlot)
@@ -745,6 +858,8 @@
 {
     load32(reinterpret_cast<char*>(operand) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag), regT1);
     load32(reinterpret_cast<char*>(operand) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload), regT0);
+
+	dprint("JIT@% 3d: emit_op_get_from_scope: Var: address %08x tag %08x payload %08x\n", getgencount(), operand, regT1, regT0);
 }
 
 void JIT::emitGetClosureVar(int scope, uintptr_t operand)
@@ -766,20 +881,24 @@
     switch (resolveType) {
     case GlobalProperty:
     case GlobalPropertyWithVarInjectionChecks:
+	dprint("JIT@% 3d: emit_op_get_from_scope: Property\n", getgencount());
         emitLoadWithStructureCheck(scope, structureSlot); // Structure check covers var injection.
         emitGetGlobalProperty(operandSlot);
         break;
     case GlobalVar:
     case GlobalVarWithVarInjectionChecks:
+	dprint("JIT@% 3d: emit_op_get_from_scope: Var\n", getgencount());
         emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
         emitGetGlobalVar(*operandSlot);
         break;
     case ClosureVar:
     case ClosureVarWithVarInjectionChecks:
+	dprint("JIT@% 3d: emit_op_get_from_scope: Closure\n", getgencount());
         emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
         emitGetClosureVar(scope, *operandSlot);
         break;
     case Dynamic:
+	dprint("JIT@% 3d: emit_op_get_from_scope: Dynamic\n", getgencount());
         addSlowCase(jump());
         break;
     }
@@ -796,6 +915,9 @@
         return;
 
     linkSlowCase(iter);
+
+    dprint("JIT@% 3d: get_from_scope: Instruction %08x\n", getgencount(), (int)currentInstruction);
+
     callOperation(WithProfile, operationGetFromScope, dst, currentInstruction);
 }
 
@@ -849,6 +971,9 @@
 void JIT::emitPutGlobalVar(uintptr_t operand, int value, VariableWatchpointSet* set)
 {
     emitLoad(value, regT1, regT0);
+
+	dprint("JIT@% 3d: put_to_scope: Var: operand %d tag %08x payload %08x\n", getgencount(), operand, regT1, regT0);
+
     emitNotifyWrite(regT1, regT0, regT2, set);
     store32(regT1, reinterpret_cast<char*>(operand) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag));
     store32(regT0, reinterpret_cast<char*>(operand) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload));
@@ -874,23 +999,27 @@
     switch (resolveType) {
     case GlobalProperty:
     case GlobalPropertyWithVarInjectionChecks:
+    	dprint("JIT@% 3d: put_to_scope: Property\n", getgencount());
         emitWriteBarrier(m_codeBlock->globalObject(), value, ShouldFilterValue);
         emitLoadWithStructureCheck(scope, structureSlot); // Structure check covers var injection.
         emitPutGlobalProperty(operandSlot, value);
         break;
     case GlobalVar:
     case GlobalVarWithVarInjectionChecks:
+    	dprint("JIT@% 3d: put_to_scope: Var\n", getgencount());
         emitWriteBarrier(m_codeBlock->globalObject(), value, ShouldFilterValue);
         emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
         emitPutGlobalVar(*operandSlot, value, currentInstruction[5].u.watchpointSet);
         break;
     case ClosureVar:
     case ClosureVarWithVarInjectionChecks:
+    	dprint("JIT@% 3d: put_to_scope: Closure\n", getgencount());
         emitWriteBarrier(scope, value, ShouldFilterValue);
         emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
         emitPutClosureVar(scope, *operandSlot, value);
         break;
     case Dynamic:
+    	dprint("JIT@% 3d: put_to_scope: Dynamic\n", getgencount());
         addSlowCase(jump());
         break;
     }
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITStubs.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITStubs.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITStubs.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITStubs.cpp	2018-06-12 14:28:02.361668925 +0000
@@ -41,6 +41,8 @@
 #include "JITStubsX86.h"
 #elif CPU(X86_64)
 #include "JITStubsX86_64.h"
+#elif CPU(PPC)
+#include "JITStubsPPC.h"
 #elif CPU(ARM64)
 // There isn't an ARM64 specific .h file
 #elif CPU(MIPS)
@@ -51,4 +53,32 @@
 #error "JIT not supported on this platform."
 #endif
 
+void DumpDumpSpaces();
+
+#if 0
+asm (
+".text" "\n"
+".align 2" "\n"
+".globl returnFromJavaScript" "\n"
+"returnFromJavaScript:" "\n"
+	"twi 31,0,0" "\n"
+);
+
+asm (
+".text" "\n"
+".align 2" "\n"
+".globl callToJavaScript" "\n"
+"callToJavaScript:" "\n"
+	"twi 31,0,0" "\n"
+);
+
+asm (
+".text" "\n"
+".align 2" "\n"
+".globl callToNativeFunction" "\n"
+"callToNativeFunction:" "\n"
+	"twi 31,0,0" "\n"
+);
+#endif
+
 #endif // ENABLE(JIT)
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITStubsPPC.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITStubsPPC.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITStubsPPC.h	1970-01-01 00:00:00.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITStubsPPC.h	2018-06-12 14:28:02.365668958 +0000
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2008, 2009, 2013 Apple Inc. All rights reserved.
+ * Copyright (C) 2008 Cameron Zwarich <cwzwarich@uwaterloo.ca>
+ * Copyright (C) Research In Motion Limited 2010, 2011. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
+ *     its contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef JITStubsPPC_h
+#define JITStubsPPC_h
+
+#if !CPU(PPC)
+#error "JITStubsPPC.h should only be #included if CPU(PPC)"
+#endif
+
+#if !USE(JSVALUE32_64)
+#error "JITStubsPPC.h only implements USE(JSVALUE32_64)"
+#endif
+
+#warning foo
+
+namespace JSC {
+
+#define THUNK_RETURN_ADDRESS_OFFSET      0x38
+#define PRESERVED_RETURN_ADDRESS_OFFSET  0x3C
+#define PRESERVED_R14_OFFSET             0x40
+#define PRESERVED_R15_OFFSET             0x44
+#define PRESERVED_R16_OFFSET             0x48
+#define PRESERVED_R17_OFFSET             0x4c
+#define REGISTER_FILE_OFFSET             0x4c
+#if COMPILER(GCC)
+
+#if 0
+extern "C" EncodedJSValue ctiTrampoline(void* code, JSStack*, CallFrame*, void* /*unused1*/, void* /*unused2*/, VM*);
+#endif
+
+struct ProtoCallFrame;
+class Register;
+extern "C" void returnFromJavaScript(void);
+extern "C" EncodedJSValue callToJavaScript(void* code, ExecState**, ProtoCallFrame*, Register*);
+extern "C" EncodedJSValue callToNativeFunction(void* code, ExecState**, ProtoCallFrame*, Register*);
+
+#if 0
+asm (
+".text" "\n"
+".align 2" "\n"
+".globl " SYMBOL_STRING(ctiTrampoline) "\n"
+HIDE_SYMBOL(ctiTrampoline) "\n"
+SYMBOL_STRING(ctiTrampoline) ":" "\n"
+	"stwu	%r1,-256(%r1)" "\n"
+	"mflr	%r0" "\n"
+	"stw	%r0,260(%r1)" "\n"
+#if 0
+	"stw	%r0,4(%r1)" "\n"
+#else
+	"stw	%r0," STRINGIZE_VALUE_OF(PRESERVED_RETURN_ADDRESS_OFFSET) "(%r1)" "\n"
+#endif
+
+	"stw	%r14," STRINGIZE_VALUE_OF(PRESERVED_R14_OFFSET) "(%r1)" "\n"
+	"stw	%r15," STRINGIZE_VALUE_OF(PRESERVED_R15_OFFSET) "(%r1)" "\n"
+	"stw	%r16," STRINGIZE_VALUE_OF(PRESERVED_R16_OFFSET) "(%r1)" "\n"
+	"stw	%r17," STRINGIZE_VALUE_OF(PRESERVED_R17_OFFSET) "(%r1)" "\n"
+
+	"mr	%r14, %r5" "\n"
+
+	"mtctr	%r3" "\n"
+	"bctrl" "\n"
+
+	"lwz	%r14," STRINGIZE_VALUE_OF(PRESERVED_R14_OFFSET) "(%r1)" "\n"
+	"lwz	%r15," STRINGIZE_VALUE_OF(PRESERVED_R15_OFFSET) "(%r1)" "\n"
+	"lwz	%r16," STRINGIZE_VALUE_OF(PRESERVED_R16_OFFSET) "(%r1)" "\n"
+	"lwz	%r17," STRINGIZE_VALUE_OF(PRESERVED_R17_OFFSET) "(%r1)" "\n"
+
+	"mr	%r5,%r3" "\n"
+	"mr	%r3,%r4" "\n"
+	"mr	%r4,%r5" "\n"
+
+#if 0
+	"lwz	%r0,4(%r1)" "\n"
+#else
+	"lwz	%r0," STRINGIZE_VALUE_OF(PRESERVED_RETURN_ADDRESS_OFFSET) "(%r1)" "\n"
+#endif
+	"mtlr	%r0" "\n"
+	"lwz	%r1,0(%r1)" "\n"
+	"blr" "\n"
+".align 2" "\n"
+".globl " SYMBOL_STRING(ctiTrampolineEnd) "\n"
+HIDE_SYMBOL(ctiTrampolineEnd) "\n"
+SYMBOL_STRING(ctiTrampolineEnd) ":" "\n"
+	"nop" "\n"
+);
+
+#if 0
+asm (
+".text" "\n"
+".align 2" "\n"
+".globl " SYMBOL_STRING(ctiVMThrowTrampoline) "\n"
+HIDE_SYMBOL(ctiVMThrowTrampoline) "\n"
+SYMBOL_STRING(ctiVMThrowTrampoline) ":" "\n"
+    "mr %r3, %r1\n"
+    "bl cti_vm_throw\n"
+	"lwz	%r14," STRINGIZE_VALUE_OF(PRESERVED_R14_OFFSET) "(%r1)" "\n"
+	"lwz	%r15," STRINGIZE_VALUE_OF(PRESERVED_R15_OFFSET) "(%r1)" "\n"
+	"lwz	%r16," STRINGIZE_VALUE_OF(PRESERVED_R16_OFFSET) "(%r1)" "\n"
+	"lwz	%r17," STRINGIZE_VALUE_OF(PRESERVED_R17_OFFSET) "(%r1)" "\n"
+
+	"mr	%r5,%r3" "\n"
+	"mr	%r3,%r4" "\n"
+	"mr	%r4,%r5" "\n"
+
+#if 0
+	"lwz	%r0,4(%r1)" "\n"
+#else
+	"lwz	%r0," STRINGIZE_VALUE_OF(PRESERVED_RETURN_ADDRESS_OFFSET) "(%r1)" "\n"
+#endif
+	"mtlr	%r0" "\n"
+	"lwz	%r1,0(%r1)" "\n"
+	"blr" "\n"
+);
+#endif
+
+#if 0
+asm (
+".text" "\n"
+".align 2" "\n"
+".globl " SYMBOL_STRING(ctiVMHandleException) "\n"
+HIDE_SYMBOL(ctiVMHandleException) "\n"
+SYMBOL_STRING(ctiVMHandleException) ":" "\n"
+    "mr %r3, %r14" "\n"
+    "bl " LOCAL_REFERENCE(cti_vm_handle_exception) "\n"
+    // When cti_vm_handle_exception returns, r3 has callFrame and r4 has handler address
+    "mr %r14, %r3" "\n"
+    "mtctr %r4" "\n"
+    "bctr" "\n"
+);
+#endif
+
+#if 1
+asm (
+".text" "\n"
+".align 2" "\n"
+".globl " SYMBOL_STRING(ctiOpThrowNotCaught) "\n"
+HIDE_SYMBOL(ctiOpThrowNotCaught) "\n"
+SYMBOL_STRING(ctiOpThrowNotCaught) ":" "\n"
+	"lwz	%r14," STRINGIZE_VALUE_OF(PRESERVED_R14_OFFSET) "(%r1)" "\n"
+	"lwz	%r15," STRINGIZE_VALUE_OF(PRESERVED_R15_OFFSET) "(%r1)" "\n"
+	"lwz	%r16," STRINGIZE_VALUE_OF(PRESERVED_R16_OFFSET) "(%r1)" "\n"
+	"lwz	%r17," STRINGIZE_VALUE_OF(PRESERVED_R17_OFFSET) "(%r1)" "\n"
+
+#if 0
+	"lwz	%r0,4(%r1)" "\n"
+#else
+	"lwz	%r0," STRINGIZE_VALUE_OF(PRESERVED_RETURN_ADDRESS_OFFSET) "(%r1)" "\n"
+#endif
+	"mtlr	%r0" "\n"
+	"lwz	%r1,0(%r1)" "\n"
+	"blr" "\n"
+);
+#endif
+
+#if 1
+#define DEFINE_STUB_FUNCTION(rtype, op) \
+    extern "C" { \
+        rtype JITStubThunked_##op(STUB_ARGS_DECLARATION); \
+    }; \
+    asm ( \
+        ".text" "\n" \
+        ".align 2" "\n" \
+        ".globl " SYMBOL_STRING(cti_##op) "\n" \
+        HIDE_SYMBOL(cti_##op) "\n"             \
+        SYMBOL_STRING(cti_##op) ":" "\n" \
+	"mflr	%r0" "\n" \
+	"stw	%r0," STRINGIZE_VALUE_OF(THUNK_RETURN_ADDRESS_OFFSET) "(%r1)" "\n" \
+	"stwu	%r1,-16(%r1)" "\n" \
+        "bl " SYMBOL_STRING(JITStubThunked_##op) "\n" \
+	"addi	%r1,%r1,16" "\n" \
+	"lwz	%r0," STRINGIZE_VALUE_OF(THUNK_RETURN_ADDRESS_OFFSET) "(%r1)" "\n" \
+	"mtlr	%r0" "\n" \
+	"blr" "\n" \
+        ); \
+    rtype JITStubThunked_##op(STUB_ARGS_DECLARATION) \
+
+#else
+#define DEFINE_STUB_FUNCTION(rtype, op) \
+    extern "C" { \
+        rtype JITStubThunked_##op(STUB_ARGS_DECLARATION); \
+    }; \
+    asm ( \
+        ".text" "\n" \
+        ".align 2" "\n" \
+        ".globl " SYMBOL_STRING(cti_##op) "\n" \
+        HIDE_SYMBOL(cti_##op) "\n"             \
+        "#.thumb" "\n" \
+        "#.thumb_func " THUMB_FUNC_PARAM(cti_##op) "\n" \
+        SYMBOL_STRING(cti_##op) ":" "\n" \
+        "#str lr, [sp, #" STRINGIZE_VALUE_OF(THUNK_RETURN_ADDRESS_OFFSET) "]" "\n" \
+        "#bl " SYMBOL_STRING(JITStubThunked_##op) "\n" \
+        "#ldr lr, [sp, #" STRINGIZE_VALUE_OF(THUNK_RETURN_ADDRESS_OFFSET) "]" "\n" \
+        "#bx lr" "\n" \
+        ); \
+    rtype JITStubThunked_##op(STUB_ARGS_DECLARATION) \
+
+#endif
+#endif
+
+#endif // COMPILER(GCC)
+
+#if 0
+static void performPPCJITAssertions()
+{
+#warning Change these back to normal asserts
+    // Unfortunate the arm compiler does not like the use of offsetof on JITStackFrame (since it contains non POD types),
+    // and the OBJECT_OFFSETOF macro does not appear constantish enough for it to be happy with its use in COMPILE_ASSERT
+    // macros.
+    RELEASE_ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedReturnAddress) == PRESERVED_RETURN_ADDRESS_OFFSET);
+    RELEASE_ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedR14) == PRESERVED_R14_OFFSET);
+    RELEASE_ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedR15) == PRESERVED_R15_OFFSET);
+    RELEASE_ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedR16) == PRESERVED_R16_OFFSET);
+
+    RELEASE_ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, stack) == REGISTER_FILE_OFFSET);
+
+    RELEASE_ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, thunkReturnAddress) == THUNK_RETURN_ADDRESS_OFFSET);
+}
+#endif
+
+} // namespace JSC
+
+#endif // JITStubsPPC_h
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITThunks.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITThunks.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITThunks.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITThunks.cpp	2018-06-12 14:28:02.365668958 +0000
@@ -52,6 +52,14 @@
 #endif
     return ctiStub(vm, nativeCallGenerator).code();
 }
+MacroAssemblerCodePtr JITThunks::ctiNativeCallWithSwap(VM* vm)
+{
+#if ENABLE(LLINT)
+    if (!vm->canUseJIT())
+        return MacroAssemblerCodePtr::createLLIntCodePtr(llint_native_call_trampoline);
+#endif
+    return ctiStub(vm, nativeCallGeneratorWithSwap).code();
+}
 MacroAssemblerCodePtr JITThunks::ctiNativeConstruct(VM* vm)
 {
 #if ENABLE(LLINT)
@@ -87,6 +95,8 @@
 
 NativeExecutable* JITThunks::hostFunctionStub(VM* vm, NativeFunction function, ThunkGenerator generator, Intrinsic intrinsic)
 {
+    COMPILEDPRINTF("%s:%d/%s(): intrinsic %d\n", __FILE__, __LINE__, __func__, (int)intrinsic);
+
     ASSERT(!isCompilationThread());    
 
     if (NativeExecutable* nativeExecutable = m_hostFunctionStubMap->get(std::make_pair(function, &callHostFunctionAsConstructor)))
@@ -95,11 +105,18 @@
     MacroAssemblerCodeRef code;
     if (generator) {
         if (vm->canUseJIT())
+        {
             code = generator(vm);
+        }
         else
+        {
             code = MacroAssemblerCodeRef();
+        }
     } else
+    {
+        COMPILEDPRINTF("%s:%d/%s(): No generator\n", __FILE__, __LINE__, __func__);
         code = JIT::compileCTINativeCall(vm, function);
+    }
 
     NativeExecutable* nativeExecutable = NativeExecutable::create(*vm, code, function, MacroAssemblerCodeRef::createSelfManagedCodeRef(ctiNativeConstruct(vm)), callHostFunctionAsConstructor, intrinsic);
     weakAdd(*m_hostFunctionStubMap, std::make_pair(function, &callHostFunctionAsConstructor), Weak<NativeExecutable>(nativeExecutable));
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JITThunks.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITThunks.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JITThunks.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JITThunks.h	2018-06-12 14:28:02.365668958 +0000
@@ -53,6 +53,7 @@
     ~JITThunks();
 
     MacroAssemblerCodePtr ctiNativeCall(VM*);
+    MacroAssemblerCodePtr ctiNativeCallWithSwap(VM*);
     MacroAssemblerCodePtr ctiNativeConstruct(VM*);
 
     MacroAssemblerCodeRef ctiStub(VM*, ThunkGenerator);
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/JSInterfaceJIT.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JSInterfaceJIT.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/JSInterfaceJIT.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/JSInterfaceJIT.h	2018-06-12 14:28:02.365668958 +0000
@@ -39,6 +39,9 @@
 #include "MacroAssembler.h"
 #include <wtf/Vector.h>
 
+#warning remove this
+extern char *dbg_enteringfunc;
+
 #if ENABLE(JIT)
 
 namespace JSC {
@@ -48,7 +51,7 @@
             : CCallHelpers(vm, codeBlock)
         {
         }
-
+        
 #if USE(JSVALUE32_64)
         // Can't just propogate JSValue::Int32Tag as visual studio doesn't like it
         static const unsigned Int32Tag = 0xffffffff;
@@ -94,14 +97,22 @@
 #if USE(JSVALUE32_64)
     inline JSInterfaceJIT::Jump JSInterfaceJIT::emitLoadJSCell(unsigned virtualRegisterIndex, RegisterID payload)
     {
+        loadPtr(tagFor(virtualRegisterIndex), payload);
+	dprint("emitLoadJSCell: tag 0x%08x\n", payload);
+
         loadPtr(payloadFor(virtualRegisterIndex), payload);
+	dprint("emitLoadJSCell: payload 0x%08x\n", payload);
         return emitJumpIfNotJSCell(virtualRegisterIndex);
     }
 
     inline JSInterfaceJIT::Jump JSInterfaceJIT::emitJumpIfNotJSCell(unsigned virtualRegisterIndex)
     {
+	JSInterfaceJIT::Jump jump;
         ASSERT(static_cast<int>(virtualRegisterIndex) < FirstConstantRegisterIndex);
-        return branch32(NotEqual, tagFor(virtualRegisterIndex), TrustedImm32(JSValue::CellTag));
+        jump = branch32(NotEqual, tagFor(virtualRegisterIndex), TrustedImm32(JSValue::CellTag));
+	dprint("emitJumpIfNotJSCell: This is a cell\n");
+
+	return jump;
     }
     
     inline JSInterfaceJIT::Jump JSInterfaceJIT::emitLoadInt32(unsigned virtualRegisterIndex, RegisterID dst)
@@ -232,7 +243,7 @@
 
     ALWAYS_INLINE void JSInterfaceJIT::emitGetFromCallFrameHeaderPtr(JSStack::CallFrameHeaderEntry entry, RegisterID to, RegisterID from)
     {
-        loadPtr(Address(from, entry * sizeof(Register)), to);
+        loadPtr(payloadFor(entry, from), to);
     }
 
     ALWAYS_INLINE void JSInterfaceJIT::emitPutToCallFrameHeader(RegisterID from, JSStack::CallFrameHeaderEntry entry)
@@ -246,7 +257,7 @@
 
     ALWAYS_INLINE void JSInterfaceJIT::emitPutImmediateToCallFrameHeader(void* value, JSStack::CallFrameHeaderEntry entry)
     {
-        storePtr(TrustedImmPtr(value), Address(callFrameRegister, entry * sizeof(Register)));
+        storePtr(TrustedImmPtr(value), payloadFor(entry, callFrameRegister));
     }
 
     ALWAYS_INLINE void JSInterfaceJIT::emitPutCellToCallFrameHeader(RegisterID from, JSStack::CallFrameHeaderEntry entry)
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/Repatch.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/Repatch.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/Repatch.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/Repatch.cpp	2018-07-17 14:02:16.686711558 +0000
@@ -330,6 +330,7 @@
 #if USE(JSVALUE64)
         stubJit.move(GPRInfo::returnValueGPR, resultGPR);
 #else
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d: resultTagGPR 0x%08x resultPayloadGPR 0x%08x\n", stubJit.getgencount(), __LINE__, resultTagGPR, resultGPR);
         stubJit.setupResults(resultGPR, resultTagGPR);
 #endif
         MacroAssembler::Jump noException = stubJit.emitExceptionCheck(CCallHelpers::InvertedExceptionCheck);
@@ -602,14 +603,14 @@
 #if USE(JSVALUE64)
                     stubJit.load64(MacroAssembler::Address(baseGPR, offsetRelativeToBase(slot.cachedOffset())), scratchGPR);
 #else
-                    stubJit.load32(MacroAssembler::Address(baseGPR, offsetRelativeToBase(slot.cachedOffset())), scratchGPR);
+                    stubJit.load32(MacroAssembler::Address(baseGPR, 4 + offsetRelativeToBase(slot.cachedOffset())), scratchGPR);
 #endif
                 } else {
                     stubJit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), scratchGPR);
 #if USE(JSVALUE64)
                     stubJit.load64(MacroAssembler::Address(scratchGPR, offsetRelativeToBase(slot.cachedOffset())), scratchGPR);
 #else
-                    stubJit.load32(MacroAssembler::Address(scratchGPR, offsetRelativeToBase(slot.cachedOffset())), scratchGPR);
+                    stubJit.load32(MacroAssembler::Address(scratchGPR, 4 + offsetRelativeToBase(slot.cachedOffset())), scratchGPR);
 #endif
                 }
                 stubJit.setupArguments(callFrameRegister, baseGPR, scratchGPR);
@@ -639,6 +640,7 @@
 #if USE(JSVALUE64)
             stubJit.move(GPRInfo::returnValueGPR, resultGPR);
 #else
+            stubJit.dprint("JIT@% 3d: " __FILE__ ":%d: resultTagGPR 0x%08x resultPayloadGPR 0x%08x\n", stubJit.getgencount(), __LINE__, resultTagGPR, resultGPR);
             stubJit.setupResults(resultGPR, resultTagGPR);
 #endif
             success = stubJit.emitExceptionCheck(CCallHelpers::InvertedExceptionCheck);
@@ -928,6 +930,7 @@
     CodeLocationLabel failureLabel,
     RefPtr<JITStubRoutine>& stubRoutine)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): tag 0x%08x payload 0x%08x\n", __FILE__, __LINE__, __func__);
     VM* vm = &exec->vm();
 
     GPRReg callFrameRegister = static_cast<GPRReg>(stubInfo.patch.callFrameRegister);
@@ -946,12 +949,15 @@
     
     CCallHelpers stubJit(vm);
     
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d: tag 0x%08x payload 0x%08x\n", stubJit.getgencount(), __LINE__, valueTagGPR, valueGPR);
+
     bool needThirdScratch = false;
     if (structure->outOfLineCapacity() != oldStructure->outOfLineCapacity()
         && oldStructure->outOfLineCapacity()) {
         needThirdScratch = true;
     }
 
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
     GPRReg scratchGPR1 = allocator.allocateScratchGPR();
     ASSERT(scratchGPR1 != baseGPR);
     ASSERT(scratchGPR1 != valueGPR);
@@ -961,6 +967,7 @@
     ASSERT(scratchGPR2 != valueGPR);
     ASSERT(scratchGPR2 != scratchGPR1);
 
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
     GPRReg scratchGPR3;
     if (needThirdScratch) {
         scratchGPR3 = allocator.allocateScratchGPR();
@@ -971,19 +978,27 @@
     } else
         scratchGPR3 = InvalidGPRReg;
     
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
     allocator.preserveReusedRegistersByPushing(stubJit);
 
     MacroAssembler::JumpList failureCases;
             
     ASSERT(oldStructure->transitionWatchpointSetHasBeenInvalidated());
     
+    stubJit.loadPtr(MacroAssembler::Address(baseGPR, JSCell::structureOffset()), scratchGPR2);
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d: baseGPR 0x%08x\n", stubJit.getgencount(), __LINE__, baseGPR);
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d: structure 0x%08x\n", stubJit.getgencount(), __LINE__, scratchGPR2);
+        stubJit.dprint("JIT@% 3d: " __FILE__ ": oldStructure 0x%08x\n", stubJit.getgencount(), (unsigned int)oldStructure);
     failureCases.append(stubJit.branchPtr(MacroAssembler::NotEqual, MacroAssembler::Address(baseGPR, JSCell::structureOffset()), MacroAssembler::TrustedImmPtr(oldStructure)));
     
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
     addStructureTransitionCheck(
         oldStructure->storedPrototype(), exec->codeBlock(), stubInfo, stubJit, failureCases,
         scratchGPR1);
             
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
     if (putKind == NotDirect) {
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
         for (WriteBarrier<Structure>* it = prototypeChain->head(); *it; ++it) {
             addStructureTransitionCheck(
                 (*it)->storedPrototype(), exec->codeBlock(), stubInfo, stubJit, failureCases,
@@ -995,10 +1010,13 @@
     
     bool scratchGPR1HasStorage = false;
     
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d: tag 0x%08x payload 0x%08x\n", stubJit.getgencount(), __LINE__, valueTagGPR, valueGPR);
     if (structure->outOfLineCapacity() != oldStructure->outOfLineCapacity()) {
         size_t newSize = structure->outOfLineCapacity() * sizeof(JSValue);
         CopiedAllocator* copiedAllocator = &vm->heap.storageAllocator();
         
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d: tag 0x%08x payload 0x%08x\n", stubJit.getgencount(), __LINE__, valueTagGPR, valueGPR);
         if (!oldStructure->outOfLineCapacity()) {
             stubJit.loadPtr(&copiedAllocator->m_currentRemaining, scratchGPR1);
             slowPath.append(stubJit.branchSubPtr(MacroAssembler::Signed, MacroAssembler::TrustedImm32(newSize), scratchGPR1));
@@ -1053,14 +1071,17 @@
     MacroAssembler::Call writeBarrierOperation = writeBarrier(stubJit, baseGPR, scratchGPR1, scratchGPR2, allocator);
 #endif
     
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
     MacroAssembler::Jump success;
     MacroAssembler::Jump failure;
             
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d: tag 0x%08x payload 0x%08x\n", stubJit.getgencount(), __LINE__, valueTagGPR, valueGPR);
     if (allocator.didReuseRegisters()) {
         allocator.restoreReusedRegistersByPopping(stubJit);
         success = stubJit.jump();
 
         failureCases.link(&stubJit);
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
         allocator.restoreReusedRegistersByPopping(stubJit);
         failure = stubJit.jump();
     } else
@@ -1069,16 +1090,21 @@
     MacroAssembler::Call operationCall;
     MacroAssembler::Jump successInSlowPath;
     
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
     if (structure->outOfLineCapacity() != oldStructure->outOfLineCapacity()) {
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
         slowPath.link(&stubJit);
         
         allocator.restoreReusedRegistersByPopping(stubJit);
         ScratchBuffer* scratchBuffer = vm->scratchBufferForSize(allocator.desiredScratchBufferSize());
         allocator.preserveUsedRegistersToScratchBuffer(stubJit, scratchBuffer, scratchGPR1);
+        stubJit.dprint("JIT@% 3d: " __FILE__ ": tag GPR %d\n", stubJit.getgencount(), (int)valueTagGPR);
+        stubJit.dprint("JIT@% 3d: " __FILE__ ": payload GPR %d\n", stubJit.getgencount(), (int)valueGPR);
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d: tag 0x%08x payload 0x%08x\n", stubJit.getgencount(), __LINE__, valueTagGPR, valueGPR);
 #if USE(JSVALUE64)
         stubJit.setupArguments(callFrameRegister, baseGPR, MacroAssembler::TrustedImmPtr(structure), MacroAssembler::TrustedImm32(slot.cachedOffset()), valueGPR);
 #else
-        stubJit.setupArguments(callFrameRegister, baseGPR, MacroAssembler::TrustedImmPtr(structure), MacroAssembler::TrustedImm32(slot.cachedOffset()), valueGPR, valueTagGPR);
+        stubJit.setupArguments(callFrameRegister, baseGPR, MacroAssembler::TrustedImmPtr(structure), MacroAssembler::TrustedImm32(slot.cachedOffset()), TAGPAYLOADREGPAIR(valueTagGPR, valueGPR));
 #endif
         operationCall = stubJit.call();
         allocator.restoreUsedRegistersFromScratchBuffer(stubJit, scratchBuffer, scratchGPR1);
@@ -1094,7 +1120,12 @@
         patchBuffer.link(failure, failureLabel);
     else
         patchBuffer.link(failureCases, failureLabel);
+
+    stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
+
     if (structure->outOfLineCapacity() != oldStructure->outOfLineCapacity()) {
+        stubJit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", stubJit.getgencount(), __LINE__);
+        CALLBACKDPRINTF("%s:%d/%s(): Gonna repatch to operationReallocateStorageAndFinishPut\n", __FILE__, __LINE__, __func__);
         patchBuffer.link(operationCall, operationReallocateStorageAndFinishPut);
         patchBuffer.link(successInSlowPath, stubInfo.callReturnLocation.labelAtOffset(stubInfo.patch.deltaCallToDone));
     }
@@ -1438,7 +1469,9 @@
     repatchBuffer.relink(callLinkInfo.hotPathOther, codePtr);
     
     if (calleeCodeBlock)
+    {
         calleeCodeBlock->linkIncomingCall(exec->callerFrame(), &callLinkInfo);
+    }
     
     if (kind == CodeForCall) {
         repatchBuffer.relink(callLinkInfo.callReturnLocation, vm->getCTIStub(linkClosureCallThunkGenerator).code());
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/SpecializedThunkJIT.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/SpecializedThunkJIT.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/SpecializedThunkJIT.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/SpecializedThunkJIT.h	2018-06-12 14:28:02.365668958 +0000
@@ -41,8 +41,10 @@
         SpecializedThunkJIT(VM* vm, int expectedArgCount)
             : JSInterfaceJIT(vm)
         {
+	    dprint("SpecializedThunkJIT: Testing argument count\n");
             // Check that we have the expected number of arguments
             m_failures.append(branch32(NotEqual, payloadFor(JSStack::ArgumentCount), TrustedImm32(expectedArgCount + 1)));
+	    dprint("SpecializedThunkJIT: Argument count OK\n");
         }
         
         explicit SpecializedThunkJIT(VM* vm)
@@ -60,12 +62,14 @@
         {
             unsigned src = CallFrame::argumentOffset(argument);
             m_failures.append(emitLoadJSCell(src, dst));
+	    dprint("loadCellArgument: Success\n");
         }
         
         void loadJSStringArgument(VM& vm, int argument, RegisterID dst)
         {
             loadCellArgument(argument, dst);
             m_failures.append(branchPtr(NotEqual, Address(dst, JSCell::structureOffset()), TrustedImmPtr(vm.stringStructure.get())));
+	    dprint("loadJSStringArgument: Success\n");
         }
         
         void loadArgumentWithSpecificClass(const ClassInfo* classInfo, int argument, RegisterID dst, RegisterID scratch)
@@ -103,6 +107,7 @@
 #else
         void returnJSValue(RegisterID payload, RegisterID tag)
         {
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
             ASSERT_UNUSED(payload, payload == regT0);
             ASSERT_UNUSED(tag, tag == regT1);
             loadPtr(Address(callFrameRegister, CallFrame::callerFrameOffset()), callFrameRegister);
@@ -112,6 +117,7 @@
         
         void returnDouble(FPRegisterID src)
         {
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
 #if USE(JSVALUE64)
             moveDoubleTo64(src, regT0);
             Jump zero = branchTest64(Zero, regT0);
@@ -136,12 +142,18 @@
             lowNonZero.link(this);
             highNonZero.link(this);
 #endif
+
+		COMPILEDPRINTF("%s:%d/%s(): !!!! This is very unlikely to work !!!!\n", __FILE__, __LINE__, __func__);
+
+		dprint("JIT@ 3d: " __FILE__ ":%d/returnDouble(): This is unlikely to work\n", getgencount(), __LINE__);
+
             loadPtr(Address(callFrameRegister, CallFrame::callerFrameOffset()), callFrameRegister);
             ret();
         }
 
         void returnInt32(RegisterID src)
         {
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
             if (src != regT0)
                 move(src, regT0);
             tagReturnAsInt32();
@@ -151,6 +163,7 @@
 
         void returnJSCell(RegisterID src)
         {
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); dprint("JIT@% 3d: " __FILE__ ":%d:\n", getgencount(), __LINE__);
             if (src != regT0)
                 move(src, regT0);
             tagReturnAsJSCell();
@@ -160,6 +173,7 @@
         
         MacroAssemblerCodeRef finalize(MacroAssemblerCodePtr fallback, const char* thunkKind)
         {
+COMPILEDPRINTF("%s:%d/%s(): thunkKind \"%s\"\n", __FILE__, __LINE__, __func__, thunkKind);
             LinkBuffer patchBuffer(*m_vm, this, GLOBAL_THUNK_ID);
             patchBuffer.link(m_failures, CodeLocationLabel(fallback));
             for (unsigned i = 0; i < m_calls.size(); i++)
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/TempRegisterSet.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/TempRegisterSet.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/TempRegisterSet.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/TempRegisterSet.cpp	2018-06-12 14:28:02.365668958 +0000
@@ -34,6 +34,9 @@
 
 TempRegisterSet::TempRegisterSet(const RegisterSet& other)
 {
+    for (unsigned i = numberOfBytesInTempRegisterSet; i--;)
+        m_set[i] = 0;
+
     for (unsigned i = GPRInfo::numberOfRegisters; i--;) {
         GPRReg reg = GPRInfo::toRegister(i);
         if (other.get(reg))
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/ThunkGenerators.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/ThunkGenerators.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/jit/ThunkGenerators.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/ThunkGenerators.cpp	2018-06-26 10:01:25.822556978 +0000
@@ -113,10 +113,14 @@
     // been adjusted, and all other registers to be available for use.
     
     CCallHelpers jit(vm);
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit.getgencount(), __LINE__);
+    foddprintf("%s:%d/%s(): Probably gonna output patchable thing now\n", __FILE__, __LINE__, __func__);
     
     slowPathFor(jit, vm, kind == CodeForCall ? operationLinkCall : operationLinkConstruct);
     
+    foddprintf("%s:%d/%s(): Creating patchBuffer\n", __FILE__, __LINE__, __func__);
     LinkBuffer patchBuffer(*vm, &jit, GLOBAL_THUNK_ID);
+    foddprintf("%s:%d/%s(): Probably done outputting patchable thing now\n", __FILE__, __LINE__, __func__);
     return FINALIZE_CODE(
         patchBuffer,
         ("Link %s slow path thunk", kind == CodeForCall ? "call" : "construct"));
@@ -245,12 +249,14 @@
     return virtualForThunkGenerator(vm, CodeForConstruct);
 }
 
-static MacroAssemblerCodeRef nativeForGenerator(VM* vm, CodeSpecializationKind kind)
+static MacroAssemblerCodeRef nativeForGenerator(VM* vm, CodeSpecializationKind kind, bool doswap = false)
 {
     int executableOffsetToFunction = NativeExecutable::offsetOfNativeFunctionFor(kind);
     
     JSInterfaceJIT jit(vm);
     
+    jit.dprint("nativeForGenerator:\n");
+
     jit.emitPutImmediateToCallFrameHeader(0, JSStack::CodeBlock);
     jit.storePtr(JSInterfaceJIT::callFrameRegister, &vm->topCallFrame);
 
@@ -343,7 +349,7 @@
 
     jit.restoreReturnAddressBeforeReturn(JSInterfaceJIT::regT3);
 
-#elif CPU(ARM) || CPU(SH4) || CPU(MIPS)
+#elif CPU(ARM) || CPU(SH4) || CPU(MIPS) || CPU(PPC)
     // Load caller frame's scope chain into this callframe so that whatever we call can get to its global data.
     jit.emitGetCallerFrameFromCallFrameHeaderPtr(JSInterfaceJIT::regT2);
     jit.emitGetFromCallFrameHeaderPtr(JSStack::ScopeChain, JSInterfaceJIT::regT1, JSInterfaceJIT::regT2);
@@ -362,10 +368,22 @@
     jit.move(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::argumentGPR0);
 
     jit.emitGetFromCallFrameHeaderPtr(JSStack::Callee, JSInterfaceJIT::argumentGPR1);
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: Old Call Frame is 0x%08x\n", jit.getgencount(), __LINE__, PPCRegisters::r14);
     jit.move(JSInterfaceJIT::regT2, JSInterfaceJIT::callFrameRegister); // Eagerly restore caller frame register to avoid loading from stack.
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: New Call Frame is 0x%08x\n", jit.getgencount(), __LINE__, PPCRegisters::r14);
     jit.loadPtr(JSInterfaceJIT::Address(JSInterfaceJIT::argumentGPR1, JSFunction::offsetOfExecutable()), JSInterfaceJIT::regT2);
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: regT2: 0x%08x\n", jit.getgencount(), __LINE__, JSInterfaceJIT::regT2);
+    jit.dprint("JIT@% 3d: executableOffsetToFunction: 0x%08x\n", jit.getgencount(), executableOffsetToFunction);
     jit.call(JSInterfaceJIT::Address(JSInterfaceJIT::regT2, executableOffsetToFunction));
 
+    if (doswap)
+    {
+        jit.dprint("JIT@% 3d: " __FILE__ ":%d: Swapping...\n", jit.getgencount(), __LINE__);
+        jit.swap(JSInterfaceJIT::regT1, JSInterfaceJIT::regT0);
+    }
+
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: Native function returned 0x%08x:0x%08x\n", jit.getgencount(), __LINE__, JSInterfaceJIT::regT1, JSInterfaceJIT::regT0);
+
 #if CPU(MIPS)
     // Restore stack space
     jit.addPtr(JSInterfaceJIT::TrustedImm32(16), JSInterfaceJIT::stackPointerRegister);
@@ -389,12 +407,15 @@
         JSInterfaceJIT::TrustedImm32(JSValue::EmptyValueTag));
 #endif
 
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit.getgencount(), __LINE__);
     // Return.
     jit.ret();
 
     // Handle an exception
     exceptionHandler.link(&jit);
 
+    jit.dprint("JIT@% 3d: nativeForGenerator: Exception occured\n", jit.getgencount());
+
     // Grab the return address.
     jit.preserveReturnAddressAfterCall(JSInterfaceJIT::regT1);
     
@@ -403,6 +424,8 @@
 
     jit.storePtr(JSInterfaceJIT::callFrameRegister, &vm->topCallFrame);
 
+COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+
 #if CPU(X86) && USE(JSVALUE32_64)
     jit.addPtr(JSInterfaceJIT::TrustedImm32(-12), JSInterfaceJIT::stackPointerRegister);
     jit.push(JSInterfaceJIT::callFrameRegister);
@@ -423,9 +446,16 @@
 
 MacroAssemblerCodeRef nativeCallGenerator(VM* vm)
 {
+	COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     return nativeForGenerator(vm, CodeForCall);
 }
 
+MacroAssemblerCodeRef nativeCallGeneratorWithSwap(VM* vm)
+{
+	COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+    return nativeForGenerator(vm, CodeForCall, true);
+}
+
 MacroAssemblerCodeRef nativeConstructGenerator(VM* vm)
 {
     return nativeForGenerator(vm, CodeForConstruct);
@@ -435,6 +465,8 @@
 {
     JSInterfaceJIT jit(vm);
 
+	COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+
     // We enter with fixup count in regT0
 #if USE(JSVALUE64)
 #  if CPU(X86_64)
@@ -462,11 +494,14 @@
 
     // Adjust call frame register to account for missing args
     jit.lshift64(JSInterfaceJIT::TrustedImm32(3), JSInterfaceJIT::regT0);
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: Old Call Frame is 0x%08x\n", jit.getgencount(), __LINE__, PPCRegisters::r14);
     jit.addPtr(JSInterfaceJIT::regT0, JSInterfaceJIT::callFrameRegister);
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: New Call Frame is 0x%08x\n", jit.getgencount(), __LINE__, PPCRegisters::r14);
 
 #  if CPU(X86_64)
     jit.push(JSInterfaceJIT::regT4);
 #  endif
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit.getgencount(), __LINE__);
     jit.ret();
 #else
 #  if CPU(X86)
@@ -474,9 +509,19 @@
 #  endif
     jit.neg32(JSInterfaceJIT::regT0);
     jit.move(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::regT3);
+#if CPU(BIG_ENDIAN)
+    jit.load32(JSInterfaceJIT::Address(JSInterfaceJIT::callFrameRegister, JSStack::ArgumentCount * 8 + 4), JSInterfaceJIT::regT2);
+#else
+#error moo
     jit.load32(JSInterfaceJIT::Address(JSInterfaceJIT::callFrameRegister, JSStack::ArgumentCount * 8), JSInterfaceJIT::regT2);
+#endif
+
+		jit.dprint("JIT@% 3d: " __FILE__ ":%d: Arg count is %08x\n", jit.getgencount(), __LINE__, JSInterfaceJIT::regT2);
+
     jit.add32(JSInterfaceJIT::TrustedImm32(JSStack::CallFrameHeaderSize), JSInterfaceJIT::regT2);
 
+		jit.dprint("JIT@% 3d: " __FILE__ ":%d: gonna loop %08x times\n", jit.getgencount(), __LINE__, JSInterfaceJIT::regT2);
+
     // Move current frame down regT0 number of slots
     JSInterfaceJIT::Label copyLoop(jit.label());
     jit.load32(JSInterfaceJIT::regT3, JSInterfaceJIT::regT1);
@@ -486,24 +531,36 @@
     jit.addPtr(JSInterfaceJIT::TrustedImm32(8), JSInterfaceJIT::regT3);
     jit.branchSub32(MacroAssembler::NonZero, JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::regT2).linkTo(copyLoop, &jit);
 
+		jit.dprint("JIT@% 3d: " __FILE__ ":%d: Filling with undefined\n", jit.getgencount(), __LINE__);
+
     // Fill in regT0 missing arg slots with undefined
     jit.move(JSInterfaceJIT::regT0, JSInterfaceJIT::regT2);
     JSInterfaceJIT::Label fillUndefinedLoop(jit.label());
     jit.move(JSInterfaceJIT::TrustedImm32(0), JSInterfaceJIT::regT1);
-    jit.store32(JSInterfaceJIT::regT1, MacroAssembler::BaseIndex(JSInterfaceJIT::regT3, JSInterfaceJIT::regT0, JSInterfaceJIT::TimesEight));
-    jit.move(JSInterfaceJIT::TrustedImm32(JSValue::UndefinedTag), JSInterfaceJIT::regT1);
     jit.store32(JSInterfaceJIT::regT1, MacroAssembler::BaseIndex(JSInterfaceJIT::regT3, JSInterfaceJIT::regT0, JSInterfaceJIT::TimesEight, 4));
+    jit.move(JSInterfaceJIT::TrustedImm32(JSValue::UndefinedTag), JSInterfaceJIT::regT1);
+    jit.store32(JSInterfaceJIT::regT1, MacroAssembler::BaseIndex(JSInterfaceJIT::regT3, JSInterfaceJIT::regT0, JSInterfaceJIT::TimesEight, 0));
 
     jit.addPtr(JSInterfaceJIT::TrustedImm32(8), JSInterfaceJIT::regT3);
     jit.branchAdd32(MacroAssembler::NonZero, JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::regT2).linkTo(fillUndefinedLoop, &jit);
 
     // Adjust call frame register to account for missing args
     jit.lshift32(JSInterfaceJIT::TrustedImm32(3), JSInterfaceJIT::regT0);
+
+#if 0
+	jit.move(JSInterfaceJIT::callFrameRegister, PPCRegisters::r6);
+    jit.addPtr(JSInterfaceJIT::regT0, PPCRegisters::r6);
+		jit.dprint("JIT@% 3d: " __FILE__ ":%d: callFrameRegister %08x -> %08x\n", jit.getgencount(), __LINE__, JSInterfaceJIT::callFrameRegister, PPCRegisters::r6);
+#endif
+
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: Old Call Frame is 0x%08x\n", jit.getgencount(), __LINE__, PPCRegisters::r14);
     jit.addPtr(JSInterfaceJIT::regT0, JSInterfaceJIT::callFrameRegister);
+    jit.dprint("JIT@% 3d: " __FILE__ ":%d: New Call Frame is 0x%08x\n", jit.getgencount(), __LINE__, PPCRegisters::r14);
 
 #  if CPU(X86)
     jit.push(JSInterfaceJIT::regT4);
 #  endif
+    COMPILEDPRINTF("%s:%d/%s()\n", __FILE__, __LINE__, __func__); jit.dprint("JIT@% 3d: " __FILE__ ":%d:\n", jit.getgencount(), __LINE__);
     jit.ret();
 #endif
 
@@ -518,15 +575,23 @@
 
     // Load string length to regT2, and start the process of loading the data pointer into regT0
     jit.load32(MacroAssembler::Address(SpecializedThunkJIT::regT0, ThunkHelpers::jsStringLengthOffset()), SpecializedThunkJIT::regT2);
+    jit.dprint("stringCharLoad: String length %d\n", SpecializedThunkJIT::regT2);
     jit.loadPtr(MacroAssembler::Address(SpecializedThunkJIT::regT0, ThunkHelpers::jsStringValueOffset()), SpecializedThunkJIT::regT0);
+    jit.dprint("stringCharLoad: String value 0x%08x\n", SpecializedThunkJIT::regT0);
     jit.appendFailure(jit.branchTest32(MacroAssembler::Zero, SpecializedThunkJIT::regT0));
 
+    jit.dprint("stringCharLoad: About to load index\n");
+
     // load index
     jit.loadInt32Argument(0, SpecializedThunkJIT::regT1); // regT1 contains the index
 
+    jit.dprint("stringCharLoad: Index %d\n", SpecializedThunkJIT::regT1);
+
     // Do an unsigned compare to simultaneously filter negative indices as well as indices that are too large
     jit.appendFailure(jit.branch32(MacroAssembler::AboveOrEqual, SpecializedThunkJIT::regT1, SpecializedThunkJIT::regT2));
 
+    jit.dprint("stringCharLoad: Index loaded\n");
+
     // Load the character
     SpecializedThunkJIT::JumpList is16Bit;
     SpecializedThunkJIT::JumpList cont8Bit;
@@ -554,7 +619,7 @@
     SpecializedThunkJIT jit(vm, 1);
     stringCharLoad(jit, vm);
     jit.returnInt32(SpecializedThunkJIT::regT0);
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "charCodeAt");
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "charCodeAt");
 }
 
 MacroAssemblerCodeRef charAtThunkGenerator(VM* vm)
@@ -563,7 +628,7 @@
     stringCharLoad(jit, vm);
     charToString(jit, vm, SpecializedThunkJIT::regT0, SpecializedThunkJIT::regT0, SpecializedThunkJIT::regT1);
     jit.returnJSCell(SpecializedThunkJIT::regT0);
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "charAt");
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "charAt");
 }
 
 MacroAssemblerCodeRef fromCharCodeThunkGenerator(VM* vm)
@@ -573,19 +638,19 @@
     jit.loadInt32Argument(0, SpecializedThunkJIT::regT0);
     charToString(jit, vm, SpecializedThunkJIT::regT0, SpecializedThunkJIT::regT0, SpecializedThunkJIT::regT1);
     jit.returnJSCell(SpecializedThunkJIT::regT0);
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "fromCharCode");
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "fromCharCode");
 }
 
 MacroAssemblerCodeRef sqrtThunkGenerator(VM* vm)
 {
     SpecializedThunkJIT jit(vm, 1);
     if (!jit.supportsFloatingPointSqrt())
-        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCall(vm));
+        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCallWithSwap(vm));
 
     jit.loadDoubleArgument(0, SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::regT0);
     jit.sqrtDouble(SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::fpRegT0);
     jit.returnDouble(SpecializedThunkJIT::fpRegT0);
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "sqrt");
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "sqrt");
 }
 
 
@@ -700,7 +765,11 @@
     SpecializedThunkJIT jit(vm, 1);
     MacroAssembler::Jump nonIntJump;
     if (!UnaryDoubleOpWrapper(floor) || !jit.supportsFloatingPoint())
-        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCall(vm));
+    {
+        COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCallWithSwap(vm));
+    }
+        COMPILEDPRINTF("%s:%d/%s(): !!! SHOULDN'T BE REACHED !!!\n", __FILE__, __LINE__, __func__);
     jit.loadInt32Argument(0, SpecializedThunkJIT::regT0, nonIntJump);
     jit.returnInt32(SpecializedThunkJIT::regT0);
     nonIntJump.link(&jit);
@@ -733,14 +802,15 @@
     doubleResult.link(&jit);
     jit.returnDouble(SpecializedThunkJIT::fpRegT0);
 #endif // CPU(ARM64)
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "floor");
+    COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "floor");
 }
 
 MacroAssemblerCodeRef ceilThunkGenerator(VM* vm)
 {
     SpecializedThunkJIT jit(vm, 1);
     if (!UnaryDoubleOpWrapper(ceil) || !jit.supportsFloatingPoint())
-        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCall(vm));
+        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCallWithSwap(vm));
     MacroAssembler::Jump nonIntJump;
     jit.loadInt32Argument(0, SpecializedThunkJIT::regT0, nonIntJump);
     jit.returnInt32(SpecializedThunkJIT::regT0);
@@ -756,14 +826,14 @@
     jit.returnInt32(SpecializedThunkJIT::regT0);
     doubleResult.link(&jit);
     jit.returnDouble(SpecializedThunkJIT::fpRegT0);
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "ceil");
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "ceil");
 }
 
 MacroAssemblerCodeRef roundThunkGenerator(VM* vm)
 {
     SpecializedThunkJIT jit(vm, 1);
     if (!UnaryDoubleOpWrapper(jsRound) || !jit.supportsFloatingPoint())
-        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCall(vm));
+        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCallWithSwap(vm));
     MacroAssembler::Jump nonIntJump;
     jit.loadInt32Argument(0, SpecializedThunkJIT::regT0, nonIntJump);
     jit.returnInt32(SpecializedThunkJIT::regT0);
@@ -790,40 +860,41 @@
     jit.returnInt32(SpecializedThunkJIT::regT0);
     doubleResult.link(&jit);
     jit.returnDouble(SpecializedThunkJIT::fpRegT0);
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "round");
+
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "round");
 }
 
 MacroAssemblerCodeRef expThunkGenerator(VM* vm)
 {
     if (!UnaryDoubleOpWrapper(exp))
-        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCall(vm));
+        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCallWithSwap(vm));
     SpecializedThunkJIT jit(vm, 1);
     if (!jit.supportsFloatingPoint())
-        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCall(vm));
+        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCallWithSwap(vm));
     jit.loadDoubleArgument(0, SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::regT0);
     jit.callDoubleToDoublePreservingReturn(UnaryDoubleOpWrapper(exp));
     jit.returnDouble(SpecializedThunkJIT::fpRegT0);
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "exp");
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "exp");
 }
 
 MacroAssemblerCodeRef logThunkGenerator(VM* vm)
 {
     if (!UnaryDoubleOpWrapper(log))
-        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCall(vm));
+        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCallWithSwap(vm));
     SpecializedThunkJIT jit(vm, 1);
     if (!jit.supportsFloatingPoint())
-        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCall(vm));
+        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCallWithSwap(vm));
     jit.loadDoubleArgument(0, SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::regT0);
     jit.callDoubleToDoublePreservingReturn(UnaryDoubleOpWrapper(log));
     jit.returnDouble(SpecializedThunkJIT::fpRegT0);
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "log");
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "log");
 }
 
 MacroAssemblerCodeRef absThunkGenerator(VM* vm)
 {
     SpecializedThunkJIT jit(vm, 1);
     if (!jit.supportsFloatingPointAbs())
-        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCall(vm));
+        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCallWithSwap(vm));
     MacroAssembler::Jump nonIntJump;
     jit.loadInt32Argument(0, SpecializedThunkJIT::regT0, nonIntJump);
     jit.rshift32(SpecializedThunkJIT::regT0, MacroAssembler::TrustedImm32(31), SpecializedThunkJIT::regT1);
@@ -836,14 +907,17 @@
     jit.loadDoubleArgument(0, SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::regT0);
     jit.absDouble(SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::fpRegT1);
     jit.returnDouble(SpecializedThunkJIT::fpRegT1);
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "abs");
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "abs");
 }
 
 MacroAssemblerCodeRef powThunkGenerator(VM* vm)
 {
     SpecializedThunkJIT jit(vm, 2);
+
+    jit.dprint("JIT@% 3d: powThunkGenerator\n", jit.getgencount());
+
     if (!jit.supportsFloatingPoint())
-        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCall(vm));
+        return MacroAssemblerCodeRef::createSelfManagedCodeRef(vm->jitStubs->ctiNativeCallWithSwap(vm));
 
     jit.loadDouble(&oneConstant, SpecializedThunkJIT::fpRegT1);
     jit.loadDoubleArgument(0, SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::regT0);
@@ -888,7 +962,7 @@
     } else
         jit.appendFailure(nonIntExponent);
 
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "pow");
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "pow");
 }
 
 MacroAssemblerCodeRef imulThunkGenerator(VM* vm)
@@ -921,7 +995,7 @@
     } else
         jit.appendFailure(nonIntArg1Jump);
 
-    return jit.finalize(vm->jitStubs->ctiNativeCall(vm), "imul");
+    return jit.finalize(vm->jitStubs->ctiNativeCallWithSwap(vm), "imul");
 }
 
 static MacroAssemblerCodeRef arrayIteratorNextThunkGenerator(VM* vm, ArrayIterationKind kind)
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/jit/ThunkGenerators.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/ThunkGenerators.h
--- clean/WebKit.161078/Source/JavaScriptCore/jit/ThunkGenerators.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/jit/ThunkGenerators.h	2018-06-12 14:28:02.369668991 +0000
@@ -42,6 +42,7 @@
 MacroAssemblerCodeRef virtualConstructThunkGenerator(VM*);
 
 MacroAssemblerCodeRef nativeCallGenerator(VM*);
+MacroAssemblerCodeRef nativeCallGeneratorWithSwap(VM*);
 MacroAssemblerCodeRef nativeConstructGenerator(VM*);
 MacroAssemblerCodeRef arityFixup(VM*);
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/llint/LLIntOfflineAsmConfig.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/LLIntOfflineAsmConfig.h
--- clean/WebKit.161078/Source/JavaScriptCore/llint/LLIntOfflineAsmConfig.h	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/LLIntOfflineAsmConfig.h	2018-06-12 14:28:02.369668991 +0000
@@ -43,6 +43,7 @@
 #define OFFLINE_ASM_ARMv7s 0
 #define OFFLINE_ASM_MIPS 0
 #define OFFLINE_ASM_SH4 0
+#define OFFLINE_ASM_PPC 0
 
 #else // !ENABLE(LLINT_C_LOOP)
 
@@ -97,6 +98,12 @@
 #define OFFLINE_ASM_SH4 0
 #endif
 
+#if CPU(PPC)
+#define OFFLINE_ASM_PPC 1
+#else
+#define OFFLINE_ASM_PPC 0
+#endif
+
 #if CPU(ARM64)
 #define OFFLINE_ASM_ARM64 1
 #else
@@ -166,4 +173,10 @@
 #define OFFLINE_ASM_VALUE_PROFILER 0
 #endif
 
+#if OS(DARWIN) && CPU(PPC)
+#define OFFLINE_ASM_FOUR_BYTE_BOOL 1
+#else
+#define OFFLINE_ASM_FOUR_BYTE_BOOL 0
+#endif
+
 #endif // LLIntOfflineAsmConfig_h
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp	2018-05-20 14:50:44.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp	2018-06-25 09:52:41.924269767 +0000
@@ -79,6 +79,7 @@
 #define LLINT_OP_C(index) (exec->r(pc[index].u.operand))
 
 #define LLINT_RETURN_TWO(first, second) do {       \
+    VALUEDPRINTF("%s:%d/%s(): LLINT_RETURN_TWO: first 0x%08x, second 0x%08x\n", __FILE__, __LINE__, __func__, first, second); \
         return encodeResult(first, second);        \
     } while (false)
 
@@ -324,6 +325,9 @@
 enum EntryKind { Prologue, ArityCheck };
 static SlowPathReturnType entryOSR(ExecState* exec, Instruction*, CodeBlock* codeBlock, const char *name, EntryKind kind)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, codeBlock 0x%08x, name 0x%08x, kind %d\n", __FILE__, __LINE__, __func__, exec, codeBlock, name, kind);
+    CALLBACKDPRINTF("%s:%d/%s(): name \"%s\"\n", __FILE__, __LINE__, __func__, name);
+
     if (Options::verboseOSR()) {
         dataLog(
             *codeBlock, ": Entered ", name, " with executeCounter = ",
@@ -331,14 +335,24 @@
     }
     
     if (!shouldJIT(exec)) {
+        CALLBACKDPRINTF("%s:%d/%s(): !shouldJIT(exec)\n", __FILE__, __LINE__, __func__);
         codeBlock->dontJITAnytimeSoon();
         LLINT_RETURN_TWO(0, exec);
     }
+    CALLBACKDPRINTF("%s:%d/%s(): shouldJIT(exec)\n", __FILE__, __LINE__, __func__);
     if (!jitCompileAndSetHeuristics(codeBlock, exec))
+    {
+        CALLBACKDPRINTF("%s:%d/%s(): !jitCompileAndSetHeuristics(codeBlock, exec)\n", __FILE__, __LINE__, __func__);
         LLINT_RETURN_TWO(0, exec);
+    }
     
+    CALLBACKDPRINTF("%s:%d/%s(): jitCompileAndSetHeuristics(codeBlock, exec)\n", __FILE__, __LINE__, __func__);
+
     if (kind == Prologue)
+    {
+        CALLBACKDPRINTF("%s:%d/%s(): executing JIT'ed code at 0x%08x\n", __FILE__, __LINE__, __func__, codeBlock->jitCode()->executableAddress());
         LLINT_RETURN_TWO(codeBlock->jitCode()->executableAddress(), exec);
+    }
     ASSERT(kind == ArityCheck);
     LLINT_RETURN_TWO(codeBlock->jitCodeWithArityCheck().executableAddress(), exec);
 }
@@ -509,15 +523,23 @@
 
 LLINT_SLOW_PATH_DECL(slow_path_get_by_id)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     LLINT_BEGIN();
     CodeBlock* codeBlock = exec->codeBlock();
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     const Identifier& ident = codeBlock->identifier(pc[3].u.operand);
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     JSValue baseValue = LLINT_OP_C(2).jsValue();
+    CALLBACKDPRINTF("%s:%d/%s(): baseValue 0x%016llx\n", __FILE__, __LINE__, __func__, JSValue::encode(baseValue));
     PropertySlot slot(baseValue);
 
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     JSValue result = baseValue.get(exec, ident, slot);
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     LLINT_CHECK_EXCEPTION();
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     LLINT_OP(1) = result;
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     
     if (!LLINT_ALWAYS_ACCESS_SLOW
         && baseValue.isCell()
@@ -525,28 +547,34 @@
         && slot.slotBase() == baseValue
         && slot.isCacheableValue()) {
         
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         JSCell* baseCell = baseValue.asCell();
         Structure* structure = baseCell->structure();
         
         if (!structure->isUncacheableDictionary()
             && !structure->typeInfo().prohibitsPropertyCaching()) {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
             ConcurrentJITLocker locker(codeBlock->m_lock);
             
             pc[4].u.structure.set(
                 vm, codeBlock->ownerExecutable(), structure);
             if (isInlineOffset(slot.cachedOffset())) {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
                 pc[0].u.opcode = LLInt::getOpcode(llint_op_get_by_id);
                 pc[5].u.operand = offsetInInlineStorage(slot.cachedOffset()) * sizeof(JSValue) + JSObject::offsetOfInlineStorage();
             } else {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
                 pc[0].u.opcode = LLInt::getOpcode(llint_op_get_by_id_out_of_line);
                 pc[5].u.operand = offsetInButterfly(slot.cachedOffset()) * sizeof(JSValue);
             }
         }
     }
 
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     if (!LLINT_ALWAYS_ACCESS_SLOW
         && isJSArray(baseValue)
         && ident == exec->propertyNames().length) {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         pc[0].u.opcode = LLInt::getOpcode(llint_op_get_array_length);
 #if ENABLE(VALUE_PROFILER)
         ArrayProfile* arrayProfile = codeBlock->getOrAddArrayProfile(pc - codeBlock->instructions().begin());
@@ -555,6 +583,7 @@
 #endif
     }
 
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
 #if ENABLE(VALUE_PROFILER)    
     pc[OPCODE_LENGTH(op_get_by_id) - 1].u.profile->m_buckets[0] = JSValue::encode(result);
 #endif
@@ -573,16 +602,27 @@
 
 LLINT_SLOW_PATH_DECL(slow_path_put_by_id)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     LLINT_BEGIN();
     CodeBlock* codeBlock = exec->codeBlock();
     const Identifier& ident = codeBlock->identifier(pc[2].u.operand);
     
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     JSValue baseValue = LLINT_OP_C(1).jsValue();
+    CALLBACKDPRINTF("%s:%d/%s(): baseValue 0x%016llx\n", __FILE__, __LINE__, __func__, JSValue::encode(baseValue));
     PutPropertySlot slot(codeBlock->isStrictMode(), codeBlock->putByIdContext());
+    CALLBACKDPRINTF("%s:%d/%s(): LLINT_OP_C(3).jsValue() 0x%016llx\n", __FILE__, __LINE__, __func__, JSValue::encode(LLINT_OP_C(3).jsValue()));
     if (pc[8].u.operand)
+    {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         asObject(baseValue)->putDirect(vm, ident, LLINT_OP_C(3).jsValue(), slot);
+    }
     else
+    {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         baseValue.put(exec, ident, LLINT_OP_C(3).jsValue(), slot);
+    }
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     LLINT_CHECK_EXCEPTION();
     
     if (!LLINT_ALWAYS_ACCESS_SLOW
@@ -1027,6 +1067,8 @@
     dataLogF("Performing call with recorded PC = %p\n", execCallee->callerFrame()->currentVPC());
 #endif
 
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+
     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
     if (!calleeAsFunctionCell)
         return handleHostCall(execCallee, pc, calleeAsValue, kind);
@@ -1037,11 +1079,16 @@
     execCallee->setScope(scope);
     ExecutableBase* executable = callee->executable();
     
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     MacroAssemblerCodePtr codePtr;
     CodeBlock* codeBlock = 0;
     if (executable->isHostFunction())
+    {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         codePtr = executable->hostCodeEntryFor(kind);
+    }
     else {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         FunctionExecutable* functionExecutable = static_cast<FunctionExecutable*>(executable);
         JSObject* error = functionExecutable->prepareForExecution(execCallee, callee->scope(), kind);
         if (error)
@@ -1054,7 +1101,9 @@
             codePtr = functionExecutable->jsCodeEntryFor(kind);
     }
     
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     if (!LLINT_ALWAYS_ACCESS_SLOW && callLinkInfo) {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         ExecState* execCaller = execCallee->callerFrame();
         
         CodeBlock* callerCodeBlock = execCaller->codeBlock();
@@ -1067,14 +1116,19 @@
         callLinkInfo->lastSeenCallee.set(vm, callerCodeBlock->ownerExecutable(), callee);
         callLinkInfo->machineCodeTarget = codePtr;
         if (codeBlock)
+        {
+            foddprintf("%s:%d/%s(): Calling linkIncomingCall\n", __FILE__, __LINE__, __func__);
             codeBlock->linkIncomingCall(execCaller, callLinkInfo);
+        }
     }
 
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     LLINT_CALL_RETURN(execCallee, codePtr.executableAddress());
 }
 
 inline SlowPathReturnType genericCall(ExecState* exec, Instruction* pc, CodeSpecializationKind kind)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, pc 0x%08x\n", __FILE__, __LINE__, __func__, exec, pc);
     // This needs to:
     // - Set up a call frame.
     // - Figure out what to call and compile it if necessary.
@@ -1089,18 +1143,22 @@
     execCallee->uncheckedR(JSStack::Callee) = calleeAsValue;
     execCallee->setCallerFrame(exec);
     
+    CALLBACKDPRINTF("%s:%d/%s(): pc 0x%08x, exec 0x%08x\n", __FILE__, __LINE__, __func__, pc, exec);
+
     ASSERT(pc[5].u.callLinkInfo);
     return setUpCall(execCallee, pc, kind, calleeAsValue, pc[5].u.callLinkInfo);
 }
 
 LLINT_SLOW_PATH_DECL(slow_path_call)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): pc 0x%08x, exec 0x%08x\n", __FILE__, __LINE__, __func__, pc, exec);
     LLINT_BEGIN_NO_SET_PC();
     return genericCall(exec, pc, CodeForCall);
 }
 
 LLINT_SLOW_PATH_DECL(slow_path_construct)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, pc 0x%08x\n", __FILE__, __LINE__, __func__, exec, pc);
     LLINT_BEGIN_NO_SET_PC();
     return genericCall(exec, pc, CodeForConstruct);
 }
@@ -1143,6 +1201,7 @@
 
 LLINT_SLOW_PATH_DECL(slow_path_call_eval)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): pc 0x%08x, exec 0x%08x\n", __FILE__, __LINE__, __func__, pc, exec);
     LLINT_BEGIN_NO_SET_PC();
     JSValue calleeAsValue = LLINT_OP(2).jsValue();
     
@@ -1165,9 +1224,11 @@
 
 LLINT_SLOW_PATH_DECL(slow_path_tear_off_activation)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): pc 0x%08x, exec 0x%08x\n", __FILE__, __LINE__, __func__, pc, exec);
     LLINT_BEGIN();
     ASSERT(exec->codeBlock()->needsFullScopeChain());
     jsCast<JSActivation*>(LLINT_OP(1).jsValue())->tearOff(vm);
+    CALLBACKDPRINTF("%s:%d/%s(): pc 0x%08x, exec 0x%08x\n", __FILE__, __LINE__, __func__, pc, exec);
     LLINT_END();
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter.asm attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter.asm
--- clean/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter.asm	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter.asm	2018-06-12 14:28:02.377669057 +0000
@@ -121,6 +121,11 @@
     const TagOffset = 4
     const PayloadOffset = 0
 end
+if JSVALUE64
+    const CellOffset = 0
+else
+    const CellOffset = PayloadOffset
+end
 
 # Constant for reasoning about butterflies.
 const IsArray                  = 1
@@ -192,7 +197,7 @@
     if C_LOOP
         cloopCrash
     else
-        storei t0, 0xbbadbeef[]
+        break
         move 0, t0
         call t0
     end
@@ -212,6 +217,8 @@
         move lr, destinationRegister
     elsif X86 or X86_64
         pop destinationRegister
+    elsif PPC
+        mflr destinationRegister
     else
         error
     end
@@ -223,6 +230,8 @@
         move sourceRegister, lr
     elsif X86 or X86_64
         push sourceRegister
+    elsif PPC
+        mtlr sourceRegister
     else
         error
     end
@@ -267,7 +276,7 @@
 
 macro checkSwitchToJIT(increment, action)
     if JIT_ENABLED
-        loadp CodeBlock[cfr], t0
+        loadp CodeBlock + PayloadOffset[cfr], t0
         baddis increment, CodeBlock::m_llintExecuteCounter + ExecutionCounter::m_counter[t0], .continue
         action()
     .continue:
@@ -287,23 +296,23 @@
 end
 
 macro functionForCallCodeBlockGetter(targetRegister)
-    loadp Callee[cfr], targetRegister
+    loadp Callee + CellOffset[cfr], targetRegister
     loadp JSFunction::m_executable[targetRegister], targetRegister
     loadp FunctionExecutable::m_codeBlockForCall[targetRegister], targetRegister
 end
 
 macro functionForConstructCodeBlockGetter(targetRegister)
-    loadp Callee[cfr], targetRegister
+    loadp Callee + CellOffset[cfr], targetRegister
     loadp JSFunction::m_executable[targetRegister], targetRegister
     loadp FunctionExecutable::m_codeBlockForConstruct[targetRegister], targetRegister
 end
 
 macro notFunctionCodeBlockGetter(targetRegister)
-    loadp CodeBlock[cfr], targetRegister
+    loadp CodeBlock + PayloadOffset[cfr], targetRegister
 end
 
 macro functionCodeBlockSetter(sourceRegister)
-    storep sourceRegister, CodeBlock[cfr]
+    storep sourceRegister, CodeBlock + PayloadOffset[cfr]
 end
 
 macro notFunctionCodeBlockSetter(sourceRegister)
@@ -421,8 +430,6 @@
     ret
 end
 
-if C_LOOP
-else
 # stub to call into JavaScript or Native functions
 # EncodedJSValue callToJavaScript(void* code, ExecState** vm, ProtoCallFrame* protoFrame, Register* topOfStack)
 # EncodedJSValue callToNativeFunction(void* code, ExecState** vm, ProtoCallFrame* protoFrame, Register* topOfStack)
@@ -433,7 +440,6 @@
 
 _callToNativeFunction:
     doCallToJavaScript(makeHostFunctionCall, doReturnFromHostFunction)
-end
 
 # Indicate the beginning of LLInt.
 _llint_begin:
@@ -685,9 +691,13 @@
 
 _llint_op_loop_hint:
     traceExecution()
-    loadp CodeBlock[cfr], t1
+    loadp CodeBlock + PayloadOffset[cfr], t1
     loadp CodeBlock::m_vm[t1], t1
-    loadb VM::watchdog+Watchdog::m_timerDidFire[t1], t0
+    if FOUR_BYTE_BOOL
+        loadi VM::watchdog+Watchdog::m_timerDidFire[t1], t0
+    else
+        loadb VM::watchdog+Watchdog::m_timerDidFire[t1], t0
+    end
     btbnz t0, .handleWatchdogTimer
 .afterWatchdogTimerCheck:
     checkSwitchToJITForLoop()
@@ -828,11 +838,15 @@
 _llint_op_debug:
 if JAVASCRIPT_DEBUGGER
     traceExecution()
-    loadp CodeBlock[cfr], t0
+    loadp CodeBlock + PayloadOffset[cfr], t0
     loadp CodeBlock::m_globalObject[t0], t0
     loadp JSGlobalObject::m_debugger[t0], t0
     btiz t0, .opDebugDone
-    loadb Debugger::m_needsOpDebugCallbacks[t0], t0
+    if FOUR_BYTE_BOOL
+        loadi Debugger::m_needsOpDebugCallbacks[t0], t0
+    else
+        loadb Debugger::m_needsOpDebugCallbacks[t0], t0
+    end
     btbz t0, .opDebugDone
 
     callSlowPath(_llint_slow_path_debug)
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter32_64.asm attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter32_64.asm
--- clean/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter32_64.asm	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter32_64.asm	2018-06-12 14:28:02.377669057 +0000
@@ -97,7 +97,7 @@
 end
 
 macro cCall2(function, arg1, arg2)
-    if ARM or ARMv7 or ARMv7_TRADITIONAL or MIPS
+    if ARM or ARMv7 or ARMv7_TRADITIONAL or MIPS or PPC
         move arg1, a0
         move arg2, a1
         call function
@@ -117,7 +117,7 @@
 
 # This barely works. arg3 and arg4 should probably be immediates.
 macro cCall4(function, arg1, arg2, arg3, arg4)
-    if ARM or ARMv7 or ARMv7_TRADITIONAL or MIPS
+    if ARM or ARMv7 or ARMv7_TRADITIONAL or MIPS or PPC
         move arg1, a0
         move arg2, a1
         move arg3, a2
@@ -146,28 +146,65 @@
 end
 
 macro functionPrologue(extraStackSpace)
-    if X86
-        push cfr
-        move sp, cfr
-    end
-    pushCalleeSaves
-    if ARM or ARMv7 or ARMv7_TRADITIONAL or MIPS
-        push cfr
-        push lr
+    if PPC
+        stwu r1, -64[r1]
+        mflr r0
+        storep r0, 68[r1]
+        storep r31, 60[r1]
+        storep r30, 56[r1]
+        storep r29, 52[r1]
+        storep r28, 48[r1]
+
+        storep r20, 44[r1]
+        storep r19, 40[r1]
+        storep r18, 36[r1]
+        storep r17, 32[r1]
+        storep r16, 28[r1]
+        storep r15, 24[r1]
+        storep r14, 20[r1]
+        storep r13, 16[r1]
+    else
+        if X86
+            push cfr
+            move sp, cfr
+        end
+        pushCalleeSaves
+        if ARM or ARMv7 or ARMv7_TRADITIONAL or MIPS
+            push cfr
+            push lr
+        end
+        subp extraStackSpace, sp
     end
-    subp extraStackSpace, sp
 end
 
 macro functionEpilogue(extraStackSpace)
-    addp extraStackSpace, sp
-    if ARM or ARMv7 or ARMv7_TRADITIONAL or MIPS
-        pop lr
-        pop cfr
-    end
-    popCalleeSaves
-    if X86
-        pop cfr
-    end
+    if PPC
+        loadp 68[r1], r0
+        mtlr r0
+        loadp 60[r1], r31
+        loadp 56[r1], r30
+        loadp 52[r1], r29
+        loadp 48[r1], r28
+        loadp 44[r1], r20
+        loadp 40[r1], r19
+        loadp 36[r1], r18
+        loadp 32[r1], r17
+        loadp 28[r1], r16
+        loadp 24[r1], r15
+        loadp 20[r1], r14
+        loadp 16[r1], r13
+        addp 64, r1
+    else
+        addp extraStackSpace, sp
+        if ARM or ARMv7 or ARMv7_TRADITIONAL or MIPS or PPC
+            pop lr
+            pop cfr
+        end
+        popCalleeSaves
+        if X86
+            pop cfr
+        end
+     end
 end
 
 macro doCallToJavaScript(makeCall, doReturn)
@@ -235,6 +272,19 @@
         const temp2 = a3 # Same as topOfStack
         const temp3 = t8
         const temp4 = t9
+    elsif PPC
+        const entry = a0
+        const vmTopCallFrame = a1
+        const protoCallFrame = a2
+        const topOfStack = a3
+
+        const extraStackSpace = 32
+        const previousCFR = t4
+        const previousPC = lr
+        const temp1 = t4 # Same as previousCFR
+        const temp2 = t5
+        const temp3 = t6
+        const temp4 = t7
     end
 
     if X86
@@ -255,13 +305,13 @@
     subp (CallFrameHeaderSlots-1)*8, cfr
     storep 0, ArgumentCount+4[cfr]
     storep 0, ArgumentCount[cfr]
-    storep 0, Callee+4[cfr]
-    storep vmTopCallFrame, Callee[cfr]
+    storep 0, Callee + TagOffset[cfr]
+    storep vmTopCallFrame, Callee + PayloadOffset[cfr]
     loadp [vmTopCallFrame], temp4
-    storep 0, ScopeChain+4[cfr]
-    storep temp4, ScopeChain[cfr]
-    storep 0, CodeBlock+4[cfr]
-    storep 1, CodeBlock[cfr]
+    storep 0, ScopeChain + TagOffset[cfr]
+    storep temp4, ScopeChain + PayloadOffset[cfr]
+    storep 0, CodeBlock + TagOffset[cfr]
+    storep 1, CodeBlock + PayloadOffset[cfr]
     storep previousPC, ReturnPC[cfr]
     storep previousCFR, CallerFrame[cfr]
     move cfr, temp1
@@ -282,7 +332,7 @@
     storep temp3, CodeBlock+4[cfr, temp1, 8]
     btinz temp1, .copyHeaderLoop
 
-    loadi ProtoCallFrame::argCountAndCodeOriginValue[protoCallFrame], temp2
+    loadi ProtoCallFrame::argCountAndCodeOriginValue + PayloadOffset[protoCallFrame], temp2
     subi 1, temp2
     loadi ProtoCallFrame::paddedArgCount[protoCallFrame], temp3
     subi 1, temp3
@@ -316,12 +366,12 @@
 
     makeCall(entry, temp1)
 
-    bpeq CodeBlock[cfr], 1, .calleeFramePopped
+    bpeq CodeBlock + PayloadOffset[cfr], 1, .calleeFramePopped
     loadp CallerFrame[cfr], cfr
 
 .calleeFramePopped:
-    loadp Callee[cfr], temp3 # VM.topCallFrame
-    loadp ScopeChain[cfr], temp4
+    loadp Callee + PayloadOffset[cfr], temp3 # VM.topCallFrame
+    loadp ScopeChain + PayloadOffset[cfr], temp4
     storep temp4, [temp3]
 
     doReturn(extraStackSpace)
@@ -417,7 +467,7 @@
     loadi PayloadOffset[cfr, index, 8], payload
     jmp .done
 .constant:
-    loadp CodeBlock[cfr], payload
+    loadp CodeBlock + PayloadOffset[cfr], payload
     loadp CodeBlock::m_constantRegisters + VectorBufferOffset[payload], payload
     # There is a bit of evil here: if the index contains a value >= FirstConstantRegisterIndex,
     # then value << 3 will be equal to (value - FirstConstantRegisterIndex) << 3.
@@ -431,7 +481,7 @@
     loadi TagOffset[cfr, index, 8], tag
     jmp .done
 .constant:
-    loadp CodeBlock[cfr], tag
+    loadp CodeBlock + PayloadOffset[cfr], tag
     loadp CodeBlock::m_constantRegisters + VectorBufferOffset[tag], tag
     # There is a bit of evil here: if the index contains a value >= FirstConstantRegisterIndex,
     # then value << 3 will be equal to (value - FirstConstantRegisterIndex) << 3.
@@ -446,7 +496,7 @@
     loadi PayloadOffset[cfr, index, 8], payload
     jmp .done
 .constant:
-    loadp CodeBlock[cfr], tag
+    loadp CodeBlock + PayloadOffset[cfr], tag
     loadp CodeBlock::m_constantRegisters + VectorBufferOffset[tag], tag
     # There is a bit of evil here: if the index contains a value >= FirstConstantRegisterIndex,
     # then value << 3 will be equal to (value - FirstConstantRegisterIndex) << 3.
@@ -463,7 +513,7 @@
     loadi PayloadOffset[cfr, index, 8], payload
     jmp .done
 .constant:
-    loadp CodeBlock[cfr], payload
+    loadp CodeBlock + PayloadOffset[cfr], payload
     loadp CodeBlock::m_constantRegisters + VectorBufferOffset[payload], payload
     # There is a bit of evil here: if the index contains a value >= FirstConstantRegisterIndex,
     # then value << 3 will be equal to (value - FirstConstantRegisterIndex) << 3.
@@ -545,14 +595,14 @@
     addp t1, cfr
 .continue:
     # Reload CodeBlock and PC, since the slow_path clobbered it.
-    loadp CodeBlock[cfr], t1
+    loadp CodeBlock + PayloadOffset[cfr], t1
     loadp CodeBlock::m_instructions[t1], PC
     jmp doneLabel
 end
 
 
 macro branchIfException(label)
-    loadp ScopeChain[cfr], t3
+    loadp ScopeChain + PayloadOffset[cfr], t3
     andp MarkedBlockMask, t3
     loadp MarkedBlock::m_weakSet + WeakSet::m_vm[t3], t3
     bieq VM::m_exception + TagOffset[t3], EmptyValueTag, .noException
@@ -565,7 +615,7 @@
 
 _llint_op_enter:
     traceExecution()
-    loadp CodeBlock[cfr], t2                // t2<CodeBlock> = cfr.CodeBlock
+    loadp CodeBlock + PayloadOffset[cfr], t2                // t2<CodeBlock> = cfr.CodeBlock
     loadi CodeBlock::m_numVars[t2], t2      // t2<size_t> = t2<CodeBlock>.m_numVars
     btiz t2, .opEnterDone
     move UndefinedTag, t0
@@ -768,7 +818,7 @@
     move 0, t1
     jmp .opEqNullNotImmediate
 .opEqNullMasqueradesAsUndefined:
-    loadp CodeBlock[cfr], t0
+    loadp CodeBlock + PayloadOffset[cfr], t0
     loadp CodeBlock::m_globalObject[t0], t0
     cpeq Structure::m_globalObject[t1], t0, t1
     jmp .opEqNullNotImmediate
@@ -815,7 +865,7 @@
     move 1, t1
     jmp .opNeqNullNotImmediate
 .opNeqNullMasqueradesAsUndefined:
-    loadp CodeBlock[cfr], t0
+    loadp CodeBlock + PayloadOffset[cfr], t0
     loadp CodeBlock::m_globalObject[t0], t0
     cpneq Structure::m_globalObject[t1], t0, t1
     jmp .opNeqNullNotImmediate
@@ -1176,7 +1226,7 @@
     storei t1, PayloadOffset[cfr, t0, 8]
     dispatch(3)
 .opIsUndefinedMasqueradesAsUndefined:
-    loadp CodeBlock[cfr], t3
+    loadp CodeBlock + PayloadOffset[cfr], t3
     loadp CodeBlock::m_globalObject[t3], t3
     cpeq Structure::m_globalObject[t1], t3, t1
     storei t1, PayloadOffset[cfr, t0, 8]
@@ -1485,7 +1535,11 @@
 .opGetByValOutOfBounds:
     if VALUE_PROFILER
         loadpFromInstruction(4, t0)
-        storeb 1, ArrayProfile::m_outOfBounds[t0]
+        if FOUR_BYTE_BOOL
+            storei 1, ArrayProfile::m_outOfBounds[t0]
+        else
+            storeb 1, ArrayProfile::m_outOfBounds[t0]
+        end
     end
 .opGetByValSlow:
     callSlowPath(_llint_slow_path_get_by_val)
@@ -1529,7 +1583,7 @@
     loadp JSCell::m_structure[t2], t0
     bpneq t0, JSPropertyNameIterator::m_cachedStructure[t3], .opGetByPnameSlow
     loadi 24[PC], t0
-    loadi [cfr, t0, 8], t0
+    loadi PayloadOffset[cfr, t0, 8], t0
     subi 1, t0
     biaeq t0, JSPropertyNameIterator::m_numCacheableSlots[t3], .opGetByPnameSlow
     bilt t0, JSPropertyNameIterator::m_cachedStructureInlineCapacity[t3], .opGetByPnameInlineProperty
@@ -1558,7 +1612,11 @@
     biaeq t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.vectorLength[t0], .opPutByValOutOfBounds
     if VALUE_PROFILER
         loadp 16[PC], t2
-        storeb 1, ArrayProfile::m_mayStoreToHole[t2]
+        if FOUR_BYTE_BOOL
+            storei 1, ArrayProfile::m_mayStoreToHole[t2]
+        else
+            storeb 1, ArrayProfile::m_mayStoreToHole[t2]
+        end
     end
     addi 1, t3, t2
     storei t2, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0]
@@ -1628,7 +1686,11 @@
 .opPutByValArrayStorageEmpty:
     if VALUE_PROFILER
         loadp 16[PC], t1
-        storeb 1, ArrayProfile::m_mayStoreToHole[t1]
+        if FOUR_BYTE_BOOL
+            storei 1, ArrayProfile::m_mayStoreToHole[t1]
+        else
+            storeb 1, ArrayProfile::m_mayStoreToHole[t1]
+        end
     end
     addi 1, ArrayStorage::m_numValuesInVector[t0]
     bib t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0], .opPutByValArrayStorageStoreResult
@@ -1639,7 +1701,11 @@
 .opPutByValOutOfBounds:
     if VALUE_PROFILER
         loadpFromInstruction(4, t0)
-        storeb 1, ArrayProfile::m_outOfBounds[t0]
+        if FOUR_BYTE_BOOL
+            storei 1, ArrayProfile::m_outOfBounds[t0]
+        else
+            storeb 1, ArrayProfile::m_outOfBounds[t0]
+        end
     end
 .opPutByValSlow:
     callSlowPath(slowPath)
@@ -1699,7 +1765,7 @@
     equalNull(
         macro (structure, value, target) 
             btbz value, MasqueradesAsUndefined, .opJeqNullNotMasqueradesAsUndefined
-            loadp CodeBlock[cfr], t0
+            loadp CodeBlock + PayloadOffset[cfr], t0
             loadp CodeBlock::m_globalObject[t0], t0
             bpeq Structure::m_globalObject[structure], t0, target
 .opJeqNullNotMasqueradesAsUndefined:
@@ -1712,7 +1778,7 @@
     equalNull(
         macro (structure, value, target) 
             btbz value, MasqueradesAsUndefined, target 
-            loadp CodeBlock[cfr], t0
+            loadp CodeBlock + PayloadOffset[cfr], t0
             loadp CodeBlock::m_globalObject[t0], t0
             bpneq Structure::m_globalObject[structure], t0, target
         end,
@@ -1723,7 +1789,7 @@
     traceExecution()
     loadi 4[PC], t0
     loadi 8[PC], t1
-    loadp CodeBlock[cfr], t2
+    loadp CodeBlock + PayloadOffset[cfr], t2
     loadp CodeBlock::m_globalObject[t2], t2
     bineq TagOffset[cfr, t0, 8], CellTag, .opJneqPtrBranch
     loadp JSGlobalObject::m_specialPointers[t2, t1, 4], t1
@@ -1778,7 +1844,7 @@
     loadi 12[PC], t2
     loadi 4[PC], t3
     loadConstantOrVariable(t2, t1, t0)
-    loadp CodeBlock[cfr], t2
+    loadp CodeBlock + PayloadOffset[cfr], t2
     loadp CodeBlock::m_rareData[t2], t2
     muli sizeof SimpleJumpTable, t3   # FIXME: would be nice to peephole this!
     loadp CodeBlock::RareData::m_switchJumpTables + VectorBufferOffset[t2], t2
@@ -1806,7 +1872,7 @@
     loadi 12[PC], t2
     loadi 4[PC], t3
     loadConstantOrVariable(t2, t1, t0)
-    loadp CodeBlock[cfr], t2
+    loadp CodeBlock + PayloadOffset[cfr], t2
     loadp CodeBlock::m_rareData[t2], t2
     muli sizeof SimpleJumpTable, t3
     loadp CodeBlock::RareData::m_switchJumpTables + VectorBufferOffset[t2], t2
@@ -1966,7 +2032,7 @@
     loadi 20[PC], t2
     loadi PayloadOffset[cfr, t2, 8], t2
     loadp JSPropertyNameIterator::m_jsStrings[t2], t3
-    loadi [t3, t0, 8], t3
+    loadi PayloadOffset[t3, t0, 8], t3
     addi 1, t0
     storei t0, PayloadOffset[cfr, t1, 8]
     loadi 4[PC], t1
@@ -2003,7 +2069,7 @@
     # the interpreter's throw trampoline (see _llint_throw_trampoline).
     # The throwing code must have known that we were throwing to the interpreter,
     # and have set VM::targetInterpreterPCForThrow.
-    loadp ScopeChain[cfr], t3
+    loadp ScopeChain + PayloadOffset[cfr], t3
     andp MarkedBlockMask, t3
     loadp MarkedBlock::m_weakSet + WeakSet::m_vm[t3], t3
     loadp VM::callFrameForThrow[t3], cfr
@@ -2029,9 +2095,13 @@
 
     btiz t2, .done
 
-    loadp CodeBlock[cfr], t1
+    loadp CodeBlock + PayloadOffset[cfr], t1
     bineq CodeBlock::m_codeType[t1], FunctionCode, .loop
-    btbz CodeBlock::m_needsActivation[t1], .loop
+    if FOUR_BYTE_BOOL
+        btiz CodeBlock::m_needsActivation[t1], .loop
+    else
+        btbz CodeBlock::m_needsActivation[t1], .loop
+    end
 
     loadi CodeBlock::m_activationRegister[t1], t1
 
@@ -2069,7 +2139,7 @@
     # When throwing from the interpreter (i.e. throwing from LLIntSlowPaths), so
     # the throw target is not necessarily interpreted code, we come to here.
     # This essentially emulates the JIT's throwing protocol.
-    loadp CodeBlock[cfr], t1
+    loadp CodeBlock + PayloadOffset[cfr], t1
     loadp CodeBlock::m_vm[t1], t1
     jmp VM::targetMachinePCForThrow[t1]
 
@@ -2080,13 +2150,13 @@
 
 
 macro nativeCallTrampoline(executableOffsetToFunction)
-    storep 0, CodeBlock[cfr]
+    storep 0, CodeBlock + PayloadOffset[cfr]
     loadp CallerFrame[cfr], t0
     loadi ScopeChain + PayloadOffset[t0], t1
     storei CellTag, ScopeChain + TagOffset[cfr]
     storei t1, ScopeChain + PayloadOffset[cfr]
     if X86
-        loadp ScopeChain[cfr], t3
+        loadp ScopeChain + PayloadOffset[cfr], t3
         andp MarkedBlockMask, t3
         loadp MarkedBlock::m_weakSet + WeakSet::m_vm[t3], t3
         storep cfr, VM::topCallFrame[t3]
@@ -2099,11 +2169,11 @@
         move t0, cfr
         call executableOffsetToFunction[t1]
         addp 16 - 4, sp
-        loadp ScopeChain[cfr], t3
+        loadp ScopeChain + PayloadOffset[cfr], t3
         andp MarkedBlockMask, t3
         loadp MarkedBlock::m_weakSet + WeakSet::m_vm[t3], t3
-    elsif ARM or ARMv7 or ARMv7_TRADITIONAL or MIPS or SH4
-        loadp ScopeChain[cfr], t3
+    elsif ARM or ARMv7 or ARMv7_TRADITIONAL or MIPS or SH4 or PPC
+        loadp ScopeChain + PayloadOffset[cfr], t3
         andp MarkedBlockMask, t3
         loadp MarkedBlock::m_weakSet + WeakSet::m_vm[t3], t3
         storep cfr, VM::topCallFrame[t3]
@@ -2118,12 +2188,15 @@
             move t0, a0
         end
         call executableOffsetToFunction[t1]
+        move t0, t2
+        move t1, t0
+        move t2, t1
         restoreReturnAddressBeforeReturn(t3)
-        loadp ScopeChain[cfr], t3
+        loadp ScopeChain + PayloadOffset[cfr], t3
         andp MarkedBlockMask, t3
         loadp MarkedBlock::m_weakSet + WeakSet::m_vm[t3], t3
     elsif C_LOOP
-        loadp ScopeChain[cfr], t3
+        loadp ScopeChain + PayloadOffset[cfr], t3
         andp MarkedBlockMask, t3
         loadp MarkedBlock::m_weakSet + WeakSet::m_vm[t3], t3
         storep cfr, VM::topCallFrame[t3]
@@ -2136,7 +2209,7 @@
         move t2, cfr
         cloopCallNative executableOffsetToFunction[t1]
         restoreReturnAddressBeforeReturn(t3)
-        loadp ScopeChain[cfr], t3
+        loadp ScopeChain + PayloadOffset[cfr], t3
         andp MarkedBlockMask, t3
         loadp MarkedBlock::m_weakSet + WeakSet::m_vm[t3], t3
     else
@@ -2153,7 +2226,7 @@
 
 
 macro getGlobalObject(dst)
-    loadp CodeBlock[cfr], t0
+    loadp CodeBlock + PayloadOffset[cfr], t0
     loadp CodeBlock::m_globalObject[t0], t0
     loadisFromInstruction(dst, t1)
     storei CellTag, TagOffset[cfr, t1, 8]
@@ -2161,22 +2234,26 @@
 end
 
 macro varInjectionCheck(slowPath)
-    loadp CodeBlock[cfr], t0
+    loadp CodeBlock + PayloadOffset[cfr], t0
     loadp CodeBlock::m_globalObject[t0], t0
     loadp JSGlobalObject::m_varInjectionWatchpoint[t0], t0
     bbeq WatchpointSet::m_state[t0], IsInvalidated, slowPath
 end
 
 macro resolveScope()
-    loadp CodeBlock[cfr], t0
+    loadp CodeBlock + PayloadOffset[cfr], t0
     loadisFromInstruction(4, t2)
-    btbz CodeBlock::m_needsActivation[t0], .resolveScopeAfterActivationCheck
+    if FOUR_BYTE_BOOL
+        btiz CodeBlock::m_needsActivation[t0], .resolveScopeAfterActivationCheck
+    else
+        btbz CodeBlock::m_needsActivation[t0], .resolveScopeAfterActivationCheck
+    end
     loadis CodeBlock::m_activationRegister[t0], t1
     btpz PayloadOffset[cfr, t1, 8], .resolveScopeAfterActivationCheck
     addi 1, t2
 
 .resolveScopeAfterActivationCheck:
-    loadp ScopeChain[cfr], t0
+    loadp ScopeChain + PayloadOffset[cfr], t0
     btiz t2, .resolveScopeLoopEnd
 
 .resolveScopeLoop:
@@ -2235,7 +2312,7 @@
 
 macro loadWithStructureCheck(operand, slowPath)
     loadisFromInstruction(operand, t0)
-    loadp [cfr, t0, 8], t0
+    loadp PayloadOffset[cfr, t0, 8], t0
     loadpFromInstruction(5, t1)
     bpneq JSCell::m_structure[t0], t1, slowPath
 end
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter64.asm attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter64.asm
--- clean/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter64.asm	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/LowLevelInterpreter64.asm	2018-06-12 14:28:02.377669057 +0000
@@ -1286,7 +1286,11 @@
 .opGetByValOutOfBounds:
     if VALUE_PROFILER
         loadpFromInstruction(4, t0)
-        storeb 1, ArrayProfile::m_outOfBounds[t0]
+        if FOUR_BYTE_BOOL
+            storei 1, ArrayProfile::m_outOfBounds[t0]
+        else
+            storeb 1, ArrayProfile::m_outOfBounds[t0]
+        end
     end
 .opGetByValSlow:
     callSlowPath(_llint_slow_path_get_by_val)
@@ -1359,7 +1363,11 @@
     biaeq t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.vectorLength[t0], .opPutByValOutOfBounds
     if VALUE_PROFILER
         loadp 32[PB, PC, 8], t2
-        storeb 1, ArrayProfile::m_mayStoreToHole[t2]
+        if FOUR_BYTE_BOOL
+            storei 1, ArrayProfile::m_mayStoreToHole[t2]
+        else
+            storeb 1, ArrayProfile::m_mayStoreToHole[t2]
+        end
     end
     addi 1, t3, t2
     storei t2, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0]
@@ -1425,7 +1433,11 @@
 .opPutByValArrayStorageEmpty:
     if VALUE_PROFILER
         loadpFromInstruction(4, t1)
-        storeb 1, ArrayProfile::m_mayStoreToHole[t1]
+        if FOUR_BYTE_BOOL
+            storei 1, ArrayProfile::m_mayStoreToHole[t1]
+        else
+            storeb 1, ArrayProfile::m_mayStoreToHole[t1]
+        end
     end
     addi 1, ArrayStorage::m_numValuesInVector[t0]
     bib t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0], .opPutByValArrayStorageStoreResult
@@ -1436,7 +1448,11 @@
 .opPutByValOutOfBounds:
     if VALUE_PROFILER
         loadpFromInstruction(4, t0)
-        storeb 1, ArrayProfile::m_outOfBounds[t0]
+        if FOUR_BYTE_BOOL
+            storei 1, ArrayProfile::m_outOfBounds[t0]
+        else
+            storeb 1, ArrayProfile::m_outOfBounds[t0]
+        end
     end
 .opPutByValSlow:
     callSlowPath(slowPath)
@@ -1946,7 +1962,11 @@
 macro resolveScope()
     loadp CodeBlock[cfr], t0
     loadisFromInstruction(4, t2)
-    btbz CodeBlock::m_needsActivation[t0], .resolveScopeAfterActivationCheck
+    if FOUR_BYTE_BOOL
+        btiz CodeBlock::m_needsActivation[t0], .resolveScopeAfterActivationCheck
+    else
+        btbz CodeBlock::m_needsActivation[t0], .resolveScopeAfterActivationCheck
+    end
     loadis CodeBlock::m_activationRegister[t0], t1
     btpz [cfr, t1, 8], .resolveScopeAfterActivationCheck
     addi 1, t2
Binary files clean/WebKit.161078/Source/JavaScriptCore/llint/Programs_LLIntOffsetsExtractor-LLIntOffsetsExtractor.o and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/llint/Programs_LLIntOffsetsExtractor-LLIntOffsetsExtractor.o differ
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/offlineasm/backends.rb attempt-5-161078/WebKit.161078/Source/JavaScriptCore/offlineasm/backends.rb
--- clean/WebKit.161078/Source/JavaScriptCore/offlineasm/backends.rb	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/offlineasm/backends.rb	2018-06-12 14:28:02.381669090 +0000
@@ -28,6 +28,7 @@
 require "x86"
 require "mips"
 require "sh4"
+require "ppc"
 require "cloop"
 
 BACKENDS =
@@ -40,6 +41,7 @@
      "ARM64",
      "MIPS",
      "SH4",
+     "PPC",
      "C_LOOP"
     ]
 
@@ -58,6 +60,7 @@
      "ARM64",
      "MIPS",
      "SH4",
+     "PPC",
      "C_LOOP"
     ]
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/offlineasm/instructions.rb attempt-5-161078/WebKit.161078/Source/JavaScriptCore/offlineasm/instructions.rb
--- clean/WebKit.161078/Source/JavaScriptCore/offlineasm/instructions.rb	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/offlineasm/instructions.rb	2018-06-12 14:28:02.381669090 +0000
@@ -297,6 +297,13 @@
     "setargs"
     ]
 
+PPC_INSTRUCTIONS =
+    [
+    "mflr",
+    "mtlr",
+    "stwu"
+    ]
+
 CXX_INSTRUCTIONS =
     [
      "cloopCrash",           # no operands
@@ -313,7 +320,7 @@
      "cloopDo",              # no operands
     ]
 
-INSTRUCTIONS = MACRO_INSTRUCTIONS + X86_INSTRUCTIONS + ARM64_INSTRUCTIONS + RISC_INSTRUCTIONS + MIPS_INSTRUCTIONS + SH4_INSTRUCTIONS + CXX_INSTRUCTIONS
+INSTRUCTIONS = MACRO_INSTRUCTIONS + X86_INSTRUCTIONS + ARM64_INSTRUCTIONS + RISC_INSTRUCTIONS + MIPS_INSTRUCTIONS + SH4_INSTRUCTIONS + PPC_INSTRUCTIONS + CXX_INSTRUCTIONS
 
 INSTRUCTION_PATTERN = Regexp.new('\\A((' + INSTRUCTIONS.join(')|(') + '))\\Z')
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/offlineasm/ppc.rb attempt-5-161078/WebKit.161078/Source/JavaScriptCore/offlineasm/ppc.rb
--- clean/WebKit.161078/Source/JavaScriptCore/offlineasm/ppc.rb	1970-01-01 00:00:00.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/offlineasm/ppc.rb	2018-06-12 14:28:02.381669090 +0000
@@ -0,0 +1,683 @@
+
+class AbsoluteAddress
+    def ppcOperand
+        raise "Unconverted absolute address at #{codeOriginString}"
+    end
+end
+
+class Address
+    def ppcEmitLea(destination)
+        $asm.puts "addi #{destination.ppcOperand}, #{base.ppcOperand}, \##{offset.value}"
+    end
+
+    def ppcOperand
+        raise "Bad offset at #{codeOriginString}" if offset.value < -0x7fff or offset.value > 0x7fff
+        "#{offset.value}(#{base.ppcOperand})"
+    end
+end
+
+class Immediate
+    def ppcOperand
+        raise "Invalid immediate #{value} at #{codeOriginString}" if value < -32768 or value > 32767
+        "#{value}"
+    end
+end
+
+class Sequence
+    def getModifiedListPPC
+        result = @list
+        result = riscLowerHardBranchOps(result)
+        result = riscLowerShiftOps(result)
+        result = riscLowerMalformedAddresses(result) {
+            | node, address |
+            if address.is_a? BaseIndex
+                address.offset.value == 0
+            elsif address.is_a? Address
+                (-0x7fff..0x7fff).include? address.offset.value
+            elsif address.is_a? AbsoluteAddress
+                true
+            else
+                false
+            end
+        }
+        result = riscLowerMalformedAddressesDouble(result)
+        result = riscLowerMisplacedImmediates(result, ["storeb", "storei", "storep", "storeq"])
+        result = riscLowerMalformedImmediates(result, -0x7fff..0x7fff)
+        result = riscLowerMisplacedAddresses(result)
+        result = ppcLowerBaseIndex(result)
+        result = assignRegistersToTemporaries(result, :gpr, [SpecialRegister.new("%r7"), SpecialRegister.new("%r8"), SpecialRegister.new("%r9"), SpecialRegister.new("%r10")])
+        return result
+    end
+end
+
+class RegisterID
+    def ppcOperand
+        case name
+        when "t0", "a0"
+            "%r3"
+        when "t1", "a1"
+            "%r4"
+        when "t2", "a2"
+            "%r5"
+        when "a3"
+            "%r6"
+        when "t3"
+            "%r15"
+        when "t4"
+            "%r16"
+        when "t5"
+            "%r17"
+        when "t6"
+            "%r18"
+        when "t7"
+            "%r19"
+        when "cfr"
+            "%r14"
+        when "lr"
+            "%notreallylr"
+        when "sp"
+            "%notreallysp"
+        when "r31"
+            "%r31"
+        when "r30"
+            "%r30"
+        when "r29"
+            "%r29"
+        when "r28"
+            "%r28"
+        when "r27"
+            "%r27"
+        when "r26"
+            "%r26"
+        when "r25"
+            "%r25"
+        when "r24"
+            "%r24"
+        when "r23"
+            "%r23"
+        when "r22"
+            "%r22"
+        when "r21"
+            "%r21"
+        when "r20"
+            "%r20"
+        when "r19"
+            "%r19"
+        when "r18"
+            "%r18"
+        when "r17"
+            "%r17"
+        when "r16"
+            "%r16"
+        when "r15"
+            "%r15"
+        when "r14"
+            "%r14"
+        when "r13"
+            "%r13"
+        when "r1"
+            "%r1"
+        when "r0"
+            "%r0"
+        else
+            raise "Bad register #{name} for PPC at #{codeOriginString}"
+        end
+    end
+end
+
+class SpecialRegister
+    def ppcEmitLea(destination)
+        $asm.puts "mr #{destination.ppcOperand}, #{ppcOperand}"
+    end
+
+    def ppcOperand
+        @name
+    end
+end
+
+class FPRegisterID
+    def ppcOperand
+        case name
+        when "ft0", "fr"
+            "%f0"
+        when "ft1"
+            "%f1"
+        when "ft2"
+            "%f2"
+        when "ft3"
+            "%f3"
+        when "ft4"
+            "%f4"
+        when "ft5"
+            "%f5"
+        else
+            raise "Bad register #{name} for PPC at #{codeOriginString}"
+        end
+    end
+end
+
+def ppcOperands(operands)
+    operands.map{|v| v.ppcOperand}.join(", ")
+end
+
+class Instruction
+    def oneOrTwoArgInstruction(ppcinst, ppcimminst)
+        if operands[0].immediate?
+            ppcinst = ppcimminst
+        end
+
+        if operands.size >= 2
+            $asm.puts "#{ppcinst} #{operands[1].ppcOperand}, #{operands[0].ppcOperand}"
+        else
+            $asm.puts "#{ppcinst} #{operands[0].ppcOperand}, #{operands[0].ppcOperand}"
+        end
+    end
+
+    def threeArgInstruction(ppcinst, ppcimminst)
+        raise "Wrong number of arguments" unless operands.size >= 2
+
+        if operands[0].immediate?
+            ppcinst = ppcimminst
+        end
+
+        if operands.size == 3
+            $asm.puts "#{ppcinst} #{operands[2].ppcOperand}, #{operands[1].ppcOperand}, #{operands[0].ppcOperand}"
+        else
+            $asm.puts "#{ppcinst} #{operands[1].ppcOperand}, #{operands[1].ppcOperand}, #{operands[0].ppcOperand}"
+        end
+    end
+
+    def twoArgInstruction(ppcinst, ppcimminst)
+        raise "Wrong number of arguments" unless operands.size >= 2
+
+        if operands[0].immediate?
+            ppcinst = ppcimminst
+        end
+
+        $asm.puts "#{ppcinst} #{operands[1].ppcOperand}, #{operands[0].ppcOperand}"
+    end
+
+    def ppcHandleBranchOp(ppcinst, cond, loadsize, storesize)
+        overflow = false
+
+        case cond
+        when "o"
+            overflow = true
+        when "s"
+            condcode = "lt"
+        when "z"
+            condcode = "eq"
+        when "nz"
+            condcode = "ne"
+        else
+            raise "Unknown condition code #{cond}"
+        end
+
+        if operands[1].is_a? RegisterID or operands[1].is_a? SpecialRegister
+            srcdstreg = operands[1].ppcOperand
+        else
+            srcdstreg = "%r11"
+            ppcEmitLoad([ operands[1], SpecialRegister.new(srcdstreg) ], loadsize);
+        end
+
+        if overflow
+            $stderr.puts "Overflow handling is currently broken, should be doing 31 bit overflow, not 32 bit overflow"
+            if operands[0].is_a? Immediate
+                $asm.puts "li %r12, #{operands[0].ppcOperand}"
+                $asm.puts "#{ppcinst}o #{srcdstreg}, #{srcdstreg}, %r12"
+            else
+                $asm.puts "#{ppcinst}o #{srcdstreg}, #{srcdstreg}, #{operands[0].ppcOperand}"
+            end
+
+            $asm.puts "mfxer %r12"
+            $asm.puts "andis. %r12, %r12, 0x4000"
+            condcode = "ne"
+        else
+            if operands[0].is_a? Immediate
+                $asm.puts "li %r12, #{operands[0].ppcOperand}"
+                $asm.puts "#{ppcinst}. #{srcdstreg}, #{srcdstreg}, %r12"
+            else
+                $asm.puts "#{ppcinst}. #{srcdstreg}, #{srcdstreg}, #{operands[0].ppcOperand}"
+            end
+        end
+
+        if !(operands[1].is_a? RegisterID or operands[1].is_a? SpecialRegister)
+            ppcEmitStore([ SpecialRegister.new(srcdstreg), operands[1] ], storesize);
+        end
+
+        $asm.puts "b#{condcode} #{operands[2].asmLabel}"
+    end
+
+    def lowerPPC
+        $asm.codeOrigin codeOriginString if $enableCodeOriginComments
+        $asm.annotation annotation if $enableInstrAnnotations
+
+        case opcode
+        when "addd"
+            threeArgInstruction("fadd", "faddfixme");
+        when "addi", "addp"
+            threeArgInstruction("add", "addi");
+        when "addis", "addps"
+            if operands[0].immediate?
+                $asm.puts "li %r12, #{operands[0].ppcOperand}"
+                if operands.size == 3
+                    $asm.puts "addo. #{operands[2].ppcOperand}, #{operands[1].ppcOperand}, %r12"
+                else
+                    $asm.puts "addo. #{operands[1].ppcOperand}, #{operands[1].ppcOperand}, %r12"
+                end
+            else
+                threeArgInstruction("addo.", "addo. fixme");
+            end
+        when "andi", "andp"
+            threeArgInstruction("and.", "andi.");
+        when /^baddb/
+            cond = $~.post_match
+            ppcHandleBranchOp("add", cond, "bz", "b")
+        when /^baddi/, /^baddp/
+            cond = $~.post_match
+            ppcHandleBranchOp("add", cond, "wz", "w")
+        when /^bsubb/
+            cond = $~.post_match
+            ppcHandleBranchOp("sub", cond, "bz", "b")
+        when /^bsubi/, /^bsubp/
+            cond = $~.post_match
+            ppcHandleBranchOp("sub", cond, "wz", "w")
+        when "bcd2i"
+            $asm.puts "addi %r1, %r1, -16" # To make Valgrind happy
+            $asm.puts "fctiw %f12, #{operands[0].ppcOperand}"
+            $asm.puts "stfd %f12, 0(%r1)"
+            $asm.puts "lwz #{operands[1].ppcOperand}, 4(%r1)"
+
+            # Convert the integer back into a double
+            $asm.puts "xoris %r12, #{operands[1].ppcOperand}, 0x8000"
+            $asm.puts "stw %r12, 12(%r1)"
+            $asm.puts "lis %r12, 0x4330"
+            $asm.puts "stw %r12, 8(%r1)"
+            $asm.puts "lis %r12, 0x5980"
+            $asm.puts "ori %r12, %r12, 0x0004"
+            $asm.puts "stw %r12, 4(%r1)"
+            $asm.puts "lfs %f13, 4(%r1)"
+            $asm.puts "lfd %f12, 8(%r1)"
+            $asm.puts "fsub %f13, %f12, %f13"
+
+            $asm.puts "addi %r1, %r1, 16"
+
+            # Compare the original float to the converted float
+            $asm.puts "fcmpu %cr0, #{operands[0].ppcOperand}, %f13"
+            $asm.puts "bne #{operands[2].asmLabel}"
+
+            # Also fail if the integer is zero.
+            $asm.puts "cmpw #{operands[1].ppcOperand}, 0"
+            $asm.puts "beq #{operands[2].asmLabel}"
+        when /^borb/
+            cond = $~.post_match
+            ppcHandleBranchOp("or", cond, "bz", "b")
+        when /^bori/, /^borp/
+            cond = $~.post_match
+            ppcHandleBranchOp("or", cond, "wz", "w")
+        when /^bd/
+            cond = $~.post_match
+
+            unorderedmatch = /un$/.match(cond)
+            if (unorderedmatch)
+                cond = unorderedmatch.pre_match
+                unordered = true
+                $asm.puts "fcmpo %cr0, #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+            else
+                unordered = false
+                $asm.puts "fcmpu %cr0, #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+            end
+
+            case cond
+            when "eq"
+                ppcinst = "beq"
+            when "gt"
+                ppcinst = "bgt"
+            when "gteq"
+                ppcinst = "bge"
+            when "lt"
+                ppcinst = "blt"
+            when "lteq"
+                ppcinst = "ble"
+            when "neq"
+                ppcinst = "bne"
+            else
+                ppcinst = "#{opcode} fixme"
+                $asm.puts "#{opcode} fixme"
+            end
+            $asm.puts "#{ppcinst} #{operands[2].asmLabel}"
+
+            if unordered
+                $asm.puts "bso #{operands[2].asmLabel}"
+            end
+        when /^bb/, /^bi/, /^bp/
+            cond = $~.post_match
+
+            ppccmpinst = "cmpw"
+
+            case cond
+            when "a"
+                ppccmpinst = "cmplw"
+                ppcinst = "bgt"
+            when "aeq"
+                ppccmpinst = "cmplw"
+                ppcinst = "bge"
+            when "b"
+                ppccmpinst = "cmplw"
+                ppcinst = "blt"
+            when "beq"
+                ppccmpinst = "cmplw"
+                ppcinst = "ble"
+            when "eq"
+                ppcinst = "beq"
+            when "gt"
+                ppcinst = "bgt"
+            when "gteq"
+                ppcinst = "bge"
+            when "lt"
+                ppcinst = "blt"
+            when "lteq"
+                ppcinst = "ble"
+            when "neq"
+                ppcinst = "bne"
+            else
+                ppcinst = "#{opcode} fixme"
+                $asm.puts "#{opcode} fixme"
+            end
+            if operands[1].is_a? Immediate
+                if ((ppccmpinst == "cmplw" and (operands[1].value < 0 or operands[1].value > 65535)) or (ppccmpinst == "cmpw" and (operands[1].value < -32768 or operands[1].value > 32767)))
+                    upper = (operands[1].value >> 16) & 0xffff
+                    lower = operands[1].value & 0xffff
+                    $asm.puts "lis %r0, #{upper}"
+                    $asm.puts "ori %r0, %r0, #{lower}"
+                    op1 = "%r0"
+                else
+                    ppccmpinst = ppccmpinst + "i"
+                    op1 = operands[1].ppcOperand;
+                end
+            else
+                op1 = operands[1].ppcOperand;
+            end
+
+            $asm.puts "#{ppccmpinst} #{operands[0].ppcOperand}, #{op1}"
+            $asm.puts "#{ppcinst} #{operands[2].asmLabel}"
+        when "bnz"
+            $asm.puts "bne #{operands[0].asmLabel}"
+        when "bo"
+            $asm.puts "mfxer %r12"
+            $asm.puts "andis. %r12, %r12, 0x4000"
+            $asm.puts "bne #{operands[0].asmLabel}"
+        when /^btb/, /^bti/, /^btp/
+            cond = $~.post_match
+
+            if operands.size == 3
+                if operands[1].is_a? Immediate
+                    $asm.puts "andi. %r12, #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+                else
+                    $asm.puts "and. %r12, #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+                end
+
+                destop = operands[2]
+            else
+                $asm.puts "cmpwi #{operands[0].ppcOperand}, 0"
+                destop = operands[1]
+            end
+
+            case cond
+            when "z"
+                ppcinst = "beq"
+            when "nz"
+                ppcinst = "bne"
+            else
+                ppcinst = "#{opcode} fixme"
+                $asm.puts "#{opcode} fixme"
+            end
+            $asm.puts "#{ppcinst} #{destop.asmLabel}"
+        when "break"
+            $asm.puts "twi 31,0,0"
+        when "call"
+            if operands[0].label?
+                $asm.puts "bl #{operands[0].asmLabel}"
+            else
+                $asm.puts "mtctr #{operands[0].ppcOperand}"
+                $asm.puts "bctrl"
+            end
+        when "cbb", "cib", "cpb"
+            if operands[1].is_a? Immediate
+                upper = (operands[1].value >> 16) & 0xffff
+                lower = operands[1].value & 0xffff
+                $asm.puts "lis %r11, #{upper}"
+                $asm.puts "ori %r11, %r11, #{lower}"
+                op1 = "%r11"
+            else
+                op1 = operands[1].ppcOperand
+            end
+            $asm.puts "subfc %r12, #{op1}, #{operands[0].ppcOperand}"
+            $asm.puts "subfe %r12, #{operands[0].ppcOperand}, #{operands[0].ppcOperand}"
+            $asm.puts "neg #{operands[2].ppcOperand}, %r12"
+        when "cbeq", "cieq", "cpeq"
+            if operands[1].is_a? Immediate
+                if operands[1].value < 0 || operands[1].value > 0xffff
+                    upper = (operands[1].value >> 16) & 0xffff
+                    lower = operands[1].value & 0xffff
+
+                    $asm.puts "lis %r12, #{upper}"
+                    $asm.puts "ori %r12, %r12, #{lower}"
+                    $asm.puts "xor #{operands[2].ppcOperand}, #{operands[0].ppcOperand}, %r12"
+                else
+                    $asm.puts "xori #{operands[2].ppcOperand}, #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+                end
+            else
+                $asm.puts "xor #{operands[2].ppcOperand}, #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+            end
+            $asm.puts "cntlzw #{operands[2].ppcOperand}, #{operands[2].ppcOperand}"
+            $asm.puts "rlwinm #{operands[2].ppcOperand}, #{operands[2].ppcOperand}, 27, 5, 31"
+        when "cbneq", "cineq", "cpneq"
+            # Not optimal, but doesn't require temps
+            if operands[1].is_a? Immediate
+                if operands[1].value < 0 || operands[1].value > 0xffff
+                    upper = (operands[1].value >> 16) & 0xffff
+                    lower = operands[1].value & 0xffff
+
+                    $asm.puts "lis %r12, #{upper}"
+                    $asm.puts "ori %r12, %r12, #{lower}"
+                    $asm.puts "xor #{operands[2].ppcOperand}, #{operands[0].ppcOperand}, %r12"
+                else
+                    $asm.puts "xori #{operands[2].ppcOperand}, #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+                end
+            else
+                $asm.puts "xor #{operands[2].ppcOperand}, #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+            end
+            $asm.puts "cntlzw #{operands[2].ppcOperand}, #{operands[2].ppcOperand}"
+            $asm.puts "rlwinm #{operands[2].ppcOperand}, #{operands[2].ppcOperand}, 27, 5, 31"
+            $asm.puts "not #{operands[2].ppcOperand}, #{operands[2].ppcOperand}"
+            $asm.puts "clrlwi #{operands[2].ppcOperand}, #{operands[2].ppcOperand}, 31"
+        when "ci2d"
+            $asm.puts "addi %r1, %r1, -16" # Just to make Valgrind happy
+            $asm.puts "xoris %r0, #{operands[0].ppcOperand}, 0x8000"
+            $asm.puts "stw %r0, 12(%r1)"
+            $asm.puts "lis %r0, 0x4330"
+            $asm.puts "stw %r0, 8(%r1)"
+            $asm.puts "lis %r0, 0x5980"
+            $asm.puts "ori %r0, %r0, 0x0004"
+            $asm.puts "stw %r0, 4(%r1)"
+            $asm.puts "lfs %f13, 4(%r1)"
+            $asm.puts "lfd %f12, 8(%r1)"
+            $asm.puts "fsub #{operands[1].ppcOperand}, %f12, %f13"
+            $asm.puts "addi %r1, %r1, 16"
+        when "divd"
+            threeArgInstruction("fdiv", "fdivfixme");
+        when "fd2ii"
+            $asm.puts "addi %r1, %r1, -16" # To make Valgrind happy
+            $asm.puts "stfd #{operands[0].ppcOperand}, 0(%r1)"
+            $asm.puts "lwz #{operands[2].ppcOperand}, 0(%r1)"
+            $asm.puts "lwz #{operands[1].ppcOperand}, 4(%r1)"
+            $asm.puts "addi %r1, %r1, 16"
+        when "fii2d"
+            $asm.puts "addi %r1, %r1, -16" # To make Valgrind happy
+            $asm.puts "stw #{operands[1].ppcOperand}, 0(%r1)"
+            $asm.puts "stw #{operands[0].ppcOperand}, 4(%r1)"
+            $asm.puts "lfd #{operands[2].ppcOperand}, 0(%r1)"
+            $asm.puts "addi %r1, %r1, 16"
+        when "jmp"
+            if operands[0].label?
+                $asm.puts "b #{operands[0].asmLabel}"
+            else
+                $asm.puts "mtctr #{operands[0].ppcOperand}"
+                $asm.puts "bctr"
+            end
+        when "leai", "leap"
+            operands[0].ppcEmitLea(operands[1])
+        when "leap"
+            $asm.puts "leap fixme"
+        when "loadb"
+            ppcEmitLoad(operands, "bz")
+        when "loadd"
+            ppcEmitLoad(operands, "fd")
+        when "loadh"
+            ppcEmitLoad(operands, "hz")
+        when "loadi", "loadis", "loadp"
+            ppcEmitLoad(operands, "wz")
+        when "lshifti", "lshiftp"
+            threeArgInstruction("slw", "slwi");
+        when "mflr"
+            $asm.puts "mflr #{operands[0].ppcOperand}"
+        when "move"
+            $stderr.puts "move op0: #{operands[0]}"
+            if operands[0].register? and operands[0].ppcOperand == "%notreallylr"
+                if operands[1].is_a? RegisterID
+                    $asm.puts "mflr #{operands[1].ppcOperands}"
+                else
+                    raise "Unsupported destination operand for lr move"
+                end
+            elsif operands[1].register? and operands[1].ppcOperand == "%notreallylr"
+                if operands[0].is_a? RegisterID
+                    $asm.puts "mtlr #{operands[0].ppcOperands}"
+                else
+                    raise "Unsupported source operand for lr move"
+                end
+            elsif operands[0].immediate? and (operands[0].value < -32768 or operands[0].value > 32767)
+                upper = (operands[0].value >> 16) & 0xffff
+                lower = operands[0].value & 0xffff
+
+                $asm.puts "lis #{operands[1].ppcOperand}, #{upper}"
+                $asm.puts "ori #{operands[1].ppcOperand}, #{operands[1].ppcOperand}, #{lower}"
+            else
+                twoArgInstruction("mr", "li");
+            end
+        when "mtlr"
+            $asm.puts "mtlr #{operands[0].ppcOperand}"
+        when "muld"
+            threeArgInstruction("fmul", "fmulfixme");
+        when "muli", "mulp"
+            threeArgInstruction("mullw", "mulli");
+        when "negi", "negp"
+            oneOrTwoArgInstruction("neg", "negi");
+        when "ori", "orp"
+            threeArgInstruction("or", "ori");
+        when "oris"
+            threeArgInstruction("or.", "ori.");
+        when "ret"
+            $asm.puts "blr"
+        when "rshifti", "rshiftp"
+            threeArgInstruction("sraw", "srawi");
+        when "smulli"
+            $asm.puts "mullw #{operands[2].ppcOperand}, #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+            $asm.puts "mulhw #{operands[3].ppcOperand}, #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+        when "storeb"
+            ppcEmitStore(operands, "b")
+        when "stored"
+            ppcEmitStore(operands, "fd")
+        when "storeh"
+            ppcEmitStore(operands, "h")
+        when "storei", "storep"
+            if operands[0].register? and operands[0].ppcOperand == "%notreallylr"
+                $asm.puts "mflr %r12"
+                operands[0] = SpecialRegister.new("%r12")
+            end
+            ppcEmitStore(operands, "w")
+        when "stwu"
+            $asm.puts "stwu #{ppcOperands(operands)}"
+        when "subd"
+            threeArgInstruction("fsub", "fsubfixme");
+        when "subi", "subp"
+            threeArgInstruction("sub", "subi");
+        when "subis", "subps"
+            if operands[0].immediate?
+                $asm.puts "li %r12, #{operands[0].ppcOperand}"
+                if operands.size == 3
+                    $asm.puts "subo. #{operands[2].ppcOperand}, #{operands[1].ppcOperand}, %r12"
+                else
+                    $asm.puts "subo. #{operands[1].ppcOperand}, #{operands[1].ppcOperand}, %r12"
+                end
+            else
+                threeArgInstruction("subo.", "subo. fixme");
+            end
+        when "urshifti", "urshiftp"
+            threeArgInstruction("srw", "srwi");
+        when "xori", "xorp"
+            threeArgInstruction("xor", "xori");
+        else
+            lowerDefault
+        end
+    end
+end
+
+def ppcEmitLoad(operands, type)
+    if operands[0].is_a? Address
+        $asm.puts "l#{type} #{operands[1].ppcOperand}, #{operands[0].ppcOperand}"
+    elsif operands[0].is_a? SpecialRegister or operands[0].is_a? RegisterID
+        $asm.puts "l#{type}x #{operands[1].ppcOperand}, %r0, #{operands[0].ppcOperand}"
+    else
+        raise "ppcEmitLoad: Source has unknown type: #{operands[0]}"
+    end
+end
+
+def ppcEmitStore(operands, type)
+    if operands[1].is_a? Address
+        $asm.puts "st#{type} #{operands[0].ppcOperand}, #{operands[1].ppcOperand}"
+    elsif operands[1].is_a? SpecialRegister or operands[1].is_a? RegisterID
+        $asm.puts "st#{type}x #{operands[0].ppcOperand}, %r0, #{operands[1].ppcOperand}"
+    else
+        raise "ppcEmitStore: Source has unknown type: #{operands[0]}"
+    end
+end
+
+def ppcLowerBaseIndex(list)
+    newList = []
+    list.each {
+        | node |
+        if node.is_a? Instruction
+            operands = node.operands
+            newOperands = []
+            operands.each {
+                | operand |
+                if operand.is_a? BaseIndex
+                    tmp = Tmp.new(operand.codeOrigin, :gpr)
+
+                    if operand.scale == 1
+                        newList << Instruction.new(operand.codeOrigin, "addp", [operand.base, operand.index, tmp])
+                    else
+                        newList << Instruction.new(operand.codeOrigin, "mulp", [Immediate.new(codeOrigin, operand.scale), operand.index, tmp])
+                        newList << Instruction.new(operand.codeOrigin, "addp", [operand.base, tmp])
+                    end
+
+                    if operand.offset.value != 0
+                        #newList << Instruction.new(operand.codeOrigin, "addp", [Immediate.new(codeOrigin, operand.offset.value), tmp])
+                        newList << Instruction.new(operand.codeOrigin, "addp", [operand.offset, tmp])
+                    end
+
+                    newOperands << tmp
+                else
+                    newOperands << operand
+                end
+            }
+            newList << Instruction.new(node.codeOrigin, node.opcode, newOperands, node.annotation)
+        else
+            newList << node
+        end
+    }
+    newList
+end
+
+
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/offlineasm/registers.rb attempt-5-161078/WebKit.161078/Source/JavaScriptCore/offlineasm/registers.rb
--- clean/WebKit.161078/Source/JavaScriptCore/offlineasm/registers.rb	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/offlineasm/registers.rb	2018-06-12 14:28:02.385669123 +0000
@@ -47,7 +47,28 @@
      
      # 64-bit only registers:
      "csr1",  # tag type number register
-     "csr2"   # tag mask register
+     "csr2",  # tag mask register
+
+     # PPC registers
+     "r13",
+     "r14",
+     "r15",
+     "r16",
+     "r17",
+     "r18",
+     "r19",
+     "r20",
+     "r21",
+     "r22",
+     "r23",
+     "r24",
+     "r25",
+     "r26",
+     "r27",
+     "r28",
+     "r29",
+     "r30",
+     "r31"
     ]
 
 FPRS =
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/offlineasm/risc.rb attempt-5-161078/WebKit.161078/Source/JavaScriptCore/offlineasm/risc.rb
--- clean/WebKit.161078/Source/JavaScriptCore/offlineasm/risc.rb	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/offlineasm/risc.rb	2018-06-12 14:28:02.385669123 +0000
@@ -113,7 +113,7 @@
 #
 # will become:
 #
-# andi foo, 31, tmp
+# andi 31, foo, tmp
 # lshifti tmp, bar
 #
 
@@ -121,7 +121,7 @@
     return operand if operand.immediate?
     
     tmp = Tmp.new(operand.codeOrigin, :gpr)
-    list << Instruction.new(operand.codeOrigin, "andi", [operand, Immediate.new(operand.codeOrigin, 31), tmp])
+    list << Instruction.new(operand.codeOrigin, "andi", [Immediate.new(operand.codeOrigin, 31), operand, tmp])
     tmp
 end
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/CommonSlowPaths.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/CommonSlowPaths.h
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/CommonSlowPaths.h	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/CommonSlowPaths.h	2018-06-12 14:28:02.385669123 +0000
@@ -127,8 +127,8 @@
 
 typedef union {
     struct {
-        void* a;
         void* b;
+        void* a;
     } pair;
     int64_t i;
 } SlowPathReturnTypeEncoding;
@@ -136,8 +136,8 @@
 inline SlowPathReturnType encodeResult(void* a, void* b)
 {
     SlowPathReturnTypeEncoding u;
-    u.pair.a = a;
-    u.pair.b = b;
+    u.pair.a = b;
+    u.pair.b = a;
     return u.i;
 }
 
@@ -145,8 +145,8 @@
 {
     SlowPathReturnTypeEncoding u;
     u.i = result;
-    a = u.pair.a;
-    b = u.pair.b;
+    b = u.pair.a;
+    a = u.pair.b;
 }
 #endif // USE(JSVALUE32_64)
     
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/ConstructData.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/ConstructData.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/ConstructData.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/ConstructData.cpp	2018-06-14 05:58:12.185001953 +0000
@@ -36,6 +36,7 @@
 
 JSObject* construct(ExecState* exec, JSValue constructorObject, ConstructType constructType, const ConstructData& constructData, const ArgList& args)
 {
+    EXECUTEDPRINTF("%s:%d/%s(): Called from 0x%08x\n", __FILE__, __LINE__, __func__, __builtin_return_address(0));
     ASSERT(constructType == ConstructTypeJS || constructType == ConstructTypeHost);
     return exec->interpreter()->executeConstruct(exec, asObject(constructorObject), constructType, constructData, args);
 }
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/FunctionPrototype.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/FunctionPrototype.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/FunctionPrototype.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/FunctionPrototype.cpp	2018-06-14 08:04:10.119519011 +0000
@@ -105,22 +105,28 @@
 
 EncodedJSValue JSC_HOST_CALL functionProtoFuncToString(ExecState* exec)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): Called from 0x%08x\n", __FILE__, __LINE__, __func__, __builtin_return_address(0));
     JSValue thisValue = exec->hostThisValue();
     if (thisValue.inherits(JSFunction::info())) {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         JSFunction* function = jsCast<JSFunction*>(thisValue);
         if (function->isHostFunction())
             return JSValue::encode(jsMakeNontrivialString(exec, "function ", function->name(exec), "() {\n    [native code]\n}"));
         FunctionExecutable* executable = function->jsExecutable();
         String sourceString = executable->source().toString();
         insertSemicolonIfNeeded(sourceString, executable->bodyIncludesBraces());
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         return JSValue::encode(jsMakeNontrivialString(exec, "function ", function->name(exec), "(", executable->paramString(), ") ", sourceString));
     }
 
     if (thisValue.inherits(InternalFunction::info())) {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         InternalFunction* function = asInternalFunction(thisValue);
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
         return JSValue::encode(jsMakeNontrivialString(exec, "function ", function->name(exec), "() {\n    [native code]\n}"));
     }
 
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     return throwVMTypeError(exec);
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/JSBoundFunction.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSBoundFunction.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/JSBoundFunction.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSBoundFunction.cpp	2018-06-14 08:15:24.896917111 +0000
@@ -36,6 +36,8 @@
 
 EncodedJSValue JSC_HOST_CALL boundFunctionCall(ExecState* exec)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): Called from 0x%08x\n", __FILE__, __LINE__, __func__, __builtin_return_address(0));
+    EncodedJSValue retval;
     JSBoundFunction* boundFunction = jsCast<JSBoundFunction*>(exec->callee());
 
     ASSERT(isJSArray(boundFunction->boundArgs())); // Currently this is true!
@@ -51,11 +53,15 @@
     CallData callData;
     CallType callType = getCallData(targetFunction, callData);
     ASSERT(callType != CallTypeNone);
-    return JSValue::encode(call(exec, targetFunction, callType, callData, boundFunction->boundThis(), args));
+    retval = JSValue::encode(call(exec, targetFunction, callType, callData, boundFunction->boundThis(), args));
+    CALLBACKDPRINTF("%s:%d/%s(): Returning 0x%016llx\n", __FILE__, __LINE__, __func__, retval);
+    return retval;
 }
 
 EncodedJSValue JSC_HOST_CALL boundFunctionConstruct(ExecState* exec)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): Called from 0x%08x\n", __FILE__, __LINE__, __func__, __builtin_return_address(0));
+    EncodedJSValue retval;
     JSBoundFunction* boundFunction = jsCast<JSBoundFunction*>(exec->callee());
 
     ASSERT(isJSArray(boundFunction->boundArgs())); // Currently this is true!
@@ -71,14 +77,24 @@
     ConstructData constructData;
     ConstructType constructType = getConstructData(targetFunction, constructData);
     ASSERT(constructType != ConstructTypeNone);
-    return JSValue::encode(construct(exec, targetFunction, constructType, constructData, args));
+    retval = JSValue::encode(construct(exec, targetFunction, constructType, constructData, args));
+    CALLBACKDPRINTF("%s:%d/%s(): Returning 0x%016llx\n", __FILE__, __LINE__, __func__, retval);
+    {
+        unsigned long long ull;
+        /* I don't know why I have to swap this... */
+        ull = retval;
+        retval = (ull<<32)|(ull>>32);
+    }
+    return retval;
 }
 
 JSBoundFunction* JSBoundFunction::create(VM& vm, JSGlobalObject* globalObject, JSObject* targetFunction, JSValue boundThis, JSValue boundArgs, int length, const String& name)
 {
+    COMPILEDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     ConstructData constructData;
     ConstructType constructType = JSC::getConstructData(targetFunction, constructData);
     bool canConstruct = constructType != ConstructTypeNone;
+    COMPILEDPRINTF("%s:%d/%s(): canConstruct %d, called from 0x%08x\n", __FILE__, __LINE__, __func__, (int)canConstruct, __builtin_return_address(0));
     NativeExecutable* executable = vm.getHostFunction(boundFunctionCall, canConstruct ? boundFunctionConstruct : callHostFunctionAsConstructor);
     JSBoundFunction* function = new (NotNull, allocateCell<JSBoundFunction>(vm.heap)) JSBoundFunction(vm, globalObject, globalObject->boundFunctionStructure(), targetFunction, boundThis, boundArgs);
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValue.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValue.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValue.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValue.cpp	2018-06-28 09:32:39.657157853 +0000
@@ -56,6 +56,7 @@
 
 double JSValue::toNumberSlowCase(ExecState* exec) const
 {
+    CALLBACKDPRINTF("%s:%d/%s(): this 0x%08x, tag 0x%08x, payload 0x%08x\n", __FILE__, __LINE__, __func__, this, u.asBits.tag, u.asBits.payload);
     ASSERT(!isInt32() && !isDouble());
     if (isCell())
         return asCell()->toNumber(exec);
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValue.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValue.h
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValue.h	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValue.h	2018-06-12 14:28:02.385669123 +0000
@@ -146,6 +146,7 @@
 #endif
 
     static EncodedJSValue encode(JSValue);
+    static EncodedJSValue encode_endian_workaround(JSValue);
     static JSValue decode(EncodedJSValue);
 
     enum JSNullTag { JSNull };
@@ -188,6 +189,7 @@
     bool isFalse() const;
 
     int32_t asInt32() const;
+    int64_t asInt64() const;
     uint32_t asUInt32() const;
     int64_t asMachineInt() const;
     double asDouble() const;
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValueInlines.h attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValueInlines.h
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValueInlines.h	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSCJSValueInlines.h	2018-07-16 09:21:23.201360258 +0000
@@ -145,11 +145,37 @@
 
 inline EncodedJSValue JSValue::encode(JSValue value)
 {
+	VALUEDPRINTF("%s:%d/%s(): Returning 0x%016llx\n", __FILE__, __LINE__, __func__, value.u.asInt64);
     return value.u.asInt64;
 }
 
+#if USE(JSVALUE32_64)
+inline EncodedJSValue JSValue::encode_endian_workaround(JSValue value)
+{
+#if 0
+    return JSValue::encode(value);
+#endif
+    return (((uint64_t)value.u.asBits.payload)<<32)|((uint64_t)(uint32_t)value.u.asBits.tag);
+}
+#else
+#error moo
+inline EncodedJSValue JSValue::encode_endian_workaround(JSValue value)
+{
+    return value.u.asInt64;
+}
+#endif
+
+extern int BreakOnInvalidValue;
+
 inline JSValue JSValue::decode(EncodedJSValue encodedJSValue)
 {
+    if (((unsigned int)(encodedJSValue>>32)) < 0xfffffff0
+     && ((unsigned int)encodedJSValue) == 0xfffffffb)
+    {
+        VALUEDPRINTF("%s:%d/%s(): tag 0x%08x payload 0x%08x\n", __FILE__, __LINE__, __func__, ((unsigned int)(encodedJSValue>>32)), ((unsigned int)encodedJSValue));
+        if (BreakOnInvalidValue)
+            asm volatile ("twi 31,0,0");
+    }
     JSValue v;
     v.u.asInt64 = encodedJSValue;
     return v;
@@ -194,11 +220,18 @@
 
 inline JSValue::JSValue(JSCell* ptr)
 {
+    VALUEDPRINTF("%s:%d/%s(): ptr 0x%08x\n", __FILE__, __LINE__, __func__, ptr);
     if (ptr)
+    {
+	VALUEDPRINTF("%s:%d/%s(): Cell\n", __FILE__, __LINE__, __func__, ptr);
         u.asBits.tag = CellTag;
+    }
     else
+    {
         u.asBits.tag = EmptyValueTag;
+    }
     u.asBits.payload = reinterpret_cast<int32_t>(ptr);
+    VALUEDPRINTF("%s:%d/%s(): tag 0x%08x payload 0x%08x\n", __FILE__, __LINE__, __func__, u.asBits.tag, u.asBits.payload);
 }
 
 inline JSValue::JSValue(const JSCell* ptr)
@@ -287,6 +320,11 @@
     return u.asBits.payload;
 }
     
+inline int64_t JSValue::asInt64() const
+{
+    return u.asInt64;
+}
+    
 inline double JSValue::asDouble() const
 {
     ASSERT(isDouble());
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/JSGlobalObject.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSGlobalObject.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/JSGlobalObject.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSGlobalObject.cpp	2018-07-16 10:04:52.285318741 +0000
@@ -185,6 +185,8 @@
 
 void JSGlobalObject::init(JSObject* thisValue)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+    CALLBACKDPRINTF("%s:%d/%s(): &vm() 0x%08x, vm().regExpCache() 0x%08x\n", __FILE__, __LINE__, __func__, &vm(), vm().regExpCache());
     ASSERT(vm().currentThreadIsHoldingAPILock());
 
     setGlobalThis(vm(), thisValue);
@@ -203,6 +205,7 @@
 
 void JSGlobalObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     JSGlobalObject* thisObject = jsCast<JSGlobalObject*>(cell);
     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(thisObject));
 
@@ -258,9 +261,14 @@
 
 void JSGlobalObject::reset(JSValue prototype)
 {
+    CALLBACKDPRINTF("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
     ExecState* exec = JSGlobalObject::globalExec();
     VM& vm = exec->vm();
 
+    CALLBACKDPRINTF("%s:%d/%s(): VM 0x%08x\n", __FILE__, __LINE__, __func__, &vm);
+
+    CALLBACKDPRINTF("%s:%d/%s(): vm.regExpCache() 0x%08x\n", __FILE__, __LINE__, __func__, vm.regExpCache());
+
     m_functionPrototype.set(vm, this, FunctionPrototype::create(vm, FunctionPrototype::createStructure(vm, this, jsNull()))); // The real prototype will be set once ObjectPrototype is created.
     m_functionStructure.set(vm, this, JSFunction::createStructure(vm, this, m_functionPrototype.get()));
     m_boundFunctionStructure.set(vm, this, JSBoundFunction::createStructure(vm, this, m_functionPrototype.get()));
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/JSObject.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSObject.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/JSObject.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/JSObject.cpp	2018-07-16 13:26:33.630817484 +0000
@@ -346,6 +346,8 @@
     ASSERT(value);
     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(thisObject));
     VM& vm = exec->vm();
+
+    CALLBACKDPRINTF("%s:%d/%s(): cell 0x%08x, exec 0x%08x, value 0x%016llx, slot 0x%08x\n", __FILE__, __LINE__, __func__, cell, exec, JSValue::encode(value), &slot);
     
     // Try indexed put first. This is required for correctness, since loads on property names that appear like
     // valid indices will never look in the named property storage.
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/NumberConstructor.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/NumberConstructor.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/NumberConstructor.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/NumberConstructor.cpp	2018-06-28 09:34:32.462040545 +0000
@@ -125,6 +125,7 @@
 // ECMA 15.7.2
 static EncodedJSValue JSC_HOST_CALL callNumberConstructor(ExecState* exec)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): argumentCount %d\n", __FILE__, __LINE__, __func__, exec->argumentCount());
     return JSValue::encode(jsNumber(!exec->argumentCount() ? 0 : exec->uncheckedArgument(0).toNumber(exec)));
 }
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/ObjectPrototype.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/ObjectPrototype.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/ObjectPrototype.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/ObjectPrototype.cpp	2018-07-16 13:24:55.618082425 +0000
@@ -178,9 +178,13 @@
 
 EncodedJSValue JSC_HOST_CALL objectProtoFuncPropertyIsEnumerable(ExecState* exec)
 {
+    foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+
     JSObject* thisObject = exec->hostThisValue().toThis(exec, StrictMode).toObject(exec);
     Identifier propertyName(exec, exec->argument(0).toString(exec)->value(exec));
 
+    foddprintf("%s:%d/%s(): thisObject 0x%08x\n", __FILE__, __LINE__, __func__, thisObject);
+
     PropertyDescriptor descriptor;
     bool enumerable = thisObject->getOwnPropertyDescriptor(exec, propertyName, descriptor) && descriptor.enumerable();
     return JSValue::encode(jsBoolean(enumerable));
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/Options.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/Options.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/Options.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/Options.cpp	2018-07-14 11:43:25.476152868 +0000
@@ -212,6 +212,21 @@
     useRegExpJIT() = false;
 #endif
 
+    if (getenv("OWB_NO_JIT"))
+    {
+        useJIT() = false;
+    }
+
+    if (getenv("OWB_NO_LLINT"))
+    {
+        useLLInt() = false;
+    }
+
+    if (getenv("OWB_NO_DFG"))
+    {
+        useDFGJIT() = false;
+    }
+
     // Do range checks where needed and make corrections to the options:
     ASSERT(thresholdForOptimizeAfterLongWarmUp() >= thresholdForOptimizeAfterWarmUp());
     ASSERT(thresholdForOptimizeAfterWarmUp() >= thresholdForOptimizeSoon());
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/PropertyDescriptor.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/PropertyDescriptor.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/PropertyDescriptor.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/PropertyDescriptor.cpp	2018-07-16 13:24:35.169929376 +0000
@@ -98,6 +98,10 @@
 
 void PropertyDescriptor::setDescriptor(JSValue value, unsigned attributes)
 {
+    foddprintf("%s:%d/%s():\n", __FILE__, __LINE__, __func__);
+
+    foddprintf("%s:%d/%s(): value 0x%016llx\n", __FILE__, __LINE__, __func__, JSValue::encode(value));
+
     ASSERT(value);
     ASSERT(value.isGetterSetter() == !!(attributes & Accessor));
 
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/runtime/RegExpConstructor.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/RegExpConstructor.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/runtime/RegExpConstructor.cpp	2018-05-20 14:50:45.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/runtime/RegExpConstructor.cpp	2018-06-12 14:28:02.389669156 +0000
@@ -45,8 +45,13 @@
 static EncodedJSValue regExpConstructorDollar8(ExecState*, EncodedJSValue, EncodedJSValue, PropertyName);
 static EncodedJSValue regExpConstructorDollar9(ExecState*, EncodedJSValue, EncodedJSValue, PropertyName);
 
+#if 0
 static void setRegExpConstructorInput(ExecState*, JSObject*, JSValue);
 static void setRegExpConstructorMultiline(ExecState*, JSObject*, JSValue);
+#else
+void setRegExpConstructorInput(ExecState* exec, EncodedJSValue encodedbaseObject, EncodedJSValue encodedValue);
+void setRegExpConstructorMultiline(ExecState* exec, EncodedJSValue encodedbaseObject, EncodedJSValue encodedValue);
+#endif
 
 } // namespace JSC
 
@@ -240,16 +245,33 @@
 
 void RegExpConstructor::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
 {
+    CALLBACKDPRINTF("%s:%d/%s(): cell 0x%08x, exec 0x%08x, value 0x%016llx, slot 0x%08x\n", __FILE__, __LINE__, __func__, cell, exec, JSValue::encode(value), &slot);
     lookupPut<RegExpConstructor, InternalFunction>(exec, propertyName, value, ExecState::regExpConstructorTable(exec), jsCast<RegExpConstructor*>(cell), slot);
 }
 
+#if 0
 void setRegExpConstructorInput(ExecState* exec, JSObject* baseObject, JSValue value)
-{
+#else
+void setRegExpConstructorInput(ExecState* exec, EncodedJSValue encodedBaseObject, EncodedJSValue encodedValue)
+#endif
+{
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, encodedBaseObject 0x%08x, encodedValue 0x%016llx\n", __FILE__, __LINE__, __func__, exec, encodedBaseObject, encodedValue);
+    JSObject *baseObject = (JSObject *)encodedBaseObject;
+    JSValue value = JSValue::decode(encodedValue);
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, baseObject 0x%08x, value 0x%016llx\n", __FILE__, __LINE__, __func__, exec, baseObject, JSValue::encode(value));
     asRegExpConstructor(baseObject)->setInput(exec, value.toString(exec));
 }
 
+#if 0
 void setRegExpConstructorMultiline(ExecState* exec, JSObject* baseObject, JSValue value)
-{
+#else
+void setRegExpConstructorMultiline(ExecState* exec, EncodedJSValue encodedBaseObject, EncodedJSValue encodedValue)
+#endif
+{
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, encodedBaseObject 0x%08x, encodedValue 0x%016llx\n", __FILE__, __LINE__, __func__, exec, encodedBaseObject, encodedValue);
+    JSObject *baseObject = (JSObject *)encodedBaseObject;
+    JSValue value = JSValue::decode(encodedValue);
+    CALLBACKDPRINTF("%s:%d/%s(): exec 0x%08x, baseObject 0x%08x, value 0x%016llx\n", __FILE__, __LINE__, __func__, exec, baseObject, JSValue::encode(value));
     asRegExpConstructor(baseObject)->setMultiline(value.toBoolean(exec));
 }
 
@@ -306,6 +328,7 @@
 static EncodedJSValue JSC_HOST_CALL callRegExpConstructor(ExecState* exec)
 {
     ArgList args(exec);
+    /* Called from generateSlowCaseFor() */
     return JSValue::encode(constructRegExp(exec, asInternalFunction(exec->callee())->globalObject(), args));
 }
 
Binary files clean/WebKit.161078/Source/JavaScriptCore/tests/mozilla/core and attempt-5-161078/WebKit.161078/Source/JavaScriptCore/tests/mozilla/core differ
diff -x GNUmakefile.in -x GNUmakefile -x 'stamp-*' -x actual.html -x gtk -x '*.pc' -x 'WebKitFeatures.*' -x libtool -x configure -x config.log -x config.status -x Programs -x '*.gir' -x DerivedSources -x '*.la' -x '*.lo' -x .libs -x .deps -x 'autotool*' -x aclocal.m4 -x Tools -x calls -x autotools -x WebInspectorUI -x WebCore -x LayoutTests -x WTF -ruN clean/WebKit.161078/Source/JavaScriptCore/yarr/YarrJIT.cpp attempt-5-161078/WebKit.161078/Source/JavaScriptCore/yarr/YarrJIT.cpp
--- clean/WebKit.161078/Source/JavaScriptCore/yarr/YarrJIT.cpp	2018-05-20 14:50:46.000000000 +0000
+++ attempt-5-161078/WebKit.161078/Source/JavaScriptCore/yarr/YarrJIT.cpp	2018-06-12 14:28:02.389669156 +0000
@@ -118,6 +118,8 @@
 
     static const RegisterID returnRegister = X86Registers::eax;
     static const RegisterID returnRegister2 = X86Registers::edx;
+#else
+#error moo
 #endif
 
     void optimizeAlternative(PatternAlternative* alternative)
Binary files clean/WebKit.161078/Source/WebKit2/PluginProcess/Programs_WebKitPluginProcess-PluginControllerProxy.o and attempt-5-161078/WebKit.161078/Source/WebKit2/PluginProcess/Programs_WebKitPluginProcess-PluginControllerProxy.o differ
Binary files clean/WebKit.161078/Source/WebKit2/PluginProcess/Programs_WebKitPluginProcess-PluginCreationParameters.o and attempt-5-161078/WebKit.161078/Source/WebKit2/PluginProcess/Programs_WebKitPluginProcess-PluginCreationParameters.o differ
Binary files clean/WebKit.161078/Source/WebKit2/PluginProcess/Programs_WebKitPluginProcess-PluginProcess.o and attempt-5-161078/WebKit.161078/Source/WebKit2/PluginProcess/Programs_WebKitPluginProcess-PluginProcess.o differ
Binary files clean/WebKit.161078/Source/WebKit2/PluginProcess/Programs_WebKitPluginProcess-WebProcessConnection.o and attempt-5-161078/WebKit.161078/Source/WebKit2/PluginProcess/Programs_WebKitPluginProcess-WebProcessConnection.o differ
Binary files clean/WebKit.161078/Source/WebKit2/PluginProcess/unix/Programs_WebKitPluginProcess-PluginControllerProxyUnix.o and attempt-5-161078/WebKit.161078/Source/WebKit2/PluginProcess/unix/Programs_WebKitPluginProcess-PluginControllerProxyUnix.o differ
Binary files clean/WebKit.161078/Source/WebKit2/PluginProcess/unix/Programs_WebKitPluginProcess-PluginProcessMainUnix.o and attempt-5-161078/WebKit.161078/Source/WebKit2/PluginProcess/unix/Programs_WebKitPluginProcess-PluginProcessMainUnix.o differ
Binary files clean/WebKit.161078/Source/WebKit2/PluginProcess/unix/Programs_WebKitPluginProcess-PluginProcessUnix.o and attempt-5-161078/WebKit.161078/Source/WebKit2/PluginProcess/unix/Programs_WebKitPluginProcess-PluginProcessUnix.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Scripts/webkit2/__init__.pyc and attempt-5-161078/WebKit.161078/Source/WebKit2/Scripts/webkit2/__init__.pyc differ
Binary files clean/WebKit.161078/Source/WebKit2/Scripts/webkit2/messages.pyc and attempt-5-161078/WebKit.161078/Source/WebKit2/Scripts/webkit2/messages.pyc differ
Binary files clean/WebKit.161078/Source/WebKit2/Scripts/webkit2/model.pyc and attempt-5-161078/WebKit.161078/Source/WebKit2/Scripts/webkit2/model.pyc differ
Binary files clean/WebKit.161078/Source/WebKit2/Scripts/webkit2/parser.pyc and attempt-5-161078/WebKit.161078/Source/WebKit2/Scripts/webkit2/parser.pyc differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Plugins/Netscape/Programs_WebKitPluginProcess-NetscapePluginModule.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Plugins/Netscape/Programs_WebKitPluginProcess-NetscapePluginModule.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Plugins/Netscape/x11/Programs_WebKitPluginProcess-NetscapePluginModuleX11.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Plugins/Netscape/x11/Programs_WebKitPluginProcess-NetscapePluginModuleX11.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-NPIdentifierData.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-NPIdentifierData.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-NPObjectMessageReceiver.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-NPObjectMessageReceiver.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-NPObjectProxy.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-NPObjectProxy.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-NPRemoteObjectMap.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-NPRemoteObjectMap.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-NPVariantData.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-NPVariantData.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-PluginProcessCreationParameters.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Plugins/Programs_WebKitPluginProcess-PluginProcessCreationParameters.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-ActivityAssertion.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-ActivityAssertion.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-ChildProcess.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-ChildProcess.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-ChildProcessProxy.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-ChildProcessProxy.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-ConnectionStack.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-ConnectionStack.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-ShareableBitmap.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-ShareableBitmap.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebCoreArgumentCoders.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebCoreArgumentCoders.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebEvent.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebEvent.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebKeyboardEvent.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebKeyboardEvent.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebKit2Initialize.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebKit2Initialize.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebMouseEvent.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebMouseEvent.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebWheelEvent.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/Programs_WebKitPluginProcess-WebWheelEvent.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/cairo/Programs_WebKitPluginProcess-ShareableBitmapCairo.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/cairo/Programs_WebKitPluginProcess-ShareableBitmapCairo.o differ
Binary files clean/WebKit.161078/Source/WebKit2/Shared/soup/Programs_WebKitPluginProcess-WebCoreArgumentCodersSoup.o and attempt-5-161078/WebKit.161078/Source/WebKit2/Shared/soup/Programs_WebKitPluginProcess-WebCoreArgumentCodersSoup.o differ
Binary files clean/WebKit.161078/Source/WebKit2/UIProcess/Launcher/Programs_WebKitPluginProcess-ProcessLauncher.o and attempt-5-161078/WebKit.161078/Source/WebKit2/UIProcess/Launcher/Programs_WebKitPluginProcess-ProcessLauncher.o differ
Binary files clean/WebKit.161078/Source/WebKit2/UIProcess/Plugins/unix/Programs_WebKitPluginProcess-PluginProcessProxyUnix.o and attempt-5-161078/WebKit.161078/Source/WebKit2/UIProcess/Plugins/unix/Programs_WebKitPluginProcess-PluginProcessProxyUnix.o differ
Binary files clean/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Netscape/Programs_WebKitPluginProcess-NPRuntimeUtilities.o and attempt-5-161078/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Netscape/Programs_WebKitPluginProcess-NPRuntimeUtilities.o differ
Binary files clean/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Netscape/Programs_WebKitPluginProcess-NetscapeBrowserFuncs.o and attempt-5-161078/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Netscape/Programs_WebKitPluginProcess-NetscapeBrowserFuncs.o differ
Binary files clean/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Netscape/Programs_WebKitPluginProcess-NetscapePlugin.o and attempt-5-161078/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Netscape/Programs_WebKitPluginProcess-NetscapePlugin.o differ
Binary files clean/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Netscape/Programs_WebKitPluginProcess-NetscapePluginStream.o and attempt-5-161078/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Netscape/Programs_WebKitPluginProcess-NetscapePluginStream.o differ
Binary files clean/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Netscape/x11/Programs_WebKitPluginProcess-NetscapePluginX11.o and attempt-5-161078/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Netscape/x11/Programs_WebKitPluginProcess-NetscapePluginX11.o differ
Binary files clean/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Programs_WebKitPluginProcess-Plugin.o and attempt-5-161078/WebKit.161078/Source/WebKit2/WebProcess/Plugins/Programs_WebKitPluginProcess-Plugin.o differ
Binary files clean/WebKit.161078/Source/WebKit2/unix/Programs_WebKitNetworkProcess-NetworkMainUnix.o and attempt-5-161078/WebKit.161078/Source/WebKit2/unix/Programs_WebKitNetworkProcess-NetworkMainUnix.o differ
Binary files clean/WebKit.161078/Source/WebKit2/unix/Programs_WebKitPluginProcess-PluginMainUnix.o and attempt-5-161078/WebKit.161078/Source/WebKit2/unix/Programs_WebKitPluginProcess-PluginMainUnix.o differ
Binary files clean/WebKit.161078/core and attempt-5-161078/WebKit.161078/core differ
Binary files clean/WebKit.161078/core.old and attempt-5-161078/WebKit.161078/core.old differ
Binary files clean/WebKit.161078/libWebCoreLayerGtk2.a and attempt-5-161078/WebKit.161078/libWebCoreLayerGtk2.a differ
